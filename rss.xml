<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Youthfulhps.dev]]></title><description><![CDATA[Blog posted front-end, troubleshooting!]]></description><link>https://youthfulhps.dev</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 10 Dec 2023 15:21:13 GMT</lastBuildDate><item><title><![CDATA[node.js에서 하나의 모듈 시스템을 사용하는 날이 올까]]></title><description><![CDATA[…]]></description><link>https://youthfulhps.dev/javascript/nodejs-module-system/</link><guid isPermaLink="false">https://youthfulhps.dev/javascript/nodejs-module-system/</guid><pubDate>Thu, 09 Nov 2023 13:05:26 GMT</pubDate><content:encoded>&lt;p&gt;최근 라이브러리를 제작하면서 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;ECMAScript&lt;/code&gt; 모듈 시스템(이하 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;)에 대한 모듈 시스템 포맷이 혼란스러웠던 기억이 있다. 패키지를 빌드할 때 각각의
모듈 시스템을 사용하는 포맷으로 빌드 결과물을 만들어 주어야 했는데, 사실 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;require&lt;/code&gt; 등 구문 정도의 차이를 이해했을 뿐 모듈 시스템의 구조적인
라이브러리 제작자로서 대응해 주어야 하는 작업에 대해 크게 고민해 본 적이 없었기 때문일 것이다.&lt;/p&gt;
&lt;p&gt;특히나 최신 프론트엔드 개발 환경에 익숙한 개발자라면 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;을 일상적으로 사용하고 있어 가령 &lt;code class=&quot;language-text&quot;&gt;require&lt;/code&gt;이 번들링에 어떤 영향을 끼치는지 궁금해 하기란 사실 쉽지 않은 일이고,
&lt;code class=&quot;language-text&quot;&gt;node.js&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;도 공식적으로 지원하기 시작하면서 독립적으로 개발된 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt; 모듈 시스템을 청산해야 한다는 이야기도 많은 탓에 자연스럽게 멀리하게 된다.&lt;/p&gt;
&lt;p&gt;그러나 &lt;code class=&quot;language-text&quot;&gt;node.js&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt; 모듈 시스템 기반으로 제작되어 있는 라이브러리 생태계가 건재하고, 여전히 두 모듈 시스템이 공존하고 있기 때문에 각각의 모듈 시스템의
이해와 현 상황을 이해할 필요가 있다. 언젠가 &lt;code class=&quot;language-text&quot;&gt;node.js&lt;/code&gt; 생태계에서 하나의 모듈 시스템을 사용하는 날이 오길 기대하며 현재 &lt;code class=&quot;language-text&quot;&gt;node.js&lt;/code&gt;가 지원하고 있는 대표적인
모듈 시스템들을 살펴보자.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 984px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 47.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACmElEQVQozx2S32/aBhSFra1alzQE88MUDJiAa8CBGJvgQABjEgxJIMCSBpqU0DZTlqRLtjXrpkrTqr2uj/uLv3l7uDrSle53dc69QjAgEVgLocZjXDpl7g8tzroumfwxTv8nZssveKNPFMwF3uQvzt7+g9m6R7OWtLyPdId/opYX7LiPeOPPCJlglHggjCpJXLV1HgYG09Yuha0xpycPXN9+YTD+jaIx9Yd/52TxN0bjmrx5Qbv/SKv3SEZ/ie3e0xk8IlQ3NLoljWY+xaKucrun8+PEo1CZ8Mt8xse7T7ijX+laDRYHY0azz5TsJZrx0gf+TK1zQyo/odq+obl/h3A7drk9MOlbKhc1hbtOjsv9OpmcQyZdQ1W7dL0rSlmV4x2To9Edem3h25zSHjxg7r4hkTvEbF6x0/keYbpbxivJvLIVTg2ZcyvBsFqgbA6QYhbrIRPHnSMFReJhEW/wDq0yY0M/otV/T9k+J5bpUWkssdtvEZxchEM9xr2bZapHmZUl9nWFQrlHOrWNLFextg8IrjzlyddfYTdnZDcnJF94NHvXbFqnRFIuWz7Yai4QPnTTvG/FWVZFvisEmW+K9IopMlqHUqmNVWpSa0yJBCWCftWd1yjFIXJu37/yD/8Dw3LLz3Xu279AuLIjvKnLvPO2ed1rcD1ymTeKpBWTgt5BVpoY5h4hMcnqqohWdIn7vai8zaZ5jKK6rIe3fO2w8aKNcGmsMa8mODk85vzkjJuLS/447WMXDOKpKmI4j6JUCIWyPP1mlXg8TzRZR/TzVTSX5+kGa+GKv6RFcsNBWDRzzJwtjpw2w26H5bDPh+EeVq6IlND57/GjMY1nz2RWvg0Qi6mIUpVAxCCZdYgmbFbWS77WeZ7a5V9EWkePtDG0YgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;썸네일&quot;
        title=&quot;썸네일&quot;
        src=&quot;/static/72f35027b0c63e01aa9029dd3e9b0c79/0b6f4/thumbnail.png&quot;
        srcset=&quot;/static/72f35027b0c63e01aa9029dd3e9b0c79/5a46d/thumbnail.png 300w,
/static/72f35027b0c63e01aa9029dd3e9b0c79/0a47e/thumbnail.png 600w,
/static/72f35027b0c63e01aa9029dd3e9b0c79/0b6f4/thumbnail.png 984w&quot;
        sizes=&quot;(max-width: 984px) 100vw, 984px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;자바스크립트-구동-환경을-확장하기-위한-행보&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B5%AC%EB%8F%99-%ED%99%98%EA%B2%BD%EC%9D%84-%ED%99%95%EC%9E%A5%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%ED%96%89%EB%B3%B4&quot; aria-label=&quot;자바스크립트 구동 환경을 확장하기 위한 행보 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;자바스크립트 구동 환경을 확장하기 위한 행보&lt;/h2&gt;
&lt;p&gt;웹 브라우저의 동적인 조작을 구사하기 위해 탄생한 자바스크립트는 브라우저와 함께 성장과 인기를 얻게 되었다. 이에 따라 브라우저뿐만 아니라 더 다양한 환경에서
자바스크립트를 사용하고자 원하는 목소리들도 커지게 된다.&lt;/p&gt;
&lt;p&gt;그 중 단순히 니즈만 내세우는 것이 아니라 구체적인 액션 플랜을 제안한 Kevin Dangoor는 &lt;a href=&quot;https://www.blueskyonmars.com/2009/01/29/what-server-side-javascript-needs/&quot;&gt;What Server Side JavaScript needs&lt;/a&gt;
라는 제목의 글을 통해 자바스크립트가 다른 환경에서 사용되기 위해 선행되어야 하는 작업들을 나열했다.&lt;/p&gt;
&lt;p&gt;더불어 오늘날 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;라 불리는 모듈 시스템을 제작하기 위한 그룹을 결성하고 라이브러리, 인터페이스, 패키지 매니저, 그리고 오늘의 주제인 모듈 시스템에
대한 표준화 작업을 진행하게 된다.&lt;/p&gt;
&lt;h2 id=&quot;commonjs&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#commonjs&quot; aria-label=&quot;commonjs permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;CommonJS&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;javascript, not just for browsers any more!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;는 자바스크립트를 브라우저 외에도 서버사이드를 포함한 다양한 환경에서 범용적으로 사용할 수 있도록 &lt;a href=&quot;https://arstechnica.com/information-technology/2009/12/commonjs-effort-sets-javascript-on-path-for-world-domination/&quot;&gt;다양한 기능&lt;/a&gt;
들을 표준화했고, 이때 제작된 모듈 시스템은 &lt;code class=&quot;language-text&quot;&gt;node.js&lt;/code&gt;에서 사용되는 모듈 시스템의 근본이 된다.&lt;/p&gt;
&lt;h3 id=&quot;모듈-불러오기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%AA%A8%EB%93%88-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0&quot; aria-label=&quot;모듈 불러오기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;모듈 불러오기&lt;/h3&gt;
&lt;p&gt;모듈 시스템의 기본적인 동작인 모듈을 불러오고, 내보내는 기능들을 코드에서 살펴보자. &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;require&lt;/code&gt; 함수를 통해 모듈을 불러와 사용한다.
여기서 &lt;code class=&quot;language-text&quot;&gt;require&lt;/code&gt;은 동적으로 모듈을 불러와 사용하기 때문에 최상단에서만 모듈을 불러오는 제약을 가지는 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;과 차이가 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// import
const math = require(&amp;#39;math.js&amp;#39;);

if (condition) {
  const square = require(&amp;#39;square.js&amp;#39;);
  square.area(3);
}

math.add(1, 2);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;정적-바인딩&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%95%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9&quot; aria-label=&quot;정적 바인딩 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;정적 바인딩&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;는 모듈이 정적으로 바인딩되는 것이 특징이다. 정적 바인딩이란, &lt;code class=&quot;language-text&quot;&gt;require&lt;/code&gt;을 통해 불러온 값의 복사본을 사용한다는 것과 같다. 이는 불러온 모듈 내에서
내보내진 값의 변경이 발생해도 사용처에서는 변경된 값을 알 수 없다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// lib.js
var counter = 3;
function incCounter() {
  counter++;
}
module.exports = {
  counter,
  incCounter,
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// main.js
var counter = require(&amp;#39;./lib&amp;#39;).counter;
var incCounter = require(&amp;#39;./lib&amp;#39;).incCounter;

// The imported value is a (disconnected) copy of a copy
console.log(counter); // 3
incCounter();
console.log(counter); // 3

// The imported value can be changed
counter++;
console.log(counter); // 4&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;동기적인-모듈-실행&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8F%99%EA%B8%B0%EC%A0%81%EC%9D%B8-%EB%AA%A8%EB%93%88-%EC%8B%A4%ED%96%89&quot; aria-label=&quot;동기적인 모듈 실행 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;동기적인 모듈 실행&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;는 모듈을 동기적으로 불러와 하나씩 순서대로 실행한다. 동적으로 모듈을 불러오는 탓에 런타임에 모듈 요청 여부를 판단할 수 있어 모듈 요청이 이루어진
후에야 모듈 내에서 발생하는 여러 동작들을 동기적으로 완료한 후 내보내진 값을 취할 수 있게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// module1.js ~ module2.js
console.log(&amp;#39;Module1 loading...&amp;#39;);

setTimeout(() =&amp;gt; {
  console.log(&amp;#39;Module1 load complete and run!&amp;#39;);
}, 1000);

console.log(&amp;#39;Module1 run completed!&amp;#39;);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// index.js
console.log(&amp;#39;Run index!&amp;#39;);
const module1 = require(&amp;#39;./module1&amp;#39;);
console.log(&amp;#39;index:...&amp;#39;);
const module2 = require(&amp;#39;./module2&amp;#39;);
console.log(&amp;#39;index run completed!&amp;#39;);

// Run index!
// Module1 loading...
// Module1 run completed!
// index:...
// Module2 loading...
// Module2 run completed!
// index 종료!
// Module1 load complete and run!
// Module2 load complete and run!
// index run completed!&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;로드가-완료된-모듈은-캐싱된다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A1%9C%EB%93%9C%EA%B0%80-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%AA%A8%EB%93%88%EC%9D%80-%EC%BA%90%EC%8B%B1%EB%90%9C%EB%8B%A4&quot; aria-label=&quot;로드가 완료된 모듈은 캐싱된다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;로드가 완료된 모듈은 캐싱된다&lt;/h3&gt;
&lt;p&gt;한번 로드가 완료된 모듈에 대해서 캐싱되고, 이후 같은 모듈 요청에 대해 캐싱된 값을 반환한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// module1.js
console.log(&amp;#39;Run Module1!&amp;#39;);

module.exports = &amp;#39;Module1&amp;#39;;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const module1 = require(&amp;#39;./module1&amp;#39;);
const module2 = require(&amp;#39;./module1&amp;#39;);
const module3 = require(&amp;#39;./module1&amp;#39;);

console.log(module1, module2, module3);

// Run Module1!
// Module1 Module1 Module1&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;만약 캐싱을 지우고 싶다면, &lt;code class=&quot;language-text&quot;&gt;require.cache&lt;/code&gt;에 접근해 제거할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const module1 = require(&amp;#39;./module1&amp;#39;);

delete require.cache[require.resolve(&amp;#39;./module1&amp;#39;)];

const module2 = require(&amp;#39;./module1&amp;#39;);
const module3 = require(&amp;#39;./module1&amp;#39;);

console.log(module1, module2, module3);

// Run Module1!
// Run Module1!
// Module1 Module1 Module1&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;모듈-내보내기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%AA%A8%EB%93%88-%EB%82%B4%EB%B3%B4%EB%82%B4%EA%B8%B0&quot; aria-label=&quot;모듈 내보내기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;모듈 내보내기&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;는 모듈 각각의 독립적인 실행 영역과 스코프를 유지한 채 &lt;code class=&quot;language-text&quot;&gt;module.exports&lt;/code&gt;나 축약된 숏컷인 &lt;code class=&quot;language-text&quot;&gt;exports&lt;/code&gt;를 통해
모듈을 내보낼 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const { PI } = Math;

function add(a, b) {
  return a + b;
}

function subtract(a, b) {
  return a - b;
}

function circumference(r) {
  return 2 * PI * r;
}

module.exports.add = add;
module.exports.subtract = subtract;
exports.circumference = circumference;

console.log(module.exports === exports); // true&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;node.js&lt;/code&gt;에서 내보내진 모듈을 구성할 때 &lt;code class=&quot;language-text&quot;&gt;module wrapper&lt;/code&gt; 함수를 통해 모듈 내의 코드를 래핑한다. 이는 위 예시 코드의 &lt;code class=&quot;language-text&quot;&gt;Math&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;PI&lt;/code&gt;와 같이
모듈에서 내보내지 않은 값들을 지역 변수로 은닉하여 글로벌 객체에 등록되는 것을 막는다. 또한 &lt;code class=&quot;language-text&quot;&gt;module wrapper&lt;/code&gt; 함수의 매개 변수들을
통해 글로벌 객체의 값들을 참조할 수 있게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;(function(exports, require, module, __filename, _dirname) {
  // ... (모듈 코드)
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;moduleexports와-exports&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#moduleexports%EC%99%80-exports&quot; aria-label=&quot;moduleexports와 exports permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;module.exports와 exports&lt;/h3&gt;
&lt;p&gt;모듈 내보내기의 예시 코드에서 &lt;code class=&quot;language-text&quot;&gt;module.exports&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;exports&lt;/code&gt;가 함께 사용된 것을 확인할 수 있다. 이 둘의 차이가 있을 까 싶지만
&lt;a href=&quot;https://nodejs.org/api/modules.html#exports&quot;&gt;공식 문서&lt;/a&gt;에서 알 수 있듯 &lt;code class=&quot;language-text&quot;&gt;exports&lt;/code&gt;는 단지 &lt;code class=&quot;language-text&quot;&gt;module.exports&lt;/code&gt;의 축약된 &lt;code class=&quot;language-text&quot;&gt;shortcut&lt;/code&gt;인 것이다.&lt;/p&gt;
&lt;p&gt;즉 &lt;code class=&quot;language-text&quot;&gt;exports&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;module.exports&lt;/code&gt;가 기본적으로 내보낼 객체를 동일하게 가리키고 있어 위와 같이 객체에 새로운 키를 추가하여 내보낼 객체에 새로운 프로퍼티를
할당하는 것은 어느 것을 사용해도 동일한 결과를 얻는다.&lt;/p&gt;
&lt;p&gt;그러나 주의해야 할 점은 &lt;code class=&quot;language-text&quot;&gt;exports&lt;/code&gt;나 &lt;code class=&quot;language-text&quot;&gt;module.exports&lt;/code&gt;에 새로운 함수나 객체를 할당해 내보내는 경우이다. 다음과 같이 다음과 같이 &lt;code class=&quot;language-text&quot;&gt;Square&lt;/code&gt; 클래스를 &lt;code class=&quot;language-text&quot;&gt;module.exports&lt;/code&gt;
에 할당하여 내보낸다면, &lt;code class=&quot;language-text&quot;&gt;module.exports&lt;/code&gt;는 새로운 객체를 참조하게 되어 &lt;code class=&quot;language-text&quot;&gt;exports&lt;/code&gt;와 참조 대상이 상이해진다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;module.exports = class Square {
  constructor(width) {
    this.width = width;
  }

  area() {
    return this.width ** 2;
  }
};

console.log(module.exports === exports); // false&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 &lt;code class=&quot;language-text&quot;&gt;module.exports&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;shortcut&lt;/code&gt;인 &lt;code class=&quot;language-text&quot;&gt;exports&lt;/code&gt;와 다른 객체를 가리키게 되는 것은 크게 문제가 되지 않는다. 모듈을 불러오는 &lt;code class=&quot;language-text&quot;&gt;require&lt;/code&gt;함수는
내부적으로 &lt;code class=&quot;language-text&quot;&gt;module.exports&lt;/code&gt;가 가리키는 값을 반환하기 때문이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function require() {
  // ...
  return module.exports;
}

const Square = require(&amp;#39;./Square.js&amp;#39;);
console.log(Square); // [class Square]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;문제는 다음과 같이 &lt;code class=&quot;language-text&quot;&gt;exports&lt;/code&gt;를 통해 새로운 값을 할당해 내보내는 경우이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const { PI } = Math;

exports = class Circle {
  constructor(r) {
    this.radius = r;
  }

  circumference() {
    return 2 * PI * this.radius;
  }
};

console.log(module.exports === exports); // false&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;export&lt;/code&gt;에 새로운 값을 할당한다면, &lt;code class=&quot;language-text&quot;&gt;module.exports&lt;/code&gt;가 가리키고 있는 대상과 다른 참조를 가지게 된다. 이것 또한 구현상의 문제는 없어보이지만,
위에서 언급한 것 처럼 &lt;code class=&quot;language-text&quot;&gt;require&lt;/code&gt;이 반환하는 &lt;code class=&quot;language-text&quot;&gt;module.exports&lt;/code&gt;과는 무관한 변경이기 때문에 의도한대로 모듈을 불러올 수 없게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const Square = require(&amp;#39;./Square.js&amp;#39;);
console.log(Square); // [class Square]

const Circle = require(&amp;#39;./Circle.js&amp;#39;);
console.log(Circle); // {}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;결론적으로 &lt;code class=&quot;language-text&quot;&gt;exports&lt;/code&gt;를 통한 내보내기가 정상적으로 동작한다 하더라도, &lt;code class=&quot;language-text&quot;&gt;module.exports&lt;/code&gt;를 사용하는 것이 안전하다.&lt;/p&gt;
&lt;h3 id=&quot;트리-쉬이킹의-한계&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%8A%B8%EB%A6%AC-%EC%89%AC%EC%9D%B4%ED%82%B9%EC%9D%98-%ED%95%9C%EA%B3%84&quot; aria-label=&quot;트리 쉬이킹의 한계 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;트리 쉬이킹의 한계&lt;/h3&gt;
&lt;p&gt;표준을 만들고자 독립적으로 설계되었던 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;의 모듈 시스템은 자바스크립트의 근간을 다루는 혁명(?)처럼 느껴져 단점을 논하자니
괜히 겸허해진다. 사실 단점이라고 하기보단 이후에 등장한 자바스크립트의 공식적인 모듈 시스템과 비교에 가깝다.&lt;/p&gt;
&lt;p&gt;대표적인 비교점은 아무래도 모듈을 동적, 그리고 동기적으로 불러올 수 있는 동작이 불러오는 결과일 것이다. &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;에 익숙한 개발자라면
비교적 유연해 보일 수 있지만 브라우저를 중심으로 하는 자바스크립트 생태계에서 기준이 되기란 쉽지 않았는데, 대표적인 이유로 트리쉐이킹 문제를 꼽는다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;는 동적으로 모듈을 불러올 수 있는 동작 때문에 런타임에 들어서야 모듈 평가가 이루어지는 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt; 모듈 시스템 구조상 참조되지 않은
대상을 제거해도 되는지에 대한 가늠하기 어렵다.&lt;/p&gt;
&lt;p&gt;그러나 일체 불가능한 것은 아니다. 번들러 차원에서 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;에서 트리쉐이킹이 가능하도록 플러그인들이나 기능을 제공하는 경우도 있다. 가령 &lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt;의 경우
&lt;a href=&quot;https://github.com/indutny/webpack-common-shake&quot;&gt;webpack-common-shake&lt;/a&gt;를 통해 일정 부분 제거가 가능하다.&lt;/p&gt;
&lt;p&gt;하지만 이후 살펴볼 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt; 처럼 정적 분석이 가능한 모듈 시스템 구조보다는 트리쉐이킹 수행에 어려움이 있으며,
다음과 같은 제약 사항들을 포함하고 있어 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt; 모듈 시스템의 특징적인 구현에 제동이 걸리게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Dynamic exports
exports[Math.random()] = ...
// Overriding imported vars
var a = require(&amp;#39;./a&amp;#39;);
a.lib;
a = require(&amp;#39;./b&amp;#39;)
// Using require in unknown way
console.log(require(&amp;#39;./lib&amp;#39;))
// Destructuring require dynamically
{ [prop]: name } = require(&amp;#39;./a&amp;#39;)
// Dynamic import
var fn = require(&amp;#39;./lib&amp;#39;)[Math.random()]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;nodejs의-esm-지원&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#nodejs%EC%9D%98-esm-%EC%A7%80%EC%9B%90&quot; aria-label=&quot;nodejs의 esm 지원 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;node.js의 ESM 지원&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;를 채택한 &lt;code class=&quot;language-text&quot;&gt;node.js&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;--experimental-module&lt;/code&gt; 플래그를 통해 실험적으로 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;을 지원하다가 &lt;a href=&quot;https://nodejs.org/api/esm.html#modules-ecmascript-modules&quot;&gt;버전 13.2.0부터 안정적으로 지원&lt;/a&gt;
하기 시작했다. 위에서 다뤘던 것처럼 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;는 ECMA 표준의 지원 없이 독립적으로 개발되었고, 태생적으로 브라우저 중심의 생태계에 적합하지 않을 수 있다는 이야기들이 반영된 것이다.&lt;/p&gt;
&lt;p&gt;그렇다면 다소 아쉬운 점을 들어내는 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;으로 급진적인 전환이 가능했을까. 사실 아직까지도 과도기이며, 최근 많은 라이브러리들이 &lt;a href=&quot;https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c&quot;&gt;순수 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;만을
지원하려는 움직임&lt;/a&gt;도 보이고 있지만,
이미 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt; 기반의 라이브러리들을 사용하고 있는 많은 사용자를 감안한다면 쉽게 선택할 수 있는 일이 아닌 것은 분명하다.
그렇다면 현재 라이브러리들은 어떻게 대처하고 있을까. 이 내용은 우리가 익숙하게 사용하고 있는 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;를 먼저 살펴보고 알아보자.&lt;/p&gt;
&lt;h2 id=&quot;esm-ecmascript-modules&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#esm-ecmascript-modules&quot; aria-label=&quot;esm ecmascript modules permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;ESM (ECMAScript Modules)&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;은 자바스크립트 표준을 다루는 ECMAScript 발표한 표준 모듈 시스템이다. 이는 자바스크립트 자체적으로 모듈에 대한 문법을 지원하게 된 것을 의미한다.
모던 브라우저 상에서 동작하는 어플리케이션을 개발하고 있다면, 가장 익숙한 모듈 시스템일 것이다. 기본적인 모듈 사용 방식은 건너뛰고 동작 방식과 특징들을
살펴보자.&lt;/p&gt;
&lt;h3 id=&quot;동작-방식&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D&quot; aria-label=&quot;동작 방식 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;동작 방식&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;은 구성, 인스턴스화, 평가 세 단계로 동작한다. 가장 먼저 &lt;strong&gt;구성 단계&lt;/strong&gt;에서는 번들러의 진입점과 같이 모듈 그래프의 시작점이 되는 파일에서부터 시작해 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt;
구문을 통해 의존적으로 불러오고 있는 모듈들의 종속성 트리를 생성한다.&lt;/p&gt;
&lt;p&gt;여기서 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt;가 가리키고 있는 파일 자체를 브라우저가 사용할 수 없기 때문에 이를 &lt;a href=&quot;https://262.ecma-international.org/6.0/#sec-source-text-module-records&quot;&gt;모듈 레코드(Module Record)&lt;/a&gt;
로 변환한다. 이때 모듈 간 관계를 구조화해야 하기 때문에 모든 파일을 구문 분석한다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 57.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/webp;base64,UklGRloAAABXRUJQVlA4IE4AAABQAwCdASoUAAsAPtFWo0uoJKMhsAgBABoJY0wAS0eTjbL+AAD+8NC3DyYaHzp375nl0C6FAZdCrFLMRipkxPJlHXPdS/IlOuaGZpUAAAA=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;모듈 레코드&quot;
        title=&quot;모듈 레코드&quot;
        src=&quot;/static/295d985ffa55da2db2adca9a65fb2aee/8b983/05_module_record-768x441.webp&quot;
        srcset=&quot;/static/295d985ffa55da2db2adca9a65fb2aee/c85cb/05_module_record-768x441.webp 300w,
/static/295d985ffa55da2db2adca9a65fb2aee/e88ff/05_module_record-768x441.webp 600w,
/static/295d985ffa55da2db2adca9a65fb2aee/8b983/05_module_record-768x441.webp 768w&quot;
        sizes=&quot;(max-width: 768px) 100vw, 768px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;다음으로 모듈 레코드를 코드와 상태를 담은 &lt;strong&gt;모듈 인스턴스로 변환&lt;/strong&gt;한다. &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt;된 모든 값을 할당할 메모리 공간을 찾고, 해당 모듈을 불러온 사용처의 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt;
와 해당 모듈을 내보낸 &lt;code class=&quot;language-text&quot;&gt;export&lt;/code&gt;가 모듈의 실제 메모리를 동일하게 가리키도록 한다. 이 과정을 마치면 진입점으로부터 시작되는 모든 모듈들에 대한 인스턴스 그래프를 얻게 된다.&lt;/p&gt;
&lt;p&gt;마지막으로 &lt;strong&gt;코드를 평가&lt;/strong&gt;한다. 위에서 언급한 상태는 특정 시점의 변수의 실제 값들을 의미하는데, 코드를 평가함으로써 해당 시점에 얻어낼 수 있는 실제 값들을
메모리에 채워 넣는다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 36.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/webp;base64,UklGRlAAAABXRUJQVlA4IEQAAAAwAwCdASoUAAcAPtFUo0uoJKMhsAgBABoJZwAAetEwhLYAAP7xxGX06b0Jre6Z8/p48g8BNdqmCzi3iMOjImREcRO8AA==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;ESM 모듈 동작 방식&quot;
        title=&quot;ESM 모듈 동작 방식&quot;
        src=&quot;/static/4b832e29b8d8d27d620c0bb85af25bbb/8b983/07_3_phases-768x282.webp&quot;
        srcset=&quot;/static/4b832e29b8d8d27d620c0bb85af25bbb/c85cb/07_3_phases-768x282.webp 300w,
/static/4b832e29b8d8d27d620c0bb85af25bbb/e88ff/07_3_phases-768x282.webp 600w,
/static/4b832e29b8d8d27d620c0bb85af25bbb/8b983/07_3_phases-768x282.webp 768w&quot;
        sizes=&quot;(max-width: 768px) 100vw, 768px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;위와 같은 세 과정은 각각 개별적으로, 비동기적으로 수행될 수 있다. 더불어 위 과정을 선재적으로 진행함에 따라 얻을 수 있는 이점들이 많다.&lt;/p&gt;
&lt;h3 id=&quot;읽기-전용-실시간-바인딩&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%BD%EA%B8%B0-%EC%A0%84%EC%9A%A9-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%B0%94%EC%9D%B8%EB%94%A9&quot; aria-label=&quot;읽기 전용 실시간 바인딩 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;읽기 전용 실시간 바인딩&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;의 정적 바인딩과는 달리 실시간으로 바인딩된다. 이는 모듈을 내보낸 곳에서 변경 사항이 모듈을 불러온 사용처에서도 반영된다는 것이다.&lt;/p&gt;
&lt;p&gt;이는 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;의 구동 방식의 인스턴스화 단계에서 모듈을 내보낸 &lt;code class=&quot;language-text&quot;&gt;export&lt;/code&gt;와 모듈을 불러온 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt;가 모두 모듈의 실제 메모리를 가리키도록 하는 작업이
수행되기 때문에 가능한 일이다. 즉 복사본이 아니라 불러온 모듈의 실제 메모리를 참조하여 값을 읽어 사용하는 것이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// lib.js
export let counter = 3;
export function incCounter() {
  counter++;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// main.js
import { counter, incCounter } from &amp;#39;./lib&amp;#39;;

// The imported value `counter` is live
console.log(counter); // 3
incCounter();
console.log(counter); // 4

// The imported value can’t be changed
counter++; // TypeError&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;단, 위에서 &lt;code class=&quot;language-text&quot;&gt;counter&lt;/code&gt; 값을 수정할 때 &lt;code class=&quot;language-text&quot;&gt;TypeError&lt;/code&gt;가 발생하는 것처럼, 내보내는 모듈은 언제든지 해당 값을 변경할 수 있지만, 모듈을
가져오는 곳에서는 마치 &lt;code class=&quot;language-text&quot;&gt;const&lt;/code&gt;로 선언된 값처럼 변경할 수 없다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 41%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABYElEQVQoz22RW0+DQBCF+f+/x/juq7GJJLY1tVbuUFhKuSzLssBxZqtRaycZ2GHZb8+ZcZZlwd8EpmGAzgWGLIcuKyzzbPfmQWNRyiaMAYeZZqhxRjdMkHqCg1uhfw4uUtpPS99jzAt0mUAdH1GXNQxd7pcKD28V/JNCKUc4/MhbjazRqJXBuTfI2hEpZdYZ5GmJzUHgNe3gbX3sPYFDXCFICPKR4WmTYBW2iKrBcpz7dYlHr0anZ4RFh+3+iCQSSKMCSVggjEq4BFwnHd59ggUCcVqhrxpkpYQkuyPZ7scvy27UIiC5Wa1RdBe1Ka1b6gmrVxPgJhL8365Q6KluxwWS3oo9X4XDNgWBjmS5oTXXbD8+DxbMl62CBs8EPPfjP8D1UJ27F2Ets+SIILtcWnhBPWTFlTRYU/82qcRJXoDzFeQbbBW6cWsnxE1lCFtmdayUa21meDRJTnbw+/Ct+ATBO2cACQxjjQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;읽기 전용 실시간 바인딩&quot;
        title=&quot;읽기 전용 실시간 바인딩&quot;
        src=&quot;/static/00494c0d4e8627e8da139d21fbfeead9/e5715/live-binding.png&quot;
        srcset=&quot;/static/00494c0d4e8627e8da139d21fbfeead9/5a46d/live-binding.png 300w,
/static/00494c0d4e8627e8da139d21fbfeead9/0a47e/live-binding.png 600w,
/static/00494c0d4e8627e8da139d21fbfeead9/e5715/live-binding.png 768w&quot;
        sizes=&quot;(max-width: 768px) 100vw, 768px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;정적-모듈-구조&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%95%EC%A0%81-%EB%AA%A8%EB%93%88-%EA%B5%AC%EC%A1%B0&quot; aria-label=&quot;정적 모듈 구조 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;정적 모듈 구조&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;은 정적 모듈 구조를 가진다. 동적인 모듈 시스템 구조를 가지고 있는 CommonJS는 어떤 모듈을 불러왔고 내보냈는지를 런타임에 파악할 수 있는 반면 ESM은
정적인 모듈 구조를 가지고 있어 어떤 모듈을 불러왔고 내보냈는지에 대해 컴파일 단계에서 파악할 수 있다. &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;export&lt;/code&gt;를 최상위에서만 사용해야 하는
이유이기도 하다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import foo from &amp;#39;./foo&amp;#39;;

if (condition) {
  import bar from &amp;#39;./bar&amp;#39;; // SyntaxError
}

function exportModule() {
  export default &amp;#39;baz&amp;#39;; // SyntaxError;
}

exportModule();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;정적 모듈 구조가 다소 유연성이 떨어지는 것처럼 보이지만 동적 구조 대비 &lt;a href=&quot;https://exploringjs.com/es6/ch_modules.html#static-module-structure&quot;&gt;다양한 이점&lt;/a&gt;
을 취할 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;죽은-코드를-제거하고-트리-쉐이킹-가능하다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A3%BD%EC%9D%80-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B3%A0-%ED%8A%B8%EB%A6%AC-%EC%89%90%EC%9D%B4%ED%82%B9-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4&quot; aria-label=&quot;죽은 코드를 제거하고 트리 쉐이킹 가능하다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;죽은 코드를 제거하고, 트리 쉐이킹 가능하다&lt;/h3&gt;
&lt;p&gt;ESM은 정적으로 모듈을 평가하여 번들링 과정에서 죽은 코드를 제거할 수 있다. 브라우저에서는 서버사이드와는 달리 웹을 구성하는 모든 모듈을 불러와
사용해야 하기 때문에 모듈 크기의 최적화가 큰 영향을 끼친다. 만약 정의되었지만 참조되지 않은 함수나 주석/공백 제거와 같은 작업을 수행하여
번들링을 최소한의 크기로 유지하는 것은 중요한 브라우저 생태계에서 중요하다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt;의 경우 &lt;a href=&quot;https://webpack.js.org/configuration/optimization/#optimizationminimize&quot;&gt;optimization.minimize&lt;/a&gt;를 &lt;code class=&quot;language-text&quot;&gt;true&lt;/code&gt;로
설정하여 트리쉐이킹을 진행할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;module.exports = {
  optimization: {
    minimize: true,
  },
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;현재는 &lt;code class=&quot;language-text&quot;&gt;webpack5&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;을 지원하지만, &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt; 빌드 결과물을 생성할 수 있었던 &lt;code class=&quot;language-text&quot;&gt;rollup&lt;/code&gt;은 조건부로 로드된 모듈을 고려할 필요 없는
특징과 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt; 대상과 &lt;code class=&quot;language-text&quot;&gt;export&lt;/code&gt; 대상이 하나의 메모리를 참조하고 있다는 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;의 특징을 살려 모든 모듈들을 동일한 수준으로 끌어올려 트리쉐이킹 판단을 용이하게
진행할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;이때 &lt;code class=&quot;language-text&quot;&gt;rollup&lt;/code&gt;은 불필요한 대상들을 제거하는 접근이 아닌 최종 번들 파일에 포함되어야 한다고 판단된 모듈만을 포함시키려는 접근을 제시하고 적용하고 있다.
아래 &lt;code class=&quot;language-text&quot;&gt;rollup&lt;/code&gt;에서 번들링했을 때의 예시처럼 말이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// lib.js
export function foo() {}
export function bar() {}

// main.js
import { foo } from &amp;#39;./lib.js&amp;#39;;
console.log(foo());&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function foo() {}

console.log(foo());&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;불러오기-검색-속도-향상&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0-%EA%B2%80%EC%83%89-%EC%86%8D%EB%8F%84-%ED%96%A5%EC%83%81&quot; aria-label=&quot;불러오기 검색 속도 향상 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;불러오기 검색 속도 향상&lt;/h3&gt;
&lt;p&gt;동적으로 불러온 모듈의 속성을 참조한다면, 해당 속성에 대한 조회가 선행되어야 한다. 반면 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;의 경우 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt;된 모듈에 대한 평가가 완료되어 정적으로
참조 가능해 런타임에서 모듈에 대한 속성 조회가 완료된 상태로 최적화된 참조가 가능하다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;var lib = require(&amp;#39;lib&amp;#39;);
lib.someFunc(); // property lookup&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import * as lib from &amp;#39;lib&amp;#39;;
lib.someFunc(); // statically resolved&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;nodejs에서-모듈-시스템을-선정하는-방식&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#nodejs%EC%97%90%EC%84%9C-%EB%AA%A8%EB%93%88-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EC%84%A0%EC%A0%95%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D&quot; aria-label=&quot;nodejs에서 모듈 시스템을 선정하는 방식 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;node.js에서 모듈 시스템을 선정하는 방식&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt; 모듈 시스템이 함께 지원되는 환경에서 &lt;code class=&quot;language-text&quot;&gt;node.js&lt;/code&gt;는 어떻게 모듈 시스템을 선정할 수 있을까.
이는 파일 확장자와 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 필드로 모듈 시스템을 명시할 수 있다.&lt;/p&gt;
&lt;p&gt;파일 확장자가 &lt;code class=&quot;language-text&quot;&gt;.cjs&lt;/code&gt; 경우 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt; 모듈 시스템을, &lt;code class=&quot;language-text&quot;&gt;.mjs&lt;/code&gt;의 경우 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt; 모듈 시스템을 사용한다.
그러나 단순히 &lt;code class=&quot;language-text&quot;&gt;.js&lt;/code&gt;의 확장자를 가지는 경우 가장 가까운 부모의 &lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt;에 명시되어 있는 &lt;code class=&quot;language-text&quot;&gt;type&lt;/code&gt; 필드를 기준으로 모듈 시스템을 선정한다.&lt;/p&gt;
&lt;p&gt;만약 &lt;code class=&quot;language-text&quot;&gt;type: &quot;module&quot;&lt;/code&gt;로 명시되어 있는 경우 ESM 모듈 시스템을 사용하고, &lt;code class=&quot;language-text&quot;&gt;type: &quot;commonjs&quot;&lt;/code&gt;가 명시되어 있거나 필드가 명시되어 있지 않은 경우
&lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt; 모듈 시스템을 사용하는데, 이미 많은 패키지들이 먼저 사용된 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt; 모듈 시스템을 따르고 있기 때문이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// package.json
{
  &amp;quot;type&amp;quot;: &amp;quot;module&amp;quot;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;타입스크립트 4.7 버전부터 &lt;code class=&quot;language-text&quot;&gt;tsconfig.json&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;moduleResolution: &quot;nodenext&quot; or &quot;node16&quot;&lt;/code&gt;일 경우 위 규칙이 동일하게 적용된다.&lt;/p&gt;
&lt;h2 id=&quot;두-모듈-시스템-지원하기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%91%90-%EB%AA%A8%EB%93%88-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%A7%80%EC%9B%90%ED%95%98%EA%B8%B0&quot; aria-label=&quot;두 모듈 시스템 지원하기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;두 모듈 시스템 지원하기&lt;/h2&gt;
&lt;p&gt;라이브러리를 제작하는 입장이라면 해당 라이브러리를 사용하는 환경에 따라 적절한 모듈 시스템이 적용된 빌드 파일을 제공해 줄 수 있어야 한다.
이는 결국 각각의 모듈 시스템을 사용한 빌드된 결과물을 제공해 주어야 하는 것이다.&lt;/p&gt;
&lt;h3 id=&quot;conditional-exports&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#conditional-exports&quot; aria-label=&quot;conditional exports permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;conditional exports&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;node.js&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;을 함께 지원하기 위해 &lt;code class=&quot;language-text&quot;&gt;exports&lt;/code&gt; 기능을 추가했다. 패키지를 사용하는 쪽에서 해당 패키지를 불러올 때 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;의
&lt;code class=&quot;language-text&quot;&gt;require&lt;/code&gt; 혹은 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt; 중 어느 구문을 통해 모듈을 불러왔는지에 따라 해당 패키지의 번들을 조건적으로 제공할 수 있게 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// package.json
{
  &amp;quot;name&amp;quot;: &amp;quot;my-package&amp;quot;,
  &amp;quot;exports&amp;quot;: {
    &amp;quot;.&amp;quot;: {
      &amp;quot;import&amp;quot;: &amp;quot;./dist/lib.mjs&amp;quot;,
      &amp;quot;require&amp;quot;: &amp;quot;./dist/lib.cjs&amp;quot;
    }
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// commonjs, ./dist/lib.cjs 를 불러온다.
const myPackage = require(&amp;#39;my-package&amp;#39;);

// esm, ./dist/lib.mjs
import myPackage from &amp;#39;my-package&amp;#39;;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;a href=&quot;https://webpack.kr/guides/ecma-script-modules/#flagging-modules-as-esm&quot;&gt;webpack5&lt;/a&gt;에서는
&lt;code class=&quot;language-text&quot;&gt;package.json&lt;/code&gt;에 &lt;code class=&quot;language-text&quot;&gt;type: &quot;module&quot;&lt;/code&gt;가 명시되어 있거나, 모듈 파일의 확장자를 &lt;code class=&quot;language-text&quot;&gt;.mjs&lt;/code&gt;로 설정하여 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt; 모듈 시스템을 사용하는 번들을
생성해낼 수 있다. 또 다른 예시로 &lt;code class=&quot;language-text&quot;&gt;vite&lt;/code&gt;는 &lt;a href=&quot;https://vitejs.dev/config/build-options.html#build-lib&quot;&gt;build.lib.formats&lt;/a&gt;
설정을 통해 명시한 각각의 모듈 시스템에 대한 번들을 생성해낸다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  highlight-lines=&quot;1 7&quot;&gt;
          &lt;code slot=&quot;code&quot;&gt;// vite.config.js
build: {
  lib: {
    entry: path.resolve(__dirname, &amp;#39;src/main.ts&amp;#39;),
    name: pascalCase(pkg.name.split(&amp;#39;/&amp;#39;).pop() ?? &amp;#39;&amp;#39;),
    fileName: &amp;#39;lib&amp;#39;,
    formats: [&amp;#39;cjs&amp;#39;, &amp;#39;es&amp;#39;, &amp;#39;umd&amp;#39;]
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위에서 언급한 &lt;a href=&quot;#conditional-exports&quot;&gt;conditional exports&lt;/a&gt;는 동일한 불러오기 경로에 대해 특정 조건에 따라 다른 모듈을 제공할 수 있었다면,
라이브러리가 사용되는 환경에 따라 이를 제공할 수도 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// package.json
{
  // 패키지를 사용할 때 진입되는 경로
  &amp;quot;main&amp;quot;: &amp;quot;./dist/lib.js&amp;quot;,
  // ES6가 호환되는 환경에서의 진입 경로
  &amp;quot;module&amp;quot;: &amp;quot;./dist/lib.mjs&amp;quot;,
  // 클라이언트 사이드 (브라우저) 환경에서 사용할 때 진입 경로
  &amp;quot;browser&amp;quot;: &amp;quot;./dist/lib.js&amp;quot;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서 &lt;code class=&quot;language-text&quot;&gt;main&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;node.js&lt;/code&gt; 10 버전 이하에서 사용되는 필드이며, 11 이상에서는 &lt;code class=&quot;language-text&quot;&gt;main&lt;/code&gt;과 &lt;code class=&quot;language-text&quot;&gt;exports&lt;/code&gt;가 함께 명시되어 있는 경우 &lt;code class=&quot;language-text&quot;&gt;exports&lt;/code&gt;가 먼저 적용된다.&lt;/p&gt;
&lt;h2 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h2&gt;
&lt;p&gt;익숙하게 사용 중인 &lt;code class=&quot;language-text&quot;&gt;typescript&lt;/code&gt; 4.7 버전과 &lt;code class=&quot;language-text&quot;&gt;next12&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt; 공식 지원과, &lt;code class=&quot;language-text&quot;&gt;jest&lt;/code&gt;의 실험적인 기능을 통해 서둘러 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt;을 지원하기 시작했다는 레퍼런스들을 보면서
그 시점에 해당 체인지 로그를 본 나는 업데이트하게 된 배경을 이해하고 있지 못하고 그러려니 했을거다. 지금이라도 두서없이 정리해 본 게 정말 다행이라 생각한다.&lt;/p&gt;
&lt;p&gt;사실 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;를 청산할 수 있을까에 대한 의문은 남는다. 라이브러리 메인테이너들이 여전히 건재한 &lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt; 생태계를 제쳐두고 기꺼이 &lt;code class=&quot;language-text&quot;&gt;ESM&lt;/code&gt; 도입을 위해
적극적으로 참여해줄 지, 아니면 크게 문제 없어보이는 두 모듈 시스템이 공존하는 현 상황에 만족할 것인지 나중 일들이 궁금해진다. 지금은 여전히 시끌시끌한 자바스크립트
생태계 이슈들에 조금씩 공감할 수 있게 된 것 같아 기쁘다.&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://so-so.dev/web/tree-shaking-module-system/&quot;&gt;Tree Shaking과 Module System&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://yceffort.kr/2023/05/what-is-commonjs&quot;&gt;1부) commonjs란 무엇인가?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://yceffort.kr/2023/05/why-esmodule&quot;&gt;3부) 왜 esmodule 이어야 하는가?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/&quot;&gt;ES modules: A cartoon deep-dive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://exploringjs.com/es6/ch_modules.html#static-module-structure&quot;&gt;exploringjs#static-module-structure&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://toss.tech/article/commonjs-esm-exports-field&quot;&gt;CommonJS와 ESM에 모두 대응하는 라이브러리 개발하기:exports field&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://velog.io/@yesbb/%EB%AA%A8%EB%93%88-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%97%AD%EC%82%AC-%EA%B7%B8%EB%A6%AC%EA%B3%A0-ESM&quot;&gt;모듈 시스템의 역사, 그리고 ESM&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[웹 제품을 만들기 위한 개발 환경과 기술 스택 되짚어보기]]></title><description><![CDATA[GitGlances…]]></description><link>https://youthfulhps.dev/development/git-glances-skills-retrospect/</link><guid isPermaLink="false">https://youthfulhps.dev/development/git-glances-skills-retrospect/</guid><pubDate>Mon, 23 Oct 2023 09:10:35 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://github.com/youthfulhps/git-glances&quot;&gt;GitGlances&lt;/a&gt;라는 웹과 크롬 익스텐션 제품을 동시에 만들기 위한 개발 환경 구축과 선택한 기술 스택에
대한 늦은 회고이다. 이미 환경이 구축되어 있는 프로젝트에 합류해 개발하게 된 경험이 많아 초기 단계부터 환경을 만들어가는 작업은 낯설기도 하면서 클라이언트 개발 환경을
다시 정리하기 좋은 경험이었다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 49.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABxklEQVQoz2VSSY7bQAz0KQkw1tabpNbW2qzAii17BolPmUOCAeL/P6hCti3YwBwoUFyKrGJvhBCI4xgJW5Lc7e4LNgHxZGuN9++98VPvhj/WWqRpBqUNtJIwJoORBjIikJAKQx74AFqXEBTLqNeWFkppH99womkaONeiLCvUdY3C1XCvE/IfDuJ7DrWzyKkxz3MPKqVEluVwjfP1bddSzt42lEIiJsc5h+PxiNPxhGbuoT9G6L8D1MeA4XpC3Tm0VMNslFZo2w6/399xuVywLAumaUIUxdiEQYD96xuGw4JvX78geAmgXI703wT9p0d5nbG7npERLaM1NBmzKooCXdf7TdM0pbi5UY6iCCOh//x1oaktlFTQRQZ77mDmCsXSoj6QT01KKU9XEmhOgBVJZIzx+vMgD8jXtVWJeZ6RUSKkAZoEzlSK6CVEvI3wVjU+568eRhB9hbR3KGg7HsJAPOgGSPqxoKwhC9z3PV2txDDtcCBN+RCCgBoSfhjHW6MUvqeuW6Jek188KK/oLPZ+v8f5fIIj6iWBjwTAGiWJgCWKLWnGA1aaaWY9kNZPGq5vi4UOwxDbbQDWNSbj/+c8xx+P/7Nx3X/5cAGtwOzq3wAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;GitGlances&quot;
        title=&quot;GitGlances&quot;
        src=&quot;/static/ce68ca638d873dbdad38db1221c7afde/c1b63/git-glances.png&quot;
        srcset=&quot;/static/ce68ca638d873dbdad38db1221c7afde/5a46d/git-glances.png 300w,
/static/ce68ca638d873dbdad38db1221c7afde/0a47e/git-glances.png 600w,
/static/ce68ca638d873dbdad38db1221c7afde/c1b63/git-glances.png 1200w,
/static/ce68ca638d873dbdad38db1221c7afde/21b4d/git-glances.png 1280w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;패키지-매니저&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%8C%A8%ED%82%A4%EC%A7%80-%EB%A7%A4%EB%8B%88%EC%A0%80&quot; aria-label=&quot;패키지 매니저 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;패키지 매니저&lt;/h2&gt;
&lt;p&gt;프로젝트 관리를 용이하게 도와주는 패키지 매니저는 패키지 의존성 관리와 프로젝트의 메타데이터, 스크립트 등 관리 포인트를 묶어 한곳에서 관리할 수 있도록 도와준다.
&lt;code class=&quot;language-text&quot;&gt;npm&lt;/code&gt;을 시작으로 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;pnpm&lt;/code&gt; 등 여러 패키지가 있지만, 프로젝트를 시작한 시점에 가장 자주 사용하고 익숙했던 &lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;을 사용했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;name&amp;quot;: &amp;quot;git-glances&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;2.2.2&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;repository&amp;quot;: &amp;quot;git@github.com:youthfulhps/git-glances.git&amp;quot;,
  &amp;quot;author&amp;quot;: &amp;quot;youthfulhps &amp;lt;ybh942002@gmail.com&amp;gt;&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;,
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;yarn&lt;/code&gt;은 lockfile을 도입해 협업 과정에서 일관된 의존성 버전 관리를 보장하고, 깊어지는 의존성 트리에 따라 중복 설치되는 의존성들을 호이스팅시켜 플랫하게
관리하는 컨셉을 가지고 있는 것이 특징이다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 44.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB3UlEQVQoz3WSTW/TQBCG87s4cOCv9MqBnhAIiXLohRsHDiDUqO0RVWqlHgCpQgSIEAWpRFQktMGxHSf+jr8dN7Yfdp009MKsRruafefdd3amVdUV0oIsYpKGOEWGK86LxRV1XSPvq2qJSbMYK7Rx5imuwE1ChyxPmjuJkfhWVZbUIhBpv1B2H6C07+N1D6gaUNmAGhcJVyLm/T5l+HKTixf3sD6/ZiFitcCtCWnoRLL7B2N/C3XnIdnp8SpaC6UL4SWlcGn5eIC2/xhtb4vs7GSZW94g9K2Ek4Mf9HtT3LxE9xLCecl4rItycqIwYl7kLK2iEDLdDCaJ3CspT5CtnpeEai/g1eY3vhyqJJnL1FRJk4jRaITjOA0wFAxnnxTGisu51+GrcYQfmNimxSyY4fs+nudRCqUtt1J46z7jsujys2vw4eic0E8xrSlxFDeEvY86Tzfe0Dkc0PY22NZuY0SXGJqJ57u4jo2uqRTFnFY/6bA9vMM75znvd3T2Hn3HGHoo6hDLstelyE9tmrNa12VmecHEDtBNH9uPRVNq1taLhQq/TcZs1ZL6X5f/45JY1cb0BxfESSrGZjVn0neNuzwZ3mIy7zeKyhtjIxOX56qZzeu4tCSOCcRfyon4CycioMX8YrlFAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;yarn의 의존성 호이스팅&quot;
        title=&quot;yarn의 의존성 호이스팅&quot;
        src=&quot;/static/e605658d9d980dc7db0d62f04630b1fe/c1b63/dependency-hoisting.png&quot;
        srcset=&quot;/static/e605658d9d980dc7db0d62f04630b1fe/5a46d/dependency-hoisting.png 300w,
/static/e605658d9d980dc7db0d62f04630b1fe/0a47e/dependency-hoisting.png 600w,
/static/e605658d9d980dc7db0d62f04630b1fe/c1b63/dependency-hoisting.png 1200w,
/static/e605658d9d980dc7db0d62f04630b1fe/21b4d/dependency-hoisting.png 1280w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://toss.tech/article/node-modules-and-yarn-berry&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;의존성 호이스팅을 통해 디스크 공간을 세이브할 수 있다는 장점이 있지만, 특정 의존성 패키지의 의존성이 호이스팅되어 프로젝트에 직접 추가하지 않은 의존성이 문제없이
불러올 수 있게 되는 유령 의존성 (Phantom Dependency) 현상이 발생하기도 한다.&lt;/p&gt;
&lt;p&gt;외람된 이야기지만, 현재는 &lt;code class=&quot;language-text&quot;&gt;pnpm&lt;/code&gt;를 주로 사용한다. &lt;code class=&quot;language-text&quot;&gt;pnpm&lt;/code&gt;은 심링크, 하드링크를 통해 프로젝트에서 의존성을 로컬 디스크의 상위 스토어에 설치된 의존성과 연결시켜
사용하는 &lt;code class=&quot;language-text&quot;&gt;Content-addressable-storage&lt;/code&gt; 전략을 통해 여러 프로젝트에서 중복되게 사용되는 의존성에 대한 중복 설치를 방지하고 있다. 이 컨셉이 적잖게 충격이었다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1080px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 47.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7rAAAO6wFxzYGVAAABn0lEQVQoz22SSY/UMBCF8///DBL31nABhGDEIhbRg6YnTezE+xIn3ZweVU6MhtEcnlKq2F+9clUX5hVNsVygXMRZKvRCwYSMtFxrPpEen32quP/vWoIvtsujCZCkySVInyB8hElz/dfEZ+f1ikxqxTjfxbIFmi6yO45tSAT1UD7DxUROI06TpgIBPhXEvOA8OXz82ePTsYeg4lygOhxcwRgWCOWqWqXRxs2ldTDjCdZo9HKC1g6ewMcHicOHb7i5/Y57acjpnw1o8wpPgdodNuBEsaDL3HbMBc4NGIwlhzPyvODuPOLF4S1e3rzDSerafqB8J/yMKRZyZ6piWao8QUbr8VvZCj6rATrxkFbMlyt+DQqH91/x6vbHDuR3LOjSDsjrSrr8A6Zlg/K7MfBE7VofYKiIDwH3QuP15yPefLlDP5l6tzpsgP+0bHB2w3HalR/lPbmx1D6LnTVjzwJ9ijRlGgZNO/CUyZmmSavIbg1tREAoNG0C8XkGNj0L1J7ejtbEcfU80+rQ+qRE6zThQUgM1OJI0xfa1sKSvnI38Bd2B/P/hvRypAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;pnpm의 node_modules 디렉토리 구조&quot;
        title=&quot;pnpm의 node_modules 디렉토리 구조&quot;
        src=&quot;/static/11f7c87ca58e7f7d79107b3a347267db/302a4/pnpm-node-modules-example.png&quot;
        srcset=&quot;/static/11f7c87ca58e7f7d79107b3a347267db/5a46d/pnpm-node-modules-example.png 300w,
/static/11f7c87ca58e7f7d79107b3a347267db/0a47e/pnpm-node-modules-example.png 600w,
/static/11f7c87ca58e7f7d79107b3a347267db/302a4/pnpm-node-modules-example.png 1080w&quot;
        sizes=&quot;(max-width: 1080px) 100vw, 1080px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://pnpm.io/motivation&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;번들러&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B2%88%EB%93%A4%EB%9F%AC&quot; aria-label=&quot;번들러 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;번들러&lt;/h2&gt;
&lt;p&gt;모듈 시스템을 기반으로 형성된 거대한 코드 베이스와 CSS, 이미지 등 웹을 구성하기 위한 모든 자원을 모듈이라 한다. 번들러는 스크립트 모듈 내의 파일 단위와
변수 유효 범위를 유지한 채 웹을 구성하는 모든 모듈들을 하나의 번들로 생성한다.&lt;/p&gt;
&lt;p&gt;하나로 묶인 번들은 정량적인 요청 횟수를 줄여 브라우저별로 상이한 요청 횟수 제한에서 안전할 수 있으며, 원한다면 코드 스플리팅을 통해 원하는 때 분리된 번들을 로드할
수 있고, 사용하지 않은 코드들을 트리 쉐이킹해 번들링 과정에서 제거할 수 있다.&lt;/p&gt;
&lt;p&gt;최근 &lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt;과 비교했을 때 빌드 속도가 현저히 개선된 &lt;code class=&quot;language-text&quot;&gt;esbuild&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;vite&lt;/code&gt;와 같은 번들러들이 많은 관심을 받고 있고, 최근 실무에서는 &lt;code class=&quot;language-text&quot;&gt;vite&lt;/code&gt;를 주로
사용하는데 역시나 번들링 설정이 매우 간결하고 개발자 친화적이다.&lt;/p&gt;
&lt;p&gt;하지만 개선된 번들러를 신나게 칭찬하고선 &lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt;을 사용하기로 결정했다. 아직 번들러 시장에서 점유율이 견고할 뿐만 아니라, 실무에서 번들러에 문제가 생겨
누군가 해결해야 한다면 그 대상이 &lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt;일 가능성이 높지 않을까 싶어 설정 수정과 적용에 있어 부담이 적은 개인 프로젝트에서 다루어보는 것도 즐겁지 않을까
싶어서다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 42.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABKklEQVQoz41R2XLEMAjL/39qt7udxBdgsCqcbR/61GQ0MDLiPM7zxOPxQG0VpRT03rHWwv5p8/vx/4PDzODT8VbeSe48SPrjUqB94at/osn4jfuL9baHqaFoRfMOiwkPx3CBxI06Gzrfho/N7zdXQqBh1NzwNTcOGQzSsUUpvqxs34IiIlZs8YjBBJkk+XFzRGehNgdeg02Z4lBVTI69R2SHL3vu1qffc0dwNwHYBHQuiC0MospCkcA1Ak2TYwxXdIgISleOvXCK40n/YnDVDHaKfNumjm5BYdA6i8d9CK5oObOxS9Aec04Ylx0mmMqdVV55yg5Y2oiKJYXtVbbwht7YbxljqR878ZHXiambTGi74NrJCasHsmCuJUePd1fKFSWf/uZphcdN+w3z53TGc9UxhgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;npm 번들러 다운로드 수 비교&quot;
        title=&quot;npm 번들러 다운로드 수 비교&quot;
        src=&quot;/static/62d6bff4f93a180deeea69d3aefad338/c1b63/bundler-comparison.png&quot;
        srcset=&quot;/static/62d6bff4f93a180deeea69d3aefad338/5a46d/bundler-comparison.png 300w,
/static/62d6bff4f93a180deeea69d3aefad338/0a47e/bundler-comparison.png 600w,
/static/62d6bff4f93a180deeea69d3aefad338/c1b63/bundler-comparison.png 1200w,
/static/62d6bff4f93a180deeea69d3aefad338/d61c2/bundler-comparison.png 1800w,
/static/62d6bff4f93a180deeea69d3aefad338/97a96/bundler-comparison.png 2400w,
/static/62d6bff4f93a180deeea69d3aefad338/ba168/bundler-comparison.png 2644w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt;의 설정 파일은 기본적으로 다음과 같은 구조를 가진다. 몇 가지 필수적인 설정을 살펴보자.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;var path = require(&amp;#39;path&amp;#39;);

module.exports = {
  mode: &amp;#39;none&amp;#39;,
  entry: &amp;#39;./src/index.js&amp;#39;,
  output: {
    filename: &amp;#39;main.js&amp;#39;,
    path: path.resolve(__dirname, &amp;#39;dist&amp;#39;),
  },
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;entry-output&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#entry-output&quot; aria-label=&quot;entry output permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;entry, output&lt;/h3&gt;
&lt;p&gt;번들링이 시작되는 진입점은 &lt;code class=&quot;language-text&quot;&gt;entry&lt;/code&gt; 포인트로 제공하고 그 결과를 &lt;code class=&quot;language-text&quot;&gt;output&lt;/code&gt;에 반환한다. 싱글 페이지 어플리케이션을 제작할 경우 진입점을 하나로 두어 모든 페이지를 하나의
번들로 구성할 수 있고, 진입점을 여러 개로 나누어 멀티 페이지 어플리케이션을 구성하는 페이지 별 번들을 생성할 수도 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;entry: {
  login: &amp;#39;./src/LoginPage.js&amp;#39;,
  main: &amp;#39;./src/MainPage.js&amp;#39;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;loader&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#loader&quot; aria-label=&quot;loader permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;loader&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt;은 자바스크립트 파일이 아닌 &lt;code class=&quot;language-text&quot;&gt;image&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;css&lt;/code&gt; 등과 같은 자원들을 해석하고 변환할 수 있도록 &lt;code class=&quot;language-text&quot;&gt;loader&lt;/code&gt;를 제공해주어야 한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// ...
module: {
  rules: [
    {
      test: /\.(ts|tsx)$/,
      loader: &amp;#39;ts-loader&amp;#39;,
      options: {
        transpileOnly: true,
      },
    },
    {
      test: /\.css?$/,
      use: [&amp;#39;style-loader&amp;#39;, &amp;#39;css-loader&amp;#39;, &amp;#39;postcss-loader&amp;#39;],
    },
    {
      test: /\.(webp|jpg|png|jpeg)$/,
      loader: &amp;#39;file-loader&amp;#39;,
      options: {
        name: &amp;#39;[name].[ext]?[hash]&amp;#39;,
      },
    },
    {
      test: /\.(ts|tsx|js|jsx)$/,
      exclude: /node_modules/,
      use: &amp;#39;babel-loader&amp;#39;,
    },
  ];
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;loader&lt;/code&gt;를 적용할 파일 유형이 같다면 &lt;code class=&quot;language-text&quot;&gt;rules&lt;/code&gt; 에서 먼저 오는 &lt;code class=&quot;language-text&quot;&gt;loader&lt;/code&gt;가 적용되고, 하나의 &lt;code class=&quot;language-text&quot;&gt;rule&lt;/code&gt;에 여러 개의 &lt;code class=&quot;language-text&quot;&gt;loader&lt;/code&gt;를 사용할 수 있다면, &lt;code class=&quot;language-text&quot;&gt;use&lt;/code&gt;
배열의 뒤에서부터 &lt;code class=&quot;language-text&quot;&gt;loader&lt;/code&gt;가 적용된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// css-loader가 style-loader보다 우선 적용
module: {
  rules: [
    {
      test: /\.css$/,
      use: [&amp;#39;css-loader&amp;#39;],
    },
    {
      test: /\.css$/,
      use: [&amp;#39;style-loader&amp;#39;],
    },
  ];
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// sass-loader -&amp;gt; css-loader -&amp;gt; style-loader 순으로 로더 적용
modules: {
  rules: [
    {
      test: /\.scss$/,
      use: [&amp;#39;style-loader&amp;#39;, &amp;#39;css-loader&amp;#39;, &amp;#39;sass-loader&amp;#39;],
    },
  ];
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;plugin&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#plugin&quot; aria-label=&quot;plugin permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;plugin&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;plugin&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt;의 기본적인 번들링 동작에 추가적인 동작과 기능을 부가하는 데 사용된다. 가령 해당 결과물의 형태를 조작하거나, 추가적인
작업을 지시할 때 사용한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;plugins: [
  new CleanWebpackPlugin(),
  new HtmlWebpackPlugin({
    template: path.resolve(__dirname, &amp;#39;public&amp;#39;, &amp;#39;index.html&amp;#39;),
    hash: false,
  }),
  new webpack.DefinePlugin({
    &amp;#39;process.env&amp;#39;: JSON.stringify(process.env),
    &amp;#39;process.env.IS_WEB&amp;#39;: JSON.stringify(isWeb),
  }),
  new CopyWebpackPlugin({
    patterns: [
      {
        from: path.resolve(__dirname, &amp;#39;public/*.png&amp;#39;),
        to() {
          return &amp;#39;[name][ext]&amp;#39;;
        },
      },
      {
        from: path.resolve(__dirname, &amp;#39;public/icons&amp;#39;),
        to() {
          return &amp;#39;icons/[name][ext]&amp;#39;;
        },
      },
      {
        from: path.resolve(__dirname, &amp;#39;public/manifest.json&amp;#39;),
        to: &amp;#39;manifest.json&amp;#39;,
      },
      ...(!isWeb
        ? [
            {
              from: path.resolve(__dirname, &amp;#39;public/favicon.png&amp;#39;),
              to: &amp;#39;icons/icon16.png&amp;#39;,
            },
          ]
        : []),
    ],
  }),
];&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;프로젝트를 제작할 때 다음과 같은 &lt;code class=&quot;language-text&quot;&gt;plugin&lt;/code&gt;들을 사용했다. 초기 설정을 구성할 때 일괄적으로 적용해 주었다면 좋았겠지만, 빌드 결과물에 에셋 파일이 포함되어 있지 않다던지,
보일러 플레이트를 사용할 때는 당연하게 생각했던 &lt;code class=&quot;language-text&quot;&gt;index.html&lt;/code&gt; 파일이 생성되어 있지 않는 등 석연치 않은 불편함을 하나씩 느끼면서 &lt;code class=&quot;language-text&quot;&gt;plugin&lt;/code&gt;을 추가해 보는 것도
그 역할을 깨닫기 좋은 경험이었다.&lt;/p&gt;
&lt;h3 id=&quot;cleanwebpackplugin&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#cleanwebpackplugin&quot; aria-label=&quot;cleanwebpackplugin permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;CleanWebpackPlugin&lt;/h3&gt;
&lt;p&gt;새롭게 빌드를 진행하기 전에 &lt;code class=&quot;language-text&quot;&gt;output&lt;/code&gt; 디렉토리를 정리해준다. 빌드 결과물들이 쌓여 구분이 어려워지거나 직접 제거해주어야 하는 난감한 상황을 방지한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;new CleanWebpackPlugin();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;htmlwebpackplugin&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#htmlwebpackplugin&quot; aria-label=&quot;htmlwebpackplugin permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;HtmlWebpackPlugin&lt;/h3&gt;
&lt;p&gt;번들링이 완료된 자바스크립트 파일을 &lt;code class=&quot;language-text&quot;&gt;script&lt;/code&gt; 태그를 통해 로드하는 HTML 파일을 생성해준다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;new HtmlWebpackPlugin({
  template: path.resolve(__dirname, &amp;#39;public&amp;#39;, &amp;#39;index.html&amp;#39;),
  hash: false,
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;&amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;script defer=&amp;quot;defer&amp;quot; src=&amp;quot;main.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;copywebpackplugin&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#copywebpackplugin&quot; aria-label=&quot;copywebpackplugin permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;CopyWebpackPlugin&lt;/h3&gt;
&lt;p&gt;원하는 모듈을 복사해서 빌드 결과물에 포함시켜준다. 주로 &lt;code class=&quot;language-text&quot;&gt;image&lt;/code&gt;와 같은 에셋을 대상으로 사용했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;new CopyWebpackPlugin({
  patterns: [
    {
      from: path.resolve(__dirname, &amp;#39;public/*.png&amp;#39;),
      to() {
        return &amp;#39;[name][ext]&amp;#39;;
      },
    },
    {
      from: path.resolve(__dirname, &amp;#39;public/icons&amp;#39;),
      to() {
        return &amp;#39;icons/[name][ext]&amp;#39;;
      },
    },
  ],
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;부가적인-설정들&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B6%80%EA%B0%80%EC%A0%81%EC%9D%B8-%EC%84%A4%EC%A0%95%EB%93%A4&quot; aria-label=&quot;부가적인 설정들 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;부가적인 설정들&lt;/h3&gt;
&lt;h3 id=&quot;webpack-dev-server&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#webpack-dev-server&quot; aria-label=&quot;webpack dev server permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;webpack-dev-server&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;webpack-dev-server&lt;/code&gt;는 개발 과정에서 코드를 수정하고 &lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt; 명령어를 따로 실행하지 않아도 변경된 결과물을 새롭게 적용해준다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ yarn add --dev webpack-dev-server
~$ webpack serve&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// webpack.config.js
devServer: {
  host: &amp;#39;localhost&amp;#39;,
  port: PORT,
  open: true,
  hot: true,
  compress: true,
  historyApiFallback: true,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;experiments&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#experiments&quot; aria-label=&quot;experiments permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;experiments&lt;/h3&gt;
&lt;p&gt;ES2022 기능 중 하나인 &lt;code class=&quot;language-text&quot;&gt;top-level await&lt;/code&gt;를 사용해보기 위해 &lt;code class=&quot;language-text&quot;&gt;experiments&lt;/code&gt; 속성을 추가해주었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;experiments: {
  topLevelAwait: true,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;트랜스컴파일러&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%8A%B8%EB%9E%9C%EC%8A%A4%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC&quot; aria-label=&quot;트랜스컴파일러 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;트랜스컴파일러&lt;/h2&gt;
&lt;p&gt;브라우저마다 해석 가능한 자바스크립트 스펙 한계가 조금씩 달라 참고서에서 &lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80_%ED%98%B8%ED%99%98%EC%84%B1&quot;&gt;브라우저 호환성&lt;/a&gt;
를 제공해주곤 한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;babel&lt;/code&gt;은 이러한 크로스 브라우징 이슈를 해결하기 위해 브라우저에서 이해할 수 있는 스펙의 자바스크립트로 트랜스파일링 해준다. 일반적으로 코드를 분석해서 추상 구문
트리를 생성하고, 추상 구문 트리를 통해 브라우저가 해석할 수 있는 적당한 스펙의 자바스크립트로 코드를 재생성한다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;babel&lt;/code&gt;의 설정 파일은 일반적으로 &lt;code class=&quot;language-text&quot;&gt;presets&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;plugins&lt;/code&gt;을 나열한다. &lt;code class=&quot;language-text&quot;&gt;plugin&lt;/code&gt;은 가령 자바스크립트 파일에 포함된 &lt;code class=&quot;language-text&quot;&gt;react&lt;/code&gt; 개발 구문과 &lt;code class=&quot;language-text&quot;&gt;jsx&lt;/code&gt;,
타입스크립트로 작성된 코드를 트랜스파일링 과정에서 해석할 수 있도록 도와주는 역할을 한다. &lt;code class=&quot;language-text&quot;&gt;plugin&lt;/code&gt;은 종종 하나의 목적을 이루고자 의존적으로 추가해 주어야 하는
&lt;code class=&quot;language-text&quot;&gt;plugin&lt;/code&gt;들이 있는데, 이들을 묶어둔 것이 &lt;code class=&quot;language-text&quot;&gt;preset&lt;/code&gt;이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;module.exports = {
  presets: [
    &amp;#39;@babel/preset-env&amp;#39;,
    &amp;#39;@babel/preset-react&amp;#39;,
    &amp;#39;@babel/preset-typescript&amp;#39;,
  ],
  plugins: [
    &amp;#39;babel-plugin-macros&amp;#39;,
    &amp;#39;styled-components&amp;#39;,
    [
      &amp;#39;@babel/plugin-transform-runtime&amp;#39;,
      {
        regenerator: true,
      },
    ],
  ],
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;babel-env&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#babel-env&quot; aria-label=&quot;babel env permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;babel-env&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;babel-env&lt;/code&gt;은 브라우저와 버전을 제공해 해당 브라우저에서 동작 가능한 코드를 생산하고, 고스펙의 코드의 경우 &lt;code class=&quot;language-text&quot;&gt;polyfill&lt;/code&gt;을 제공하는 데 사용된다.
가령 &lt;code class=&quot;language-text&quot;&gt;ES2015&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt; 객체를 트랜스파일링하면 다음과 같은 결과를 얻게 되는데,&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;new Promise();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;#39;use strict&amp;#39;;

new Promise();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여전히 &lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;로 유지되는 코드는 윈도우 익스플로어와 같은 브라우저에서 해석이 불가능해 레퍼런스 에러를 던진다. &lt;code class=&quot;language-text&quot;&gt;babel-env&lt;/code&gt;는 이러한 이슈에 맞서
&lt;code class=&quot;language-text&quot;&gt;Promise&lt;/code&gt;를 해석할 수 있도록 &lt;code class=&quot;language-text&quot;&gt;polyfill&lt;/code&gt;이라는 코드 조각을 제공하여 문제를 해결한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  highlight-lines=&quot;4,8&quot;&gt;
          &lt;code slot=&quot;code&quot;&gt;[
  &amp;quot;@babel/preset-env&amp;quot;,
  {
    useBuiltIns: &amp;quot;usage&amp;quot;, // 폴리필 사용 방식 지정
    corejs: {
      // 폴리필 버전 지정
      version: 2,
    },
  },
],&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;#39;use strict&amp;#39;;

require(&amp;#39;core-js/modules/es6.promise&amp;#39;);
require(&amp;#39;core-js/modules/es6.object.to-string&amp;#39;);

new Promise();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;babelpreset-react&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#babelpreset-react&quot; aria-label=&quot;babelpreset react permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;@babel/preset-react&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;react&lt;/code&gt;를 위한 &lt;code class=&quot;language-text&quot;&gt;preset&lt;/code&gt;도 브라우저에서 해석 가능한 코드로 변환하는데 사용된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;;

function Component() {
  return &amp;lt;button&amp;gt;Click me!&amp;lt;/button&amp;gt;;
}

export default Component;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;;
import { jsx as _jsx } from &amp;#39;react/jsx-runtime&amp;#39;;
function Component() {
  return /*#__PURE__*/ _jsx(&amp;#39;button&amp;#39;, {
    children: &amp;#39;Click me!&amp;#39;,
  });
}
export default Component;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;babelpreset-typescript&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#babelpreset-typescript&quot; aria-label=&quot;babelpreset typescript permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;@babel/preset-typescript&lt;/h3&gt;
&lt;p&gt;타입스크립트를 해석하기 위한 프리셋 또한 제공한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const foo: number = 1;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const foo = 1;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;babel-loader&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#babel-loader&quot; aria-label=&quot;babel loader permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;babel-loader&lt;/h3&gt;
&lt;p&gt;위에서 살펴본 &lt;code class=&quot;language-text&quot;&gt;babel&lt;/code&gt;은 일반적으로 &lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt;과 함께 사용한다. 빌드 과정에서 적절한 스펙의 자바스크립트로 트랜스파일링 한 뒤 이를 번들링하기 위함인데,
이는 &lt;code class=&quot;language-text&quot;&gt;babel-loader&lt;/code&gt;를 통해 기능을 제공한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  highlight-lines=&quot;1 6,10&quot;&gt;
          &lt;code slot=&quot;code&quot;&gt;// webpack.config.js
module.exports = {
  ...
  module: {
    rules: [
      {
        test: /\.(ts|tsx|js|jsx)$/,
        exclude: /node_modules/,
        loader: &amp;#39;babel-loader&amp;#39;,
      },
    ],
  },
  ..
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;babel-loader와-babelconfigjs&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#babel-loader%EC%99%80-babelconfigjs&quot; aria-label=&quot;babel loader와 babelconfigjs permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;babel-loader와 babel.config.js&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt;에 적용 가능한 &lt;code class=&quot;language-text&quot;&gt;babel-loader&lt;/code&gt;의 옵션으로 &lt;code class=&quot;language-text&quot;&gt;presets&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;plugins&lt;/code&gt;를 제공할 수 있어 &lt;code class=&quot;language-text&quot;&gt;babel&lt;/code&gt; 설정 파일을 따로 구성할 필요는 없지만,
만약 프로젝트 루트 폴더에 &lt;code class=&quot;language-text&quot;&gt;babel&lt;/code&gt; 설정 파일이 존재한다면 &lt;code class=&quot;language-text&quot;&gt;babel-loader&lt;/code&gt;가 적용될 때 해당 설정을 읽어드리기 때문에 설정을 제공하는 방법은 자유롭게 선택 가능하다.&lt;/p&gt;
&lt;h2 id=&quot;테스트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%85%8C%EC%8A%A4%ED%8A%B8&quot; aria-label=&quot;테스트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;테스트&lt;/h2&gt;
&lt;p&gt;테스트는 &lt;code class=&quot;language-text&quot;&gt;jest&lt;/code&gt; 환경에서 리엑트 테스트를 위해 &lt;code class=&quot;language-text&quot;&gt;testing-library&lt;/code&gt;를 사용하고 &lt;code class=&quot;language-text&quot;&gt;ts-jest preset&lt;/code&gt;을 통해 타입스크립트 기반 코드를 커버했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import type { JestConfigWithTsJest } from &amp;#39;ts-jest&amp;#39;;

const config: JestConfigWithTsJest = {
  preset: &amp;#39;ts-jest&amp;#39;,
  testEnvironment: &amp;#39;jsdom&amp;#39;,
  setupFilesAfterEnv: [&amp;#39;&amp;lt;rootDir&amp;gt;/jest.setup.ts&amp;#39;],
  ...
};

export default config;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;만약 모듈을 불러오는 경로에 별칭을 부여해서 축약해 사용했다면, &lt;code class=&quot;language-text&quot;&gt;jest&lt;/code&gt; 환경에도 알려주어야 한다. &lt;code class=&quot;language-text&quot;&gt;webpack&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;alias&lt;/code&gt; 속성과 동일하다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  highlight-lines=&quot;3,7&quot;&gt;
          &lt;code slot=&quot;code&quot;&gt;const config: JestConfigWithTsJest = {
  ...,
  moduleNameMapper: {
    &amp;#39;^@/(.*)$&amp;#39;: &amp;#39;&amp;lt;rootDir&amp;gt;/src/$1&amp;#39;,
    &amp;#39;^@layout(.*)$&amp;#39;: &amp;#39;&amp;lt;rootDir&amp;gt;/src/_layout/$1&amp;#39;,
    &amp;#39;^@shared(.*)$&amp;#39;: &amp;#39;&amp;lt;rootDir&amp;gt;/src/_shared/$1&amp;#39;,
  },
}
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;또한 타입스크립트를 변환해 테스트할 때 변환된 결과가 개발 결과물과 동일하도록 프로젝트에서 사용하는 타입스크립트 및 &lt;code class=&quot;language-text&quot;&gt;babel&lt;/code&gt; 설정 파일을 제공했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  highlight-lines=&quot;3,12&quot;&gt;
          &lt;code slot=&quot;code&quot;&gt;const config: JestConfigWithTsJest = {
  ...,
  transform: {
    &amp;#39;^.+\\.tsx?$&amp;#39;: [
      &amp;#39;ts-jest&amp;#39;,
      {
        tsconfig: &amp;#39;&amp;lt;rootDir&amp;gt;/tsconfig.json&amp;#39;,
        babelConfig: &amp;#39;&amp;lt;rootDir&amp;gt;/babel.config.js&amp;#39;,
        useESM: true,
      },
    ],
  },
}
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;순수한-함수와-섹션-통합-단위-테스트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%88%9C%EC%88%98%ED%95%9C-%ED%95%A8%EC%88%98%EC%99%80-%EC%84%B9%EC%85%98-%ED%86%B5%ED%95%A9-%EB%8B%A8%EC%9C%84-%ED%85%8C%EC%8A%A4%ED%8A%B8&quot; aria-label=&quot;순수한 함수와 섹션 통합 단위 테스트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;순수한 함수와 섹션 통합 단위 테스트&lt;/h3&gt;
&lt;p&gt;‘정령 나는 테스트 코드를 의지하고 필요로 할까, 아니면 공개된 프로젝트라서 구색 맞추기 위함인 걸까?’ 강한 결합들로 이루어진 코드를 작성하고
나서 테스트 코드를 작성할 때 후회하며 들었던 생각이다. 다시 한번 실패하는 테스트 코드가 구현 코드보다 먼저 작성되어야 한다는 걸 느꼈다.&lt;/p&gt;
&lt;p&gt;100%의 테스트 커버리지를 자랑하는 것도 좋겠지만, 테스트 코드 작성 이유에 대해 경험을 통해 동의할 수 있는 부분들을 위주로 커버하려 했다.
그 시작점은 사이드 이펙트가 없는 순수한 함수 테스트이다. &lt;code class=&quot;language-text&quot;&gt;moment.js&lt;/code&gt;와 같이 의존성 모듈에서 제공하는 함수들을 사용하는 함수들의 테스트는
패키지에게 테스트를 맡길 수 있을 거라 기대하고, 내가 작성한 함수들에만 집중했다.&lt;/p&gt;
&lt;p&gt;순수한 함수들의 테스트를 작성해두면 나중에 로직이 구구절절 불편하게 느껴질 때 함수의 결과가 이전과 동일하다는 것을 프로그래밍적으로 의지한 채
리팩토링해 낼 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export const getSortedLanguageList: SortedLanguageList = mergedLanguageList =&amp;gt; {
  return Object.entries(mergedLanguageList)
    .sort(([, a], [, b]) =&amp;gt; Number(b) - Number(a))
    .reduce((r, [k, v]) =&amp;gt; ({ ...r, [k]: v }), {});
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;describe(&amp;#39;...&amp;#39;, () =&amp;gt; {
  it(&amp;#39;getSortedLanguageList는 병합된 언어별 사용량을 기준으로 내림차순 정렬하여 반환한다.&amp;#39;, () =&amp;gt; {
    expect(getSortedLanguageList({})).toStrictEqual({});
    expect(getSortedLanguageList(mockedMergedLanguageList)).toStrictEqual(
      mockedMergedLanguageList
    );
  });
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다음으로 커버한 테스트는 섹션별 통합 테스트이다. 본 프로젝트에서는 각각의 독립적인 기능을 담고 있는 섹션(아래 이미지의 빨간 박스)을 통합 테스트 단위로 잡았고,
서버에서 가져온 데이터라 가정한 가짜 데이터들과 전역 상태를 주입해 의존성을 해결해 주었다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 49.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB0klEQVQoz2VSybLTQAzMCagiscezebyP7RiDTeIkj0dOvANLFbz//59GmiQkVRzkRRq11N2zklJCCIGEI0muISDoLbhGkVDIa9zOyGuee8VD74ofeZ4jTR20sTBaIbUOubZIhYSNBHTMA+9AtyUk5Rz15mUOrU3Ir7jQNA28b1GVFaq6xtSW+PI0YN7V6D45zB8duiJDmmUBVCkF5zL4xqOm823XIsvyy4ZKqkDPe4/9fo9lf8Bp9tC/BqgfW4ifA/avC6a+QU0AeUHbGI227fDt5QXn8xnLsmAcR8TEZBVtNphOT9juFrx7+wbr9xuMrYX9PUJ938L9mXF8PWBbZVBEyxgT6BZFga7rw6ZpmlLeXijHcYyB0J+/nmlqS3Q0htJid/IYdyWmg8fz4tE4aiBATXQVgWYEyBJZa4P+PCgAsrt5VWKeZzgqRDTAUGNFpuj1BmYT4Vw1oZZIMiaKIfsKae9R0HZa6wDEul4AST8WlDVkQ/q+J9dK9OMHfCZN3dWIhoTfDsOlUcnQU9ctUa/pu7hTvqHz1ZmmCcfjAZ6oM/hAAKxRkkgyoyA3e2rO/tFMXR6AjHnQ8Ha3WOgoirAmmqyroOD/xzrn75f//+BzfwETfALCbP1+VAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;GitGlances 통합 테스트 범위&quot;
        title=&quot;GitGlances 통합 테스트 범위&quot;
        src=&quot;/static/2a1a7b5961cb7146ae2a0aefc5a49edc/c1b63/git-glances-section-test.png&quot;
        srcset=&quot;/static/2a1a7b5961cb7146ae2a0aefc5a49edc/5a46d/git-glances-section-test.png 300w,
/static/2a1a7b5961cb7146ae2a0aefc5a49edc/0a47e/git-glances-section-test.png 600w,
/static/2a1a7b5961cb7146ae2a0aefc5a49edc/c1b63/git-glances-section-test.png 1200w,
/static/2a1a7b5961cb7146ae2a0aefc5a49edc/21b4d/git-glances-section-test.png 1280w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { render, screen } from &amp;#39;@testing-library/react&amp;#39;;
import { ContributionsCollection } from &amp;#39;@shared/apis/contribution&amp;#39;;
import Contribution from &amp;#39;../components&amp;#39;;
import useContributionsCollectionQuery from &amp;#39;../queries/useContributionsCollectionQuery&amp;#39;;
import { mockedContributionCollection } from &amp;#39;./mocks&amp;#39;;
import { RecoilRoot } from &amp;#39;recoil&amp;#39;;

const mockedUseContributionQuery = useContributionsCollectionQuery as jest.Mock&amp;lt;
  ContributionsCollection
&amp;gt;;

jest.mock(&amp;#39;../queries/useContributionsCollectionQuery&amp;#39;);

describe(&amp;#39;Contribution 컴포넌트는 유저의 오늘 기여도 정보를 랜더링한다.&amp;#39;, () =&amp;gt; {
  beforeEach(() =&amp;gt; {
    mockedUseContributionQuery.mockImplementation(
      () =&amp;gt; mockedContributionCollection
    );
  });

  afterEach(() =&amp;gt; {
    jest.clearAllMocks();
  });

  it(&amp;#39;유저의 총 기여도는 섹션 요약 정보에서 제공한다.&amp;#39;, async () =&amp;gt; {
    render(
      &amp;lt;RecoilRoot&amp;gt;
        &amp;lt;Contribution /&amp;gt;
      &amp;lt;/RecoilRoot&amp;gt;
    );
    const totalContributions = await screen.findByText(&amp;#39;3&amp;#39;);
    expect(totalContributions).toBeInTheDocument();
  });
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;프로젝트-구조&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EA%B5%AC%EC%A1%B0&quot; aria-label=&quot;프로젝트 구조 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;프로젝트 구조&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;components&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;hooks&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;utils&lt;/code&gt; 별로 디렉토리를 구성하고 로직 레벨과 UI를 융합하기 위해 거대한 코드 베이스를 다시 거슬러 올라가기도 하고, 원하는 의존성이
어디에 위치에 했는지 관련된 코드의 기억을 더듬어 검색해보기도 한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { getSortedLanguageList } from &amp;#39;../../../../utils/language&amp;#39;;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;본 프로젝트도 초기에는 동일한 구조로 진행하다가 레퍼런스 삼아 이전 회사 리드 분의 프로젝트 구조를 보고선 카톡을 드려 해당 프로젝트의 레퍼런스를 얻어냈다.
&lt;a href=&quot;https://ahnheejong.name/articles/package-structure-with-the-principal-of-locality-in-mind/&quot;&gt;지역성의 원칙을 고려한 패키지 구조: 기능별로 나누기&lt;/a&gt;
를 읽어보면 프로젝트 구조를 잡는데도 많은 고민을 담아내는 것에 놀라울 따름이다.&lt;/p&gt;
&lt;p&gt;받아들이기 나름이지만, 섹션별로 각각의 기능을 구사하는 제품을 제작하고 있었기 때문에 글에서 언급하는 ‘캐시 미스’를 최소화할 수 있는 지역성이 발생하는 기능별 단위로
디렉토리를 구성했고, 작업 중인 기능의 맥락 블록을 기능별 디렉토리로 기준 삼아 머릿속에 적재한 상태로 작업해 코드 베이스 속에서 헤매지 않고 원하는 의존성을 찾아낼 수 있었다.
더불어 그 수정 범위 또한 예측 가능해지는 장점도 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;src
├─ Contribution
│  └─ atoms
│  └─ components
│  └─ queries
│  └─ test
│  └─ utils
├─ Daily
├─ Language
├─ Notification
├─ Refactor
├─ ...
├─ _layout
├─ _shared&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;react&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#react&quot; aria-label=&quot;react permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;react&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;react v.18&lt;/code&gt;은 동시성 기능을 담아내기 위해 5년에 가까운 시간을 들여 기저의 아키텍처부터 멘탈 모델을 고안해 만든 대규모 업데이트를 포함하고 있다. 충분한
공부가 필요했고 &lt;a href=&quot;https://youthfulhps.dev/react/react-concurrent-mode-01/&quot;&gt;메커니즘 구현체에 대해 열심히 톺아본 결과물&lt;/a&gt;을 글로 정리해 보기도 했다.&lt;/p&gt;
&lt;h3 id=&quot;suspense&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#suspense&quot; aria-label=&quot;suspense permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Suspense&lt;/h3&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Suspense&lt;/code&gt;는 자신이 감싼 하위 컴포넌트에서 &lt;code class=&quot;language-text&quot;&gt;throw&lt;/code&gt;된 &lt;code class=&quot;language-text&quot;&gt;promise&lt;/code&gt;가 &lt;code class=&quot;language-text&quot;&gt;resolve&lt;/code&gt;될 때까지 하위 컴포넌트 작업을 낮은 우선순위로 레인을 변경해 우선순위를
다른 작업에 넘겨주는 역할을 한다. 그러곤 하위 컴포넌트 랜더링을 보장받을 수 있을 때까지 &lt;code class=&quot;language-text&quot;&gt;fallback&lt;/code&gt;에 제공된 노드를 노출시킨다.&lt;/p&gt;
&lt;p&gt;여기서 &lt;code class=&quot;language-text&quot;&gt;promise&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;React.lazy&lt;/code&gt;를 통해 동적으로 필요한 자원을 로드하는 것, 컨텐츠 랜더링에 사용될 데이터 요청하는 것을 포함한 기다릴 수 있는 모든 것이
그 대상이 되고, 덕분에 개발자를 피곤하게 했던 데이터 패칭에 대한 성공 여부에 따른 UI 구성 분기를 선언적으로 할 수 있게 한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const resource = fetchProfileData();
function App() {
  return (
    &amp;lt;ErrorBoundary fallback={&amp;lt;Error /&amp;gt;}&amp;gt;
      &amp;lt;Suspense fallback={&amp;lt;Loader /&amp;gt;}&amp;gt;
        &amp;lt;UserProfile /&amp;gt;
      &amp;lt;/Suspense&amp;gt;
    &amp;lt;/ErrorBoundary&amp;gt;
  );
}

function UserProfile() {
  const user = resource.user.read();
  return &amp;lt;div&amp;gt;{user.userName}&amp;lt;/div&amp;gt;;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;em&gt;Suspense에 대한 내용은 따로 자세히 정리할 예정으로 본 글에서는 축약해 정리했습니다.&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;error-boundary&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#error-boundary&quot; aria-label=&quot;error boundary permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Error Boundary&lt;/h3&gt;
&lt;p&gt;자바스크립트로부터 발생하는 에러가 리엑트 내부 상태들을 훼손하고 제품 전체의 랜더링 문제를 발생시켰지만, 리엑트는 이를 대응할 만한 적절한 방법을 제공하지 않았었다.
그러다 &lt;code class=&quot;language-text&quot;&gt;react v16&lt;/code&gt;에서 새롭게 에러 경계라는 새로운 개념을 도입해 발생한 에러가 퍼지는 경계를 두어 앱 전역으로 에러가 영향을 끼치는 것을 제한하고, 랜더링 이슈가 발생한
컴포넌트 대신 &lt;code class=&quot;language-text&quot;&gt;fallback&lt;/code&gt;으로 전환될 수 있도록 한다.&lt;/p&gt;
&lt;p&gt;에러 경계는 &lt;code class=&quot;language-text&quot;&gt;static getDerivedStateFromError()&lt;/code&gt; 혹은 &lt;code class=&quot;language-text&quot;&gt;componentDidCatch()&lt;/code&gt; 가 선언된 클래스 컴포넌트로 구현할 수 있고, 이 컴포넌트 자체가
에러의 경계가 된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    // 다음 렌더링에서 폴백 UI가 보이도록 상태를 업데이트 합니다.
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    // 에러 리포팅 서비스에 에러를 기록할 수도 있습니다.
    logErrorToMyService(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      // 폴백 UI를 커스텀하여 렌더링할 수 있습니다.
      return &amp;lt;h1&amp;gt;Something went wrong.&amp;lt;/h1&amp;gt;;
    }

    return this.props.children;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;에러가 발생하면 &lt;code class=&quot;language-text&quot;&gt;fallback&lt;/code&gt;이 노출될 수 있도록 상태를 업데이트하는 것은 &lt;code class=&quot;language-text&quot;&gt;static getDerivedStateFromError()&lt;/code&gt;이 담당하고,
에러 정보를 기록하기 위헤 &lt;code class=&quot;language-text&quot;&gt;componentDidCatch()&lt;/code&gt;가 사용된다.
프로젝트에서는 각각의 섹션별로 에러 경계를 두고 다른 기능을 담당하는 섹션에 에러가 번져나가지 않도록 막았다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;...

const initialState: ErrorBoundaryState = {
  hasError: false,
  error: null,
  errorMessage: null,
};

class ErrorBoundary extends React.Component&amp;lt;ErrorBoundaryProps, ErrorBoundaryState&amp;gt; {
  constructor(props: ErrorBoundaryProps) {
    super(props);
    this.state = initialState;
  }

  static getDerivedStateFromError(error: any) {
    return {
      hasError: true,
      error,
      errorMessage: typeof error.message === &amp;#39;string&amp;#39; ? error.message : null,
    };
  }

  resetErrorBoundaryState = () =&amp;gt; {
    const { reset } = this.props;
    this.setState({ ...initialState });
    if (reset) reset();
  };

  render() {
    const { hasError, error, errorMessage } = this.state;
    const { children, gridArea, hasToken } = this.props;

    if (!hasToken) {
      return &amp;lt;PulseSection gridArea={gridArea} /&amp;gt;;
    }

    if (hasError &amp;amp;&amp;amp; error) {
      return (
        &amp;lt;Error
          errorMessage={errorMessage}
          reset={this.resetErrorBoundaryState}
          gridArea={gridArea}
        /&amp;gt;
      );
    }

    return children;
  }
}

export default ErrorBoundary;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;에러 경계 컴포넌트는 &lt;code class=&quot;language-text&quot;&gt;Suspense&lt;/code&gt;와 함께 사용하기 좋다. &lt;code class=&quot;language-text&quot;&gt;Suspense&lt;/code&gt;는 로딩 중의 &lt;code class=&quot;language-text&quot;&gt;fallback&lt;/code&gt;을 담당하고, &lt;code class=&quot;language-text&quot;&gt;ErrorBoundary&lt;/code&gt;를 통해
&lt;code class=&quot;language-text&quot;&gt;promise&lt;/code&gt;의 &lt;code class=&quot;language-text&quot;&gt;reject&lt;/code&gt;에 담긴 에러를 핸들링한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function SuspenseBoundary({ children, gridArea = &amp;#39;&amp;#39; }: SuspenseBoundaryProps) {
  const { reset } = useQueryErrorResetBoundary();
  const gitGlancesTokenValue = useRecoilValue(tokenAtom);

  return (
    &amp;lt;ErrorBoundary
      reset={reset}
      gridArea={gridArea}
      hasToken={!!gitGlancesTokenValue}
    &amp;gt;
      &amp;lt;Suspense fallback={&amp;lt;SectionSpinner gridArea={gridArea} /&amp;gt;}&amp;gt;
        {children}
      &amp;lt;/Suspense&amp;gt;
    &amp;lt;/ErrorBoundary&amp;gt;
  );
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// UserProfile 섹션에서 발생한 에러는 Language 섹션에 영향을 끼치지 않는다.
&amp;lt;SuspenseBoundary gridArea=&amp;quot;Profile&amp;quot;&amp;gt;
  &amp;lt;UserProfile /&amp;gt;
&amp;lt;/SuspenseBoundary&amp;gt;
&amp;lt;SuspenseBoundary gridArea=&amp;quot;Language&amp;quot;&amp;gt;
  &amp;lt;Language /&amp;gt;
&amp;lt;/SuspenseBoundary&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;react-query&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#react-query&quot; aria-label=&quot;react query permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;react-query&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;react-query&lt;/code&gt;는 뷰를 구성하는 데 필요한 데이터를 사용하기 위해 요청 작성과 응답을 받은 직후 데이터 참조 및 예외 처리를 해주어야 하는 개발자 책임을 위임할 수 있게 한다.&lt;/p&gt;
&lt;p&gt;쿼리라는 각각의 인스턴스가 필요한 데이터를 알아서 캐싱, 리패칭해 요청 시점이 데이터 참조의 직전이 아니더라도 뷰에서 필요로 하는 최신화된 데이터를 사용할 수 있도록
보장해 준다. 관행처럼 리덕스 미들웨어에 비동기 로직을 담아 서버 상태 값을 매번 최신화해 주어야 했던 책임을 라이브러리에게 위임한다는 것은 충분히 좋은 경험이었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const useContributionsCollectionQuery = (from: string, to: string) =&amp;gt; {
  const { data: contributionsCollection } = useQuery&amp;lt;
    ContributionsCollection,
    AxiosError
  &amp;gt;({
    queryKey: [&amp;#39;contributionsCollection&amp;#39;, from, to],
    refetchOnWindowFocus: true,
    queryFn: async () =&amp;gt; {
      const { data } = await getContributionsCollection(from, to);
      const destructuredContributionsCollection = getDestructuredContributionsCollection(
        data
      );

      return destructuredContributionsCollection;
    },
  });

  return contributionsCollection as ContributionsCollection;
};

export default useContributionsCollectionQuery;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;react-query&lt;/code&gt;에서는 쿼리를 &lt;code class=&quot;language-text&quot;&gt;stale&lt;/code&gt;하게 혹은 &lt;code class=&quot;language-text&quot;&gt;inactive&lt;/code&gt; 상태의 쿼리를 특정 기간 동안 캐싱할 것인지 결정할 수 있는 &lt;code class=&quot;language-text&quot;&gt;staleTime&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;cacheTime&lt;/code&gt;을 지정할 수 있다.
본 프로젝트의 기능을 예시로 들면, &lt;code class=&quot;language-text&quot;&gt;notification&lt;/code&gt;이나 &lt;code class=&quot;language-text&quot;&gt;contribution&lt;/code&gt;의 경우 앱이 새롭게 마운트되거나, 포커스를 받았을 때 즉시 업데이트해주어야 했지만, 한달 단위의
트랜드 레포지토리를 보여주는 &lt;code class=&quot;language-text&quot;&gt;trends&lt;/code&gt;섹션의 경우 즉시 업데이트가 될 필요가 없어 하루 정도 쿼리를 &lt;code class=&quot;language-text&quot;&gt;fresh&lt;/code&gt;하게 유지해줘도 크게 문제되지 않았을 것이다.&lt;/p&gt;
&lt;p&gt;정말 아쉽게도 본 프로젝트에서 &lt;code class=&quot;language-text&quot;&gt;graphql&lt;/code&gt;로 구성된 github API를 사용했는데, &lt;code class=&quot;language-text&quot;&gt;graphql&lt;/code&gt;은 일반적으로 POST 메서드를 사용해 쿼리를 바디에 담아 요청을 전달하는 구조여서
GET 메서드를 통해 얻은 데이터를 가지는 쿼리처럼 상태를 제어할 수 없어 기민하게 API 요청을 최적화할 수 없었다.&lt;/p&gt;
&lt;h2 id=&quot;recoil&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#recoil&quot; aria-label=&quot;recoil permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;recoil&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;recoil&lt;/code&gt;은 &lt;code class=&quot;language-text&quot;&gt;atom&lt;/code&gt; 단위로 전역 상태를 구성하고, &lt;code class=&quot;language-text&quot;&gt;selector&lt;/code&gt;를 통해 소비자에게 전역 상태를 구독, 업데이트할 수 있는 API를 제공한다. 리덕스를 다시 생각해 보면
서버로부터 전달받은 데이터와 클라이언트의 전역 상태가 공존하는 스토어 구조였지만, 서버 상태 관리를 &lt;code class=&quot;language-text&quot;&gt;react-query&lt;/code&gt;에게 맡기고 &lt;code class=&quot;language-text&quot;&gt;recoil&lt;/code&gt;은 클라이언트의 전역 상태에
집중할 수 있도록 사용했다.&lt;/p&gt;
&lt;p&gt;더불어, 브라우저 스토어와 상태를 동기화시켜 &lt;code class=&quot;language-text&quot;&gt;persist&lt;/code&gt;하게 유지시켜 주어야 하는 전역 상태를 관리하기 용이했다. &lt;code class=&quot;language-text&quot;&gt;atom effects&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;atom&lt;/code&gt;을 동기화하거나 초기화하기
위해 사용되는데 페이지가 새로고침 되었을 때 &lt;code class=&quot;language-text&quot;&gt;localStorage&lt;/code&gt;와 같은 브라우저 스토어에서 저장해 두었던 이전 상태를 불러와 &lt;code class=&quot;language-text&quot;&gt;atom&lt;/code&gt;을 초기화한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { AtomEffect } from &amp;#39;recoil&amp;#39;;
import {
  getChromeStorageItem,
  setChromeStorageItem,
} from &amp;#39;@shared/utils/chrome&amp;#39;;

const localStorageEffect = &amp;lt;AtomDataType&amp;gt;(key: string) =&amp;gt; {
  const effects: AtomEffect&amp;lt;AtomDataType&amp;gt; = ({ setSelf, onSet }) =&amp;gt; {
    const savedValue = localStorage.getItem(key);
    if (savedValue != null) {
      setSelf(JSON.parse(savedValue));
    }

    onSet((newValue, _, isReset) =&amp;gt; {
      if (isReset) {
        localStorage.removeItem(key);
      } else {
        localStorage.setItem(key, JSON.stringify(newValue));
      }
    });
  };

  return effects;
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export const dailyRepoAtom = atom&amp;lt;AtomRepoState&amp;gt;({
  key: &amp;#39;dailyRepo&amp;#39;,
  default: {
    prevRepo: null,
    updatedAt: &amp;#39;&amp;#39;,
    hasTodayContribution: false,
  },
  effects: [storageEffect&amp;lt;AtomRepoState&amp;gt;(&amp;#39;dailyRepo&amp;#39;)],
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://jeonghwan-kim.github.io/series/2019/12/22/frontend-dev-env-babel.html&quot;&gt;프론트엔드 개발환경의 이해: Babel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://maxkim-j.github.io/posts/frontend-tooling-ideas/&quot;&gt;React 개발 환경 구축하며 알게된 자잘한 것들&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ahnheejong.name/articles/package-structure-with-the-principal-of-locality-in-mind/&quot;&gt;지역성의 원칙을 고려한 패키지 구조: 기능별로 나누기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://maxkim-j.github.io/posts/suspense-argibraic-effect/&quot;&gt;Suspense for Data Fetching의 작동 원리와 컨셉 (feat.대수적 효과)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://maxkim-j.github.io/posts/react-query-preview&quot;&gt;React-Query 살펴보기&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://recoiljs.org/docs/guides/atom-effects/&quot;&gt;Atom Effects&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[중요 랜더링 경로]]></title><description><![CDATA[중요 랜더링 경로(Critical Rendering Path)는 브라우저가 HTML, CSS, Javascript를 화면에 픽셀로 변환하는 일련의 과정을 말한다. 중요 랜더링 경로 1. HTML을 통해 DOM 트리를 생성한다.  이미지 출처…]]></description><link>https://youthfulhps.dev/TIL/web/critical-rendering-path/</link><guid isPermaLink="false">https://youthfulhps.dev/TIL/web/critical-rendering-path/</guid><pubDate>Sun, 22 Oct 2023 13:05:26 GMT</pubDate><content:encoded>&lt;p&gt;중요 랜더링 경로(Critical Rendering Path)는 브라우저가 HTML, CSS, Javascript를 화면에 픽셀로 변환하는 일련의 과정을 말한다.&lt;/p&gt;
&lt;h2 id=&quot;중요-랜더링-경로&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A4%91%EC%9A%94-%EB%9E%9C%EB%8D%94%EB%A7%81-%EA%B2%BD%EB%A1%9C&quot; aria-label=&quot;중요 랜더링 경로 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;중요 랜더링 경로&lt;/h2&gt;
&lt;h3 id=&quot;1-html을-통해-dom-트리를-생성한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-html%EC%9D%84-%ED%86%B5%ED%95%B4-dom-%ED%8A%B8%EB%A6%AC%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;1 html을 통해 dom 트리를 생성한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. HTML을 통해 DOM 트리를 생성한다.&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1123px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAADhklEQVQozwF7A4T8AAKcU38AmE+oAJJMowCgU6ANb0EwFQACFxMbGBwREREgFBUVGiMkJQ8jJCUPJSYnDiAhIhEnKCkNJSYnDiMjJA8mJygOHyAhETEyMwv///8BAI3BuXeKvbWehrWunY/GvJZ5n5gnAAAACUJDPRA6NjEPNC8qD0tHQgtGQj0MSkQ9C01IQAtIQz0LSUQ9C0tGQAtUTkYKx7imBLWomQSrppwDANHY6XPFzNyZt73LmNXc7pCkq7guTVBLIVdcYCNcYWQgWVxbJ0xQVyJVV1YmVFlbJkpPVCVUVlUpTFJXJVNWViZeYmIjt8POD8HGvxPHy8oKALrT8Xi30O+frsbin73X94+mv+BgnLnmdqjF7WuivOF2nLzrb8LV8m+qx/djobvefKzI7nOXtuZurcXlfJ6/8GmdueJ0q8jvc6jI+27I2v1IAOrPeHXiyHKc1r1tnO/Sd5DRwog61MB4is/CjETLvoZN0b12hr7IyhnTwHp8y7yAV8XAnDDTv3eKvbueKtvHgHHZxoBo0MaVPtbCeZzZyYo/AOvJY3fnxV+f27xcnvHNYZbWvW0q3Md8UdLDiR/XxYQl3cd5Va+1uwbcx3pN3sd4QNrEeTHbxXlhxb2XEt7JfkLfyoA708SHIdjEe1jLv4kbAPHPZ3zuzGOj48Nfn/bSZ53ewGci5cdmANy+agnTumwO/9E8AJiovwb/3DMAzb+DatjDd6zbrSIA1tJ5AO/QZgD102IA/9o3AOTHYwDmy1wAAGpnXgHOvIUC//+vAnVxYwLzwjwBu8GsBtTCfG3Zw3Wgp7GkKAA6zAJ+ossJ0cGCbNnEdotLlPoHAAD/Ad/Kewztz20H/+xfAObLZgLkzl4AACIwWwCvqJMA////AP//AADet0kA2sR2d9TCe3bayIFF3sd5pbvExyfdyYCN2sd9hWaf/w2brc0Zl7nwEtjEeqTgynlu9c9eAPrTXwHJwJUAAOPEZgDqyWUA6clmAOrHXgD6wSgA1sF0BuDLiQjj5OYA0trmWMnU6qHMy7Rz1L5wqMzQy3vCzeOmzdjqNd3Fbo3cx3pr7MlfAPbOWQHMwo4AAAAAAAAAAAAAzcOOAPS5IgDrvDwA1sF0ANi6WgA8AAAA////APf//wjJ0+Oexs3YtsfR4nv///8E///ZANjHhwPDtXkC6MRZAN6/XwANb/8AHHDE/H2VdygAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;DOM 트리 생성 과정&quot;
        title=&quot;DOM 트리 생성 과정&quot;
        src=&quot;/static/b79e8f8eb86c99f1823e7aedf553bdf3/e751c/dom-construction-process.png&quot;
        srcset=&quot;/static/b79e8f8eb86c99f1823e7aedf553bdf3/5a46d/dom-construction-process.png 300w,
/static/b79e8f8eb86c99f1823e7aedf553bdf3/0a47e/dom-construction-process.png 600w,
/static/b79e8f8eb86c99f1823e7aedf553bdf3/e751c/dom-construction-process.png 1123w&quot;
        sizes=&quot;(max-width: 1123px) 100vw, 1123px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://web.dev/articles/critical-rendering-path/constructing-the-object-model?hl=ko&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 변환&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;브라우저의 랜더링 엔진은 요청을 통해 전달받은 HTML의 원시 바이트를 읽은 후 파일의 지정된 인코딩 (UTF-8)에 따라 개별 문자로 변환한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 토큰화&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;브라우저는 &lt;a href=&quot;https://html.spec.whatwg.org/multipage/&quot;&gt;W3C HTML5 표준&lt;/a&gt;에 따라 지정된 대로 문자열을 개별 토큰으로 변환하고,
꺽쇄 괄호로 묶인 기타 문자열을 반환한다. 각 토큰에는 각각의 고유한 규칙과 의미를 가진다. 즉 개별 문자열에서 HTML5 표준에 입각해서 작성된
문자열 묶음을 찾아 토큰화한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 렉싱&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;추출된 각각의 토큰은 해당 토큰이 가지는 속성과 규칙을 정의하는 객체(DOM 트리를 구성하는 각각의 노드)로 변환된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. DOM 생성&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;HTML 마크업이 정의한 대로 여러 태그 간의 관계를 따라 렉싱 단계에서 생성된 객체를 트리 구조로 연결한다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 582px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC7klEQVQoz21QW0gUCxj+d5Ts9BT0VG/VU73UQxQRREVEL9FLBnKoQ1ZG2cUsKgS1IkwMPQi15CE1e+ipHoosNN2snHH2Mjv32ZnZuey6s7PrXnDbTT0u1n8mOY998PNf+L6Pnw/6JrCO0/NdjGC8YJXkICMaI7zqvHo6hVtnI20Nbugq6cxcJJ1oeydsQMAVIBDBd6S7Cl4HXAbCpRprXbad8DaAh2O4TjTyM1FBW2aEeJqOahQlFF7vfoabP078cyJBXp4SJ65ICt19b9Xg/zrY9XPN6lz8A7Lkn5AX2gCOeQczFvEhjsJLRN/w45uwXPXXZphrZ+3gnRGZ6up8PxNajzpA62B8l0Z1PjDJ1r85sq95eweupz4PNMhfO0ZtqvVVgnlwZvVDPZEDlldAsv+F76kP0PPMv3WOvSnMRy+mCvwtZWry6Q4p2A9WuKPepZtSZuB0ocQ3jyL2Q55tacwELxjJ6XPJObb1LuIgQFidb4rKqW5KyPaMhdwBWin1+gO4jf706Pr0x56hdOR2y+exjo3jHO6bZHJ94+GMnxRLbeORwl+Usng+wJaGA1zFH1GK/ZRUqAcl7hiyLCHH8SiKAqqqhiHZbikyFyatqTOLOaalGHh3Y6/hLIxYpu5xRIzrKgpGwbRSOU2WPJ3AoSjHULK/DQOjFW7JRuZNWEz6Sc659PaLefzoc1yLS/eh4XFhi5cLUc5QwJqVU148E4ycejLNOefehJf2iHalWU0Uh4JS9lqAzR+g9JVNIGguiLIOX0ka2FgaaAN3xqx8TFITYUZOc3wsSeu2q7NGpenHggufphkQlTjw1gLYbgUSqQzImgW8lgFSrQKIepbwCLWSlqzLln6AOrtw0klnMBoJocBHkedZtG0bzXRlCHERlubtOkY0axi9TMRTJcKwnRoxZtawyixBa4s++IWDXSsgWN8IzizDTKy830qXioJizvGKzYcF64Vk5HqD2vfD+LMMWC36GgeqcMjT/A7/AX9zD+4fdPzQAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;DOM 트리 예시&quot;
        title=&quot;DOM 트리 예시&quot;
        src=&quot;/static/ba10324c0460655c5080bfd2d2380033/7c1cd/dom-tree.png&quot;
        srcset=&quot;/static/ba10324c0460655c5080bfd2d2380033/5a46d/dom-tree.png 300w,
/static/ba10324c0460655c5080bfd2d2380033/7c1cd/dom-tree.png 582w&quot;
        sizes=&quot;(max-width: 582px) 100vw, 582px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://web.dev/articles/critical-rendering-path/constructing-the-object-model?hl=ko&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;2-css를-통해-cssom를-생성한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-css%EB%A5%BC-%ED%86%B5%ED%95%B4-cssom%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;2 css를 통해 cssom를 생성한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. CSS를 통해 CSSOM를 생성한다.&lt;/h3&gt;
&lt;p&gt;DOM 트리가 문서 마크업의 속성과 관계를 캡처하지만, 요소가 랜더링될 때 어떻게 표시되어야 하는지에 대한 정보를 CSSOM로 구성한다.
브라우저가 페이지의 DOM을 생성하는 동안 문서의 헤드 섹션에서 외부 CSS 스타일시트를 참조하는 링크를 만나면 페이지 랜더링 과정에서
해당 자원이 필요하다고 판단하고 즉시 해당 자원에 대한 요청을 보내 CSS를 반환받는다.&lt;/p&gt;
&lt;p&gt;CSSOM 트리가 생성되는 과정은 DOM 트리 생성 과정과 동일하게 변환, 토큰화, 렉싱 과정을 걸쳐 CSSOM 트리를 구축한다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 582px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC7klEQVQoz21QW0gUCxj+d5Ts9BT0VG/VU73UQxQRREVEL9FLBnKoQ1ZG2cUsKgS1IkwMPQi15CE1e+ipHoosNN2snHH2Mjv32ZnZuey6s7PrXnDbTT0u1n8mOY998PNf+L6Pnw/6JrCO0/NdjGC8YJXkICMaI7zqvHo6hVtnI20Nbugq6cxcJJ1oeydsQMAVIBDBd6S7Cl4HXAbCpRprXbad8DaAh2O4TjTyM1FBW2aEeJqOahQlFF7vfoabP078cyJBXp4SJ65ICt19b9Xg/zrY9XPN6lz8A7Lkn5AX2gCOeQczFvEhjsJLRN/w45uwXPXXZphrZ+3gnRGZ6up8PxNajzpA62B8l0Z1PjDJ1r85sq95eweupz4PNMhfO0ZtqvVVgnlwZvVDPZEDlldAsv+F76kP0PPMv3WOvSnMRy+mCvwtZWry6Q4p2A9WuKPepZtSZuB0ocQ3jyL2Q55tacwELxjJ6XPJObb1LuIgQFidb4rKqW5KyPaMhdwBWin1+gO4jf706Pr0x56hdOR2y+exjo3jHO6bZHJ94+GMnxRLbeORwl+Usng+wJaGA1zFH1GK/ZRUqAcl7hiyLCHH8SiKAqqqhiHZbikyFyatqTOLOaalGHh3Y6/hLIxYpu5xRIzrKgpGwbRSOU2WPJ3AoSjHULK/DQOjFW7JRuZNWEz6Sc659PaLefzoc1yLS/eh4XFhi5cLUc5QwJqVU148E4ycejLNOefehJf2iHalWU0Uh4JS9lqAzR+g9JVNIGguiLIOX0ka2FgaaAN3xqx8TFITYUZOc3wsSeu2q7NGpenHggufphkQlTjw1gLYbgUSqQzImgW8lgFSrQKIepbwCLWSlqzLln6AOrtw0klnMBoJocBHkedZtG0bzXRlCHERlubtOkY0axi9TMRTJcKwnRoxZtawyixBa4s++IWDXSsgWN8IzizDTKy830qXioJizvGKzYcF64Vk5HqD2vfD+LMMWC36GgeqcMjT/A7/AX9zD+4fdPzQAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;CSSOM 트리 예시&quot;
        title=&quot;CSSOM 트리 예시&quot;
        src=&quot;/static/ba10324c0460655c5080bfd2d2380033/7c1cd/dom-tree.png&quot;
        srcset=&quot;/static/ba10324c0460655c5080bfd2d2380033/5a46d/dom-tree.png 300w,
/static/ba10324c0460655c5080bfd2d2380033/7c1cd/dom-tree.png 582w&quot;
        sizes=&quot;(max-width: 582px) 100vw, 582px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://web.dev/articles/critical-rendering-path/constructing-the-object-model?hl=ko&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CSS는 가장 일반적인 스타일 규칙이 적용되고 더 구체적인 규칙을 적용하는 하향식이기 때문에 CSSOM 또한 트리 구조를 띄고 있다.&lt;/p&gt;
&lt;h3 id=&quot;3-dom-트리와-cssom-트리를-결합해-랜더트리를-생성한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-dom-%ED%8A%B8%EB%A6%AC%EC%99%80-cssom-%ED%8A%B8%EB%A6%AC%EB%A5%BC-%EA%B2%B0%ED%95%A9%ED%95%B4-%EB%9E%9C%EB%8D%94%ED%8A%B8%EB%A6%AC%EB%A5%BC-%EC%83%9D%EC%84%B1%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;3 dom 트리와 cssom 트리를 결합해 랜더트리를 생성한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. DOM 트리와 CSSOM 트리를 결합해 랜더트리를 생성한다.&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1150px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 46.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC10lEQVQozzVSWUwTARAdwCKIgkE0RFJIMJqoqGjUL7+UxMRbMRgR8YNLKlK1EUTkUqAKckUQjBIJQcIhqBShhVJKd9st3d0e225Luy1tuQJI1ATlAz/WBePHZCaTd2ReBmZNZfCbKdl8K+F4OOwUBayq9gM+WnbGhuS1TxCNwb2SJphjumFxld1Y/vL10Ya3H2JZlgWvRhA2b3gSNqu7DULxM7CrBMC2AYBO1xlMqx6X0WhRcX6bJOBgNsLTKKqTLaOi8ksFJbwrLxjeMro7ELcuHKDssy1Gm7d8QGM9SSnz8vSKfGGnpGl7cc2jQEaVwgfOCCaQnGyzMueBFS0qMGItpbSuSTCpuf++9Ssa0TW2EqNDm6861Q+HaaJlzxi5ED2ATR92YIXNDuRuCqLqOG1CqhBM259oRGoG9Xh/PIz0iWAI0QLqYkNw66JYa2RySWXVgBZH6tXUd7FZ//kyM5YqsthMZ0nKaccpN6YnR2qN6KsvNDM9RFCTUsq5VGewuCU6ytsFgqxs33uiHH+PReY3TlpBrZ+8hhDummHNRMJaVv/KsN57ZOS2XqWLrze7+jSEXYVRs1lr+7hz1zcUNsiC1mbIzMz0TUtL5UVGRYUeij0SzsXqQ80sg5bw7iAo9zGJeoGPEHNhtM0RNyrt5EgWDvLfiIXK6ooAoTCLd/FEhF9h8VN/SLqZDOnpGRwINnEVJCwWB0ot7miDY7qDcsx064xUisWMxHu80y8INxtpV4uiftD5fKmiCbqUMujHUCivq13jg0DA6STeSIL0jHVBqHz3BgYt7l0KA2IdHJdj7ZqpJBdRVeEhxT2fEE901iAb4Nbm9k6N5zTWG9gQBaWLkZtN+6T0pB/9h4X6Vu5vfHwAQjmxU+cvrJ/Qizt5xjknXz61stXqmi8lbYvPcfsvEW5ytuHMyt4p7E6uB83OkNsY0ahhzKswjX8kv/3cgs8vAcLY4C8Q/p9A9HrMUwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;랜더트리 예시&quot;
        title=&quot;랜더트리 예시&quot;
        src=&quot;/static/c4a9c39ed672106bdd6822c6ccc5f373/33d1d/dom-cssom-are-combined.png&quot;
        srcset=&quot;/static/c4a9c39ed672106bdd6822c6ccc5f373/5a46d/dom-cssom-are-combined.png 300w,
/static/c4a9c39ed672106bdd6822c6ccc5f373/0a47e/dom-cssom-are-combined.png 600w,
/static/c4a9c39ed672106bdd6822c6ccc5f373/33d1d/dom-cssom-are-combined.png 1150w&quot;
        sizes=&quot;(max-width: 1150px) 100vw, 1150px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://web.dev/articles/critical-rendering-path/render-tree-construction?hl=ko&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;브라우저는 DOM과 CSSOM을 결합하여 페이지에 표시되는 DOM 컨텐츠와 해당 노드에 대한 CSSOM 스타일 정보를 캡처하는 랜더 트리를 구축한다.&lt;/p&gt;
&lt;p&gt;DOM 트리의 루트 노드부터 시작해서 각각의 노드를 순회한다. 이떄 랜더링에 표시되지 않는 script, meta와 같은 태그는 생략되며,
해당 DOM에 대한 CSSOM 스타일 정보 중 &lt;code class=&quot;language-text&quot;&gt;display: none&lt;/code&gt;이 포함되어 있다면 해당 노드 또한 생략된다.&lt;/p&gt;
&lt;p&gt;이후 CSSOM 스타일 규칙을 찾아 적용하고, 컨텐츠와 계산된 스타일이 함께 표시된 랜더트리의 노드를 반환한다.&lt;/p&gt;
&lt;h3 id=&quot;4-레이아웃-리플로우&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EB%A0%88%EC%9D%B4%EC%95%84%EC%9B%83-%EB%A6%AC%ED%94%8C%EB%A1%9C%EC%9A%B0&quot; aria-label=&quot;4 레이아웃 리플로우 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 레이아웃 (리플로우)&lt;/h3&gt;
&lt;p&gt;랜더트리가 준비되면 레이아웃 단계를 진행한다. 화면에 표시해야 할 노드와 스타일을 통해 기기의 영역 내에서 노드의 정확한 위치와
크기를 결정하는 단계이다.&lt;/p&gt;
&lt;p&gt;레이아웃 단계의 출력은 상자 모델로, 표시 영역 내 각 요소들의 정확한 위치와 크기를 캡처한다. 가령 %와 같은 상대적인 값은 절대적인
픽셀로 반환된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot; /&amp;gt;
    &amp;lt;title&amp;gt;Critial Path: Hello world!&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div style=&amp;quot;width: 50%&amp;quot;&amp;gt;
      &amp;lt;div style=&amp;quot;width: 50%&amp;quot;&amp;gt;Hello world!&amp;lt;/div&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 616px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 45.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABYElEQVQoz62SfWvCMBDG+/2/iGNsfyoMCgPrfNlQpwytXaO0mvQ9bbQic02fxSLObchg7ODHc7lwDxdymj0eG9ssddZxZCvIJo6JiEIiVJ5vNiTlnBBiE8uakSAISJqmJPF9knjeidjz7DQIXHM41DVzMPQCGoA5FN6SgbkUIfUhYg6xzsE8H+5yhSzLkOc5yrKE3O1QbLdfgKpRy5prd3pj4RIDS2IUk7EuXwYN2el3ZY9w2TGZNMYLqT9OJM/WEoCUZVnpOSVQKEXM+VSr12+c5841+q0r+dSsgc7qGIzaaE4itK0Q3dcE9yMXcSoOPdWEP5DyYIwwDE1tas4c5vtYUSopYwcF80OEfK0QlQZxirf9/mR4rse8MoyiyNQy9SHHusQvcW7yrf5pqMacHw5FUbyryYtLqKaLqPv345MnWpIkEf4plJerqSW7FUJ0OecttWMPf0H1GsqjZ9t27QPcyaRYMX8qrwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;레이아웃 계산&quot;
        title=&quot;레이아웃 계산&quot;
        src=&quot;/static/7fa749b73885c091e6ffdf4b69ec50b1/40040/calculating-layout-inform.png&quot;
        srcset=&quot;/static/7fa749b73885c091e6ffdf4b69ec50b1/5a46d/calculating-layout-inform.png 300w,
/static/7fa749b73885c091e6ffdf4b69ec50b1/0a47e/calculating-layout-inform.png 600w,
/static/7fa749b73885c091e6ffdf4b69ec50b1/40040/calculating-layout-inform.png 616w&quot;
        sizes=&quot;(max-width: 616px) 100vw, 616px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://web.dev/articles/critical-rendering-path/render-tree-construction?hl=ko&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-페인트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-%ED%8E%98%EC%9D%B8%ED%8A%B8&quot; aria-label=&quot;5 페인트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 페인트&lt;/h3&gt;
&lt;p&gt;레이아웃 단계가 완료되면 페인트 단계를 진행한다. 계산된 박스 모델들의 위치와 크기를 기반으로 실제 화면에 그려낸다.&lt;/p&gt;
&lt;h2 id=&quot;중요-랜더링-경로에서-기억해둘-것들&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A4%91%EC%9A%94-%EB%9E%9C%EB%8D%94%EB%A7%81-%EA%B2%BD%EB%A1%9C%EC%97%90%EC%84%9C-%EA%B8%B0%EC%96%B5%ED%95%B4%EB%91%98-%EA%B2%83%EB%93%A4&quot; aria-label=&quot;중요 랜더링 경로에서 기억해둘 것들 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;중요 랜더링 경로에서 기억해둘 것들&lt;/h2&gt;
&lt;h3 id=&quot;1-css-자원은-랜더링을-차단한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-css-%EC%9E%90%EC%9B%90%EC%9D%80-%EB%9E%9C%EB%8D%94%EB%A7%81%EC%9D%84-%EC%B0%A8%EB%8B%A8%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;1 css 자원은 랜더링을 차단한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. CSS 자원은 랜더링을 차단한다.&lt;/h3&gt;
&lt;p&gt;CSS는 일반적으로 랜더링을 차단하는 리소스이다. CSSOM이 구성이 되어야 레이아웃과 페인트 단계에서 입력으로 사용되는 랜더트리를 생성할 수 있고,
DOM이 없다는 것은 랜더링 할 것이 없다는 명확한 결과가 있지만, CSS 경우 불명확하다. 즉 CSS는 최대한 빨리 제공되어야 한다. (css 링크가 head에 있는 이유)
만약, CSS를 차단하지 않고 랜더링하는 경우 일시적으로 스타일이 적용되지 않은 상태로 랜더링되어 버리는 FOUC (Flash of Unstyled Content)가 발생한다.&lt;/p&gt;
&lt;p&gt;여기서 미디어 유형 및 쿼리를 사용해서 CSS 자원이 랜더링을 차단하지 않도록 지시할 수 있다. 하지만, 초기 랜더링 시에 긴급하게 적용 여부만 나타낼 뿐, 비차단 자원의
우선순위가 낮더라도 브라우저는 모든 CSS 자원을 다운로드한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;!--모든 조건에 랜더링을 차단한다.--&amp;gt;
&amp;lt;link href=&amp;quot;style.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; /&amp;gt;
&amp;lt;!--모든 조건에 랜더링을 차단한다.--&amp;gt;
&amp;lt;link href=&amp;quot;style.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;all&amp;quot; /&amp;gt;
&amp;lt;!--화면이 portrait 모드일 때만 랜더링을 차단한다. 만약 Landscape(가로) 모드라면 비차단.--&amp;gt;
&amp;lt;link href=&amp;quot;portrait.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;orientation:portrait&amp;quot; /&amp;gt;
&amp;lt;!--웹을 인쇄할 때만 적용되기 때문에 초기 랜더링 시 비차단으로 다운로드된다.--&amp;gt;
&amp;lt;link href=&amp;quot;print.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;print&amp;quot; /&amp;gt;
&amp;lt;!--쿼리로 전달된 조건에 일치하는 경우 랜더링을 차단한다.--&amp;gt;
&amp;lt;link href=&amp;quot;other.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot; media=&amp;quot;(min-width: 40em)&amp;quot; /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;2-script-태그는-페이지-하단에-위치하는-것이-좋다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-script-%ED%83%9C%EA%B7%B8%EB%8A%94-%ED%8E%98%EC%9D%B4%EC%A7%80-%ED%95%98%EB%8B%A8%EC%97%90-%EC%9C%84%EC%B9%98%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EC%A2%8B%EB%8B%A4&quot; aria-label=&quot;2 script 태그는 페이지 하단에 위치하는 것이 좋다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. script 태그는 페이지 하단에 위치하는 것이 좋다.&lt;/h3&gt;
&lt;p&gt;script 태그를 통해 얻는 자바스크립트 자원은 컨텐츠, 스타일, 상호작용에 대한 응답 등 페이지의 모든 측면에 변경을 가할 수 있다.
즉, 브라우저는 스크립트가 페이지에서 무엇을 하려고 하는 지 알지 못하기 때문에 최악의 시나리오를 가정하고 파서를 중단하고 자바스크립트 엔진에게
제어권을 넘겨 스크립트를 파싱하고 실행한다. 이는 초기 랜더링에 지연을 발생시킬 뿐 아니라 스크립트에서 아직 생성되지 않은 DOM을 쿼리할 여지가
있기 때문에 script 태그는 페이지 구성요소 최하단에 위치하는 것이 좋다.&lt;/p&gt;
&lt;p&gt;추가적으로 인라인 스크립트가 아닌 외부의 자바스크립트 자원을 불러오는 경우 자원이 모두 다운로드될 때까지 밀리초 단위의 지연이 발생한다.
자원의 다운로드가 지연을 불러오는 이슈를 막기 위해 스크립트가 사용 가능해질 때까지 DOM 생성을 차단하지 않도록 브라우저에게 지시할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;!--스크립트가 사용 가능해질 떄까지 DOM 생성을 차단하지 않고 이어간다. 이후 스크립트가 사용가능해지면 중단되고 스크립트를 실행한다.--&amp;gt;
&amp;lt;script src=&amp;quot;app.js&amp;quot; async&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;!--스크립트가 사용 가능해질 때까지 DOM 생성을 차단하지 않고 이어간다. 이후 페이지 구성이 모두 완료되면 스크립트를 실행한다.--&amp;gt;
&amp;lt;script src=&amp;quot;app.js&amp;quot; defer&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;3-리플로우-리페인트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EB%A6%AC%ED%94%8C%EB%A1%9C%EC%9A%B0-%EB%A6%AC%ED%8E%98%EC%9D%B8%ED%8A%B8&quot; aria-label=&quot;3 리플로우 리페인트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 리플로우, 리페인트&lt;/h3&gt;
&lt;p&gt;최초 랜더링 이후 스크립트로 인해 DOM을 쿼리해서 컨텐츠나 스타일에 수정을 가하면, 랜더 트리를 수정하고 레이아웃과 페인트 단계를 다시 실행한다.
다시 발생하는 레이아웃을 리플로우, 페인트를 리페인트라고 한다.&lt;/p&gt;
&lt;p&gt;리페인트는 기하학적이지 않은 스타일 CSS 프로퍼티가 변경될때 발생한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;background, color, boax-shadow, border-radius, text-decoration 등&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;반면 리플로우는 기하학적인 위치나 공간이 변경되었을때 발생한다. 해당 요소의 자식, 부모 또한 레이아웃을 다시 그려내야 하기 때문이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;윈도우 리사이징, 폰트, 내용 변화, 인라인 스타일 수정 등&lt;/li&gt;
&lt;li&gt;position, width, height, top, right, border, display, float, font-size, weight 등&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;display: none&lt;/code&gt;은 랜더트리를 그려낼때 트리 구성에서 제외되기 때문에 리플로우와 리페인트에 영향을 주지 않는다. 추가적으로
&lt;code class=&quot;language-text&quot;&gt;position: absolute, fixed&lt;/code&gt;로 설정된 요소들은 컨텐츠 맥락을 표현하는 트리에서 별개의 흐름으로 표현되기 때문에 레이아웃에 영향을 주지 않는다.&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://web.dev/articles/critical-rendering-path?hl=ko&quot;&gt;주요 랜더링 경로&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://csstriggers.com/&quot;&gt;리플로우를 발생시키는 CSS 프로퍼티 리스트&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[브라우저 주소창에 URL을 검색하면 일어나는 일들]]></title><description><![CDATA[1. 브라우저는 입력된 URL를 해석한다. 주소창에 검색어를 전달받은 브라우저는 검색어가 URL 형식인지 확인한다. 여기서 URL 형식이란, 스키마, 프로토콜, 도메인, 포트, 경로와 같은 URL…]]></description><link>https://youthfulhps.dev/TIL/network/url-search-process/</link><guid isPermaLink="false">https://youthfulhps.dev/TIL/network/url-search-process/</guid><pubDate>Sat, 21 Oct 2023 13:05:26 GMT</pubDate><content:encoded>&lt;h3 id=&quot;1-브라우저는-입력된-url를-해석한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EB%8A%94-%EC%9E%85%EB%A0%A5%EB%90%9C-url%EB%A5%BC-%ED%95%B4%EC%84%9D%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;1 브라우저는 입력된 url를 해석한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 브라우저는 입력된 URL를 해석한다.&lt;/h3&gt;
&lt;p&gt;주소창에 검색어를 전달받은 브라우저는 검색어가 URL 형식인지 확인한다. 여기서 URL 형식이란, 스키마, 프로토콜, 도메인, 포트, 경로와 같은 URL 구성을 모두
확인한다. 만약, 형식을 지키고 있지 않는다면 일반적인 검색으로 판단하고 검색 엔진으로 전달한다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 11.666666666666666%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAkklEQVQI1yXDyw7BQABA0f5/WPkLSUXETuyIWFnI0FJKTR9qtJ0+dJpKroWTHKttE47BkrkMmQVXJo8INxyjj0OUGJGJATd3xcE3CC/n4GmEr7kvNLFdEE3/Y1vzkR1W35dEymGv3ohnwqkoUeWOT7pBR2vKeEv2ksikIn03qNygCkPmNBROTX3pqD1DdTb01ZcfJY2RTJ9UGa4AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;URL 구조&quot;
        title=&quot;URL 구조&quot;
        src=&quot;/static/a6aa97f27efe03418ab404999ee8b4bc/c1b63/url-structure.png&quot;
        srcset=&quot;/static/a6aa97f27efe03418ab404999ee8b4bc/5a46d/url-structure.png 300w,
/static/a6aa97f27efe03418ab404999ee8b4bc/0a47e/url-structure.png 600w,
/static/a6aa97f27efe03418ab404999ee8b4bc/c1b63/url-structure.png 1200w,
/static/a6aa97f27efe03418ab404999ee8b4bc/d61c2/url-structure.png 1800w,
/static/a6aa97f27efe03418ab404999ee8b4bc/6052f/url-structure.png 2030w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hanseul-lee.github.io/2020/12/24/20-12-24-URL/&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;URL 형식으로 평가된 검색어라면, 실제 HTTP 메세지 포맷에 맞게 GET 요청 메세지를 작성할 준비를 한다. 크롬의 경우 브라우저 프로세스의 UI 스레드 (브라우저
애플리케이션의 최상위 프로세스)가 담당한다.&lt;/p&gt;
&lt;h3 id=&quot;2-브라우저가-http-get-요청-메세지를-작성한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EA%B0%80-http-get-%EC%9A%94%EC%B2%AD-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;2 브라우저가 http get 요청 메세지를 작성한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 브라우저가 HTTP GET 요청 메세지를 작성한다.&lt;/h3&gt;
&lt;p&gt;URL에서 취득한 정보를 바탕으로 자원을 요청하기 위한 HTTP 메세지 (상태 라인, 해더, 바디)를 가지고 있는 GET 요청 메세지를 작성한다.&lt;/p&gt;
&lt;h3 id=&quot;3-dns-요청-전-로컬-호스트파일에-해당-도메인과-대응되는-ip-정보가-있는-지-확인한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-dns-%EC%9A%94%EC%B2%AD-%EC%A0%84-%EB%A1%9C%EC%BB%AC-%ED%98%B8%EC%8A%A4%ED%8A%B8%ED%8C%8C%EC%9D%BC%EC%97%90-%ED%95%B4%EB%8B%B9-%EB%8F%84%EB%A9%94%EC%9D%B8%EA%B3%BC-%EB%8C%80%EC%9D%91%EB%90%98%EB%8A%94-ip-%EC%A0%95%EB%B3%B4%EA%B0%80-%EC%9E%88%EB%8A%94-%EC%A7%80-%ED%99%95%EC%9D%B8%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;3 dns 요청 전 로컬 호스트파일에 해당 도메인과 대응되는 ip 정보가 있는 지 확인한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. DNS 요청 전, 로컬 호스트파일에 해당 도메인과 대응되는 IP 정보가 있는 지 확인한다.&lt;/h3&gt;
&lt;p&gt;로컬 디스크 호스트파일에 해당 도메인과 대응되는 IP 정보가 있다면, 캐싱된 데이터에 접근하여 해당 IP를 사용한다.&lt;/p&gt;
&lt;h3 id=&quot;4-브라우저가-dns-요청을-os에-의뢰하고-실행한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EA%B0%80-dns-%EC%9A%94%EC%B2%AD%EC%9D%84-os%EC%97%90-%EC%9D%98%EB%A2%B0%ED%95%98%EA%B3%A0-%EC%8B%A4%ED%96%89%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;4 브라우저가 dns 요청을 os에 의뢰하고 실행한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 브라우저가 DNS 요청을 OS에 의뢰하고 실행한다.&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 35%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABHklEQVQoz32RSUsDQRCF+///A/HiGgURVPAk7kGzmIlJMBozSXT2PbOYg16erxsHhyg5PBpeVX21tMjzHFVlWfbn7b6H6LyF/8aW68Uq2EeRI5qnOOw7OOjZCJMUiyJfCRXSqCqlPhcFxm6M9aaB5jTAycDBEdWcBVhrGBg5scpJl2qlRAkpjYJdnGiOq1df6Xrs43zk4YIqPSmbOXKD6iAKKFf4YjcZVCJQAjYfTDxZEbb43hB6Nwmw0TYxtGNsdyycvXi/NT8MyRJ9M8KOZql19rs2jrlaXfexS69Fb4/eJSeS0Bq9Nr2aZqvJT4euipd5PSOCmHiJmkh3EzR4L40/Km8k15oyVtcDyKYD6paNZn6iYs+c9JGAe9ZUGd/qtQHNaLDLmQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;DNS 서버 구조&quot;
        title=&quot;DNS 서버 구조&quot;
        src=&quot;/static/55beb7482c8b487a2eb9617df3ecb66c/c1b63/dns-structure.png&quot;
        srcset=&quot;/static/55beb7482c8b487a2eb9617df3ecb66c/5a46d/dns-structure.png 300w,
/static/55beb7482c8b487a2eb9617df3ecb66c/0a47e/dns-structure.png 600w,
/static/55beb7482c8b487a2eb9617df3ecb66c/c1b63/dns-structure.png 1200w,
/static/55beb7482c8b487a2eb9617df3ecb66c/8d68c/dns-structure.png 1234w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cloudflare.com/ko-kr/learning/dns/glossary/dns-root-server/&quot;&gt;이미지 출저&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;DNS(Domain Name System)은 도메인 주소와 IP 주소를 대응시키기 위한 서버이다. 막대한 양의 도메인과 대응되는 IP 주소를 효율적으로 관리하기 위해
도메인을 &lt;code class=&quot;language-text&quot;&gt;.&lt;/code&gt;으로 분리하여 계층화된 도메인 정보를 DNS 서버에 분산시켜 다수의 DNS 서버에 등록한다.
가령, &lt;code class=&quot;language-text&quot;&gt;youthfulhps.dev&lt;/code&gt;를 검색한다면, &lt;code class=&quot;language-text&quot;&gt;dev&lt;/code&gt;를 DNS 서버의 TLD(Top Level Domain)에서 부터 서로 연대하여 검색을 시작한다.&lt;/p&gt;
&lt;p&gt;DNS 요청의 프로토콜은 UDP이고, DNS 서버의 IP 주소는 컴퓨터의 TCP/IP 설정 항목 중 하나라 OS가 이미 알고 있다.
요청한 도메인에 대한 IP를 찾아 응답을 보내주면, 해당 응답을 OS의 DNS 리졸버가 이를 해석하고 IP 주소를 추출하여 메모리에 저장한 후 브라우저에서 접근 가능하도록
허가한다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;브라우저는 직접 네트워크 요청을 할 수 없다. 모두 OS에게 의뢰하여 요청한다.&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;5-브라우저가-os의-프로토콜-스택에-메세지-송신을-의뢰하고-소켓을-작성한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EA%B0%80-os%EC%9D%98-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%8A%A4%ED%83%9D%EC%97%90-%EB%A9%94%EC%84%B8%EC%A7%80-%EC%86%A1%EC%8B%A0%EC%9D%84-%EC%9D%98%EB%A2%B0%ED%95%98%EA%B3%A0-%EC%86%8C%EC%BC%93%EC%9D%84-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;5 브라우저가 os의 프로토콜 스택에 메세지 송신을 의뢰하고 소켓을 작성한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. 브라우저가 OS의 프로토콜 스택에 메세지 송신을 의뢰하고 소켓을 작성한다.&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACSUlEQVQoz1WSO2jTURSHbx5YxFE6SweXBhpQqIOColMGcauiIOggiDi6FFSkVtAlDhnMphCQLGlSEbII2dpiSkLe73ead0LI+1Fvvxs04IXD/efmd373O+dcEYlEbne73Y/E616v97bT6bwZDocfcrncQ7PZfD4ej2/4/f51n89nyOfzBvSGWCy2HgqFVFwkRDAYFMvFwefj42NJwiISiYQMBAIyGo3+IvnqyclJPZ1ORzOZTBbDMnu+VCplisXiaa1We1WpVAS7fmnIbTv1el22Wq1Bo9GYQjhqNpuSxH2LxXIB8S2MrmNygwuvcclmKpXaTCaTd9BcIgTVaLhYoBGCj91sNquIppBIhHO1Y7R3dHRkLBQKMc58JO55vV4RDocFhspk8a2WlHIZAuEu2BLBFHPJLXPKkRj9cLlcq5y94MJnxANyNTabTed0OnUk64xGo9ZqtYr/liJst9uSfQqVrFarc8qWnLkcDsca5Aflcvk3Awv0+33V169A5ICITyYTL9V8Yw4hWhdH+25hqAiZ5pRe/aG8mWoBpgC61hjSAb31Mnk/pt/p9xeM8/Q5OhqNglS0jX6bqnbIv6tKfj8YDCSCMeJTNRiEEqp9u92+CulzevWEeEryS/SXVa9ms5nWZDJp0QsgBKYCWiEo8RPoaiiS9yRpvIRA8i5/ejyeK1RQ4lkFOA9zYZve3oNEgWjcbreAWsNvPQB6KLXi8PBwA+fHPJstaO4TWyQ9wuTm3wmu8N8KdOfUNxPWjsdjgbn4R6fIFnSsM00DRvuyTG+sAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;TCP/IP&quot;
        title=&quot;TCP/IP&quot;
        src=&quot;/static/ece48dfe1b59f7ce172282a3abc78a00/5a190/tcp-ip.png&quot;
        srcset=&quot;/static/ece48dfe1b59f7ce172282a3abc78a00/5a46d/tcp-ip.png 300w,
/static/ece48dfe1b59f7ce172282a3abc78a00/0a47e/tcp-ip.png 600w,
/static/ece48dfe1b59f7ce172282a3abc78a00/5a190/tcp-ip.png 800w&quot;
        sizes=&quot;(max-width: 800px) 100vw, 800px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://commons.wikimedia.org/wiki/File:TCP-IP_Model_-_en.png&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;일반적으로 HTTP 요청은 인터넷 프로토콜 중 TCP(Transmission Control Protocol)를 통해 이루어진다.
TCP/IP의 실제 구현체는 OS단에 존재하기 때문에 마찬가지로 OS에게 조회된 IP 주소의 서버와 연결을 위한 메세지 송신을 의뢰하고 TCP 소캣을 확보한다.&lt;/p&gt;
&lt;h3 id=&quot;6-three-way-handshake를-통해-tcp-프로토콜-연결을-설립한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#6-three-way-handshake%EB%A5%BC-%ED%86%B5%ED%95%B4-tcp-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EC%97%B0%EA%B2%B0%EC%9D%84-%EC%84%A4%EB%A6%BD%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;6 three way handshake를 통해 tcp 프로토콜 연결을 설립한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. Three-Way Handshake를 통해 TCP 프로토콜 연결을 설립한다.&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 660px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 68.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAADh0lEQVQ4y2NggIKYmALG+PhShvT0Kuv4hELP8vLJDE2Nixiwgf///zMUFhYaJiQkCDU0NDCUl5czdLc1MTis+IxQVFu7kDkru5uhrGzy/uKSCU/jIvoZnOKXMTpXLWKQ8S1gkPbOYQgvamW4efc+49OnTxmOHTt2fufOnVFnzpxhOHnyJNOqgxcZLGbchRjGyMjIFBAYyNLbN4Ghf8KkwilTpkwCOoPBtXk9g3TLBQbN/IUMGrnzGFTyl4LVv7p5huHwkaPp27dv1z579izDypWrGEHiZpOvguW1gVgViHm4eUSZQAIKyz5y6HecEDTpPiVo2HKATzm+i105oZtdNWUSu4RbOitIzcF7n0AUV3FeNqO4tBzDVKADgC7kAgmyAzEL1OdM1pa27OFtqzgVchewaWVNY9Wt2sRhNvEyv2n/eT7TCRf5THtO8RhPvSMavPSBkocqD0gvKxCwMHPyMWgXLxdDD282cQlJIZB3QYYrR3ewqUbksCmHZrIatezgNek8wm/SDXT5pCuSPsufi/KxMQgB1WkBsS4QCyvFdYMN5ANiEWA48oBjsISBwWfVHUW3VafF7RY94zOY9Z/XaM5/XsWu/6yKzf9Z9Pu+An0DtHDhIgYtXR1OoBZmYDixsPJwM2nlTAYbKA3EKkCsCAqTurRkptiF1eLxi22Fs5eI8WcslhPIXCInkLZEXSCkWZTTzJ2BxSmPm71oSSQ3Lzc/yAA2AQZ+sPcyN7oIwLzKKCYGNpxdR1+XU3G3G8PcH4UMVnmpjOHTPZnDZ/oyB/XaMBXvc+AtOeAkXLTfTrrjWpAMKwMvyCRNINYHOcy7Wl0EPQzZhflF+Ss3h/IG9WtxRkww5EhdbsGfvMRMIHGBKQjzx88x5Y+aqc9fsTqES1hIGBSGytBUwu2YoyID87I8MAx5QQZqMfgwZy1zUIyZZSAZ0KwjYBImw+VapMYW1K7LZhErz4KcW0RFRQWBTH5GBiaweECrDsgMBnEglgBikG382UVpzAwM1szQpARKc2xImJ1bkJ2dgYmBTUdPi1tBQYELKckxeFZoYGRTDklJSZGmKWUgA5lk1EWZWDmYmJhYGFmYmBlZGZkgaQ5kMR8fn8yNGzdAGYGJBQhAsS2lxccINwmUyUFg6tSpgocPH5YEecna2hqkAK4IGCwMERERjC0tLQwPHz4U27hxIy9InYeHB1wNAIav9kltkyT9AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Three-way handshake TCP 연결 과정&quot;
        title=&quot;Three-way handshake TCP 연결 과정&quot;
        src=&quot;/static/cbd6da531c0c51f5c945fd553baf04c9/1f083/three-way-handshake.png&quot;
        srcset=&quot;/static/cbd6da531c0c51f5c945fd553baf04c9/5a46d/three-way-handshake.png 300w,
/static/cbd6da531c0c51f5c945fd553baf04c9/0a47e/three-way-handshake.png 600w,
/static/cbd6da531c0c51f5c945fd553baf04c9/1f083/three-way-handshake.png 660w&quot;
        sizes=&quot;(max-width: 660px) 100vw, 660px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://commons.wikimedia.org/wiki/File:Full_TLS_1.3_Handshake.svg&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트의 접속 요청 프로세스가 SYN 패킷의 비트를 1로 만들어 연결 메세지를 전송한다.&lt;/li&gt;
&lt;li&gt;TCP 해더를 받은 서버는 포트 번호에 해당하는 소캣을 찾고, 필요한 정보를 기록해서 접속 동작을 진행한다. 서버가 요청을 수락하면
서버 또한 SYN 비트를 1, ACK 비트를 1로 만들어서 클라이언트에게 전송한다.&lt;/li&gt;
&lt;li&gt;서버에서 돌아오는 해더를 받은 클라이언트의 접속 요청 프로세스는 SYN이 1이면 접속 성공으로 해석하고 소켓의 서버 IP 주소나 포트 번호 등과
같은 제어 정보를 기록하고, 서버에게 잘 전달 받았다는 의미로 ACK 비트를 1로 만든 TCP 해더를 다시 전송한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;7-url에-포함된-프로토콜이-https라면-tls-handshake를-진행한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#7-url%EC%97%90-%ED%8F%AC%ED%95%A8%EB%90%9C-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%B4-https%EB%9D%BC%EB%A9%B4-tls-handshake%EB%A5%BC-%EC%A7%84%ED%96%89%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;7 url에 포함된 프로토콜이 https라면 tls handshake를 진행한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7. URL에 포함된 프로토콜이 HTTPS라면 TLS Handshake를 진행한다.&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 57.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB8UlEQVQoz1VSS28TQQzef8rjzIHf0AMScEMcIiEOHHkoFGgFFSIClYaUQks3QWXTNPvemd15eTyzu0lIEROlULC+sUa2P9tjj4d/RGtNS5nmZVoKodHgpRiDlBScVcb8a0bPHdArP6UCVBMRS+2CozWoL5iIWSFOExkUwOG/pJ4Laa05n9VGgqTQ/1b4uS7BXLIROYOzmJ3lUoKrpF2xtctzrDcn5P5e+GBvcmtn/O44ignPmItzYRfiMkkprIZlW8+betHY2qye6bkKEyqOospPSj8XUVE6q1TApSrFGtJpxviXkGyP0p1huDVKAyLa2q4qvw1oZxA92p92BvHBaQYr5l8yOE2EJhXbn7LusHrl590RO45ZRQvP2HkWvhge3D4c3Ds5uhOHfalcj0TJEoFpEA5GcylEW/XPi8dtuvmLPjHlYZJRT5t2Vn2aZ0/nxcuf+TNJRqBr1G4yAhVDRbQkRqWcVzZ8WA2u/ujd4J+vzOiWqZce1ks96UQfro3f38w/XmfT1xo4ysRxUFF3B5Bu68LtgkVQBZqNgY0ZjaMocauqG+E3pAf5blv2OA3cwNDxtXQNI1RG5ValklOMusLfSL/ehe8bWOwyYbzV18IG7dzYmbYLxgTIUq+h1mBacc6FoQObbopwu86e1zIwtv0NVV9QyPM482YAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;TLS-SSL-handshake&quot;
        title=&quot;TLS-SSL-handshake&quot;
        src=&quot;/static/b6c3265b63fd50ce949c3df89a6326d2/c1b63/tls-ssl-handshake.png&quot;
        srcset=&quot;/static/b6c3265b63fd50ce949c3df89a6326d2/5a46d/tls-ssl-handshake.png 300w,
/static/b6c3265b63fd50ce949c3df89a6326d2/0a47e/tls-ssl-handshake.png 600w,
/static/b6c3265b63fd50ce949c3df89a6326d2/c1b63/tls-ssl-handshake.png 1200w,
/static/b6c3265b63fd50ce949c3df89a6326d2/d61c2/tls-ssl-handshake.png 1800w,
/static/b6c3265b63fd50ce949c3df89a6326d2/97a96/tls-ssl-handshake.png 2400w,
/static/b6c3265b63fd50ce949c3df89a6326d2/54ad1/tls-ssl-handshake.png 2918w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.cloudflare.com/ko-kr/learning/ssl/what-happens-in-a-tls-handshake/&quot;&gt;이미지 출저&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;URL의 포함된 프로토콜이 HTTPS이거나, 해당 호스트가 HSTS(HTTPS Strict Transport Security)가 적용된 호스트라면 HTTPS 연결을 위한
TLS 핸드 쉐이크를 진행한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;클라이언트 헬로우 메세지&lt;/strong&gt;, 클라이언트는 서버에게 브라우저가 사용하는 SSL 버전 정보, 사용가능한 암호화 방식, 무작위 바이트로 생성된 ‘클라이언트 무작위’
문자열을 전송한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서버 헬로우 메세지&lt;/strong&gt;, 클라이언트에서 전달받은 헬로 메세지에 대한 응답으로 서버의 SSL 인증서, 사용가능한 암호화 방식 중 서버가 채택한 암호화 방식,
무작위 바이트로 생성된 ‘서버 무작위’ 문자열을 전송한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;인증&lt;/strong&gt;, 클라이언트는 서버로부터 전달받은 SSL 인증서를 복호화한다. 암호화된 SSL 인증서를 복호화하기 위해서는 제 3자(CA)로 부터 전달받은 공개키로만
복호화가 가능하기 때문에 복호화가 잘 되었다면, 신뢰할 수 있는 인증서로 판단한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;암호 전달&lt;/strong&gt;, 클라이언트는 ‘예비 마스터 암호’ 라는 무작위 바이트 문자열을 하나 더 생성하고, 이를 SSL 인증서에 담겨 있는 비밀키로 암호화한 후 서버로 전달한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;개인 키 사용&lt;/strong&gt;, 서버는 전달받은 ‘예비 마스터 암호’를 복호화한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;세션(대칭) 키 생성&lt;/strong&gt;, 클라이언트와 서버는 ‘클라이언트 무작위’, ‘서버 무작위’, ‘예비 마스터 암호’를 통해 상호 통신에 사용할 세션키를 생성한다. 이때
클라이언트와 서버는 동일한 결과가 나와야 한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;클라이언트 준비 완료&lt;/strong&gt;, 클라이언트는 세션 키로 암호화된 ‘완료’ 메세지를 전송한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;서버 준비 완료&lt;/strong&gt;, 서버는 세션 키로 암호화된 ‘완료’ 메세지를 전송한다.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;안전한 대칭 암호화 완료&lt;/strong&gt;, 핸드쉐이크가 종료되고, 세션 키를 통해 통신을 이어간다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;8-클라이언트에서-실제-get-요청-메세지를-전송하고-전달받은-서버는-응답-메세지를-작성한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#8-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%97%90%EC%84%9C-%EC%8B%A4%EC%A0%9C-get-%EC%9A%94%EC%B2%AD-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EC%A0%84%EC%86%A1%ED%95%98%EA%B3%A0-%EC%A0%84%EB%8B%AC%EB%B0%9B%EC%9D%80-%EC%84%9C%EB%B2%84%EB%8A%94-%EC%9D%91%EB%8B%B5-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EC%9E%91%EC%84%B1%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;8 클라이언트에서 실제 get 요청 메세지를 전송하고 전달받은 서버는 응답 메세지를 작성한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;8. 클라이언트에서 실제 GET 요청 메세지를 전송하고 전달받은 서버는 응답 메세지를 작성한다.&lt;/h3&gt;
&lt;p&gt;서버에서 HTTP 요청을 받으면, 요청 URI를 실제 서버의 파일 시스템에서의 URI로 바꿔 해당하는 html 자원을 찾아 바디에 넣은 후
응답 해더와 함께 응답 메세지를 작성하고 반송한다.&lt;/p&gt;
&lt;h3 id=&quot;9-응답-메세지를-받은-클라이언트는-메세지를-해석하고-자원을-랜더링한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#9-%EC%9D%91%EB%8B%B5-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%EB%B0%9B%EC%9D%80-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%8A%94-%EB%A9%94%EC%84%B8%EC%A7%80%EB%A5%BC-%ED%95%B4%EC%84%9D%ED%95%98%EA%B3%A0-%EC%9E%90%EC%9B%90%EC%9D%84-%EB%9E%9C%EB%8D%94%EB%A7%81%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;9 응답 메세지를 받은 클라이언트는 메세지를 해석하고 자원을 랜더링한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;9. 응답 메세지를 받은 클라이언트는 메세지를 해석하고 자원을 랜더링한다.&lt;/h3&gt;
&lt;p&gt;클라이언트는 HTTP 메세지의 content-type 해더를 통해 응답 데이터가 html임을 알아낸다. 이를 바탕으로 브라우저가 화면 표시 동작을 실행한다.
화면 표시는 브라우저 프로세스의 랜더러 스레드가 담당한다.&lt;/p&gt;
&lt;p&gt;브라우저는 HTML을 파싱해서 Critical Rendering Path를 거쳐 해석된 HTML을 화면에 띄우고, 파싱하다가 script 혹은 link 태그를 만나면
랜더링을 중단, JS, CSS 자원 역시 위와 같은 과정을 거쳐 서버에 요청, 응답 받아 자원을 사용하며, 이후 이어 랜더링을 완료한다.&lt;/p&gt;
&lt;h3 id=&quot;10-요청이-종료되었다면-4-way-handshake를-통해-접속을-끊고-소캣을-말소한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#10-%EC%9A%94%EC%B2%AD%EC%9D%B4-%EC%A2%85%EB%A3%8C%EB%90%98%EC%97%88%EB%8B%A4%EB%A9%B4-4-way-handshake%EB%A5%BC-%ED%86%B5%ED%95%B4-%EC%A0%91%EC%86%8D%EC%9D%84-%EB%81%8A%EA%B3%A0-%EC%86%8C%EC%BA%A3%EC%9D%84-%EB%A7%90%EC%86%8C%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;10 요청이 종료되었다면 4 way handshake를 통해 접속을 끊고 소캣을 말소한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;10. 요청이 종료되었다면, 4-Way-Handshake를 통해 접속을 끊고 소캣을 말소한다.&lt;/h3&gt;
&lt;p&gt;데이터 송수신 과정이 종료되었다면, TCP 접속을 종료하기 위해 4-Way-handshake를 진행한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;클라이언트는 연결을 종료하겠다는 의미로 TCP 해더의 FIN 비트에 1을 설정해 서버로 전달한다. 이때 FIN-WAIT 상태가 된다.&lt;/li&gt;
&lt;li&gt;서버는 종료의 요청을 받고, 확인의 의미로 TCP 해더의 ACK 비트를 전송한다. 이때 CLOSE_WAIT 상태가 된다.&lt;/li&gt;
&lt;li&gt;클라이언트는 해지 준비가 완료되었다는 것을 알리기 위해 ACK 비트를 서버에 전송한다. 이때 클라이언트는 TIME_WAIT 상태가 된다.&lt;/li&gt;
&lt;li&gt;클라이언트는 서버에서 전송할 응답 데이터가 남아있을 수 있는 여지를 염두하고 일정 시간 기다린 후, 세션을 종료하고 연결이 종료된 CLOSE 상태가 된다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HTTP1.1 부터 도입된 keep-alive로 인해 요청이 종료되어도 바로 연결이 끊기지 않는 것이 일반적이고, keep-alive timeout에 설정된 시간이 흐른뒤
연결이 종료된다.&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://maxkim-j.github.io/posts/packet-travel&quot;&gt;브라우저 주소창에 URL을 치면 일어나는 일들&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[이벤트 루프]]></title><description><![CDATA[브라우저는 단일 스레드에서 이벤트 드리븐(event-driven…]]></description><link>https://youthfulhps.dev/TIL/javascript/event-loop/</link><guid isPermaLink="false">https://youthfulhps.dev/TIL/javascript/event-loop/</guid><pubDate>Fri, 06 Oct 2023 13:10:26 GMT</pubDate><content:encoded>&lt;p&gt;브라우저는 단일 스레드에서 이벤트 드리븐(event-driven) 방식으로 동작한다. 단일 스레드는 한번에 하나의 작업만을 처리할 수 있지만, 웹은 마치 여러 작업을
동시에 처리하는 것처럼 보인다. 이처럼 &lt;strong&gt;자바스크립트의 동시성을 구현하는 방식이 이벤트 루프이다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트 엔진은 단순히 작업이 요청되면 콜스택을 사용하여 요청된 작업을 순서대로 실행하는 역할을 한다. 동시성을 지원하기 위해 필요한 비동기 요청이나 이벤트
처리는 자바스크립트 엔진을 구동하는 환경인 브라우저나 node.js가 담당한다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACBklEQVQoz41TDYubQBDN//8ZhbbQQn9AoaFfl3K9JHd+JmrUJEYv5mJidFeNX6+zWyKFQunAsDC7vpn33jjCP6LrOvxv1HWNqqowatsWm80GjuNgt9shDEMEwRacc/kwTVPMZ3O4rocoimAYJt0HKIoCx+MRSZIgyzKs12tYloURYwy6rstcLC18n/zAw3QmwUXHOD5AUZ7guQ40TYFpavB9T9Zt25bDiKaigQgJKKKsO5xZhZSV8nTXAdqmppse/p7jm/KCjxMXXx5jKKsT8jxDWZaSyfV6Rd/3Mkei0HctAVXUpUTXNrKb5QVgVYO06KH5Dj58fof3n0S+xUSfyiEaauh5npTppvdvwJ6myzh00sc0DaiaDtP2IPTNrkDkLnD4+hr++A3C8SuExj2qpkd6PkkdRYq3ErAknTRVxc+5QhraMHQNT4qK5cofHAxfMpgeaWmH8LbPWG33OJNuTdMQ7Wp4N1AuieLLKZMTGmSOomrQlw6yS4oT78hdF/tgilWU4Hgp4JOjN+1vpwAbKIu4cJpUuK2p5KaOu/sZFkQ/OnGMZx7u5kvYwQHWJkZCFIWzdd0M7g6AokNDS5mkDA+PGqWgr0nADa1HdC5IAhtLP4YTJlgFsdzH5/1e7t9fgMJyASomvWS5zPSSyQlEjfECOX3IOUPOOK0Lk0Ai8zyXf8ifgL8AlPg5cPivrxYAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;이벤트 루프의 구조&quot;
        title=&quot;이벤트 루프의 구조&quot;
        src=&quot;/static/5b53bc0eeec60e99fef5f60234ca4bdd/c1b63/event-loop.png&quot;
        srcset=&quot;/static/5b53bc0eeec60e99fef5f60234ca4bdd/5a46d/event-loop.png 300w,
/static/5b53bc0eeec60e99fef5f60234ca4bdd/0a47e/event-loop.png 600w,
/static/5b53bc0eeec60e99fef5f60234ca4bdd/c1b63/event-loop.png 1200w,
/static/5b53bc0eeec60e99fef5f60234ca4bdd/d61c2/event-loop.png 1800w,
/static/5b53bc0eeec60e99fef5f60234ca4bdd/97a96/event-loop.png 2400w,
/static/5b53bc0eeec60e99fef5f60234ca4bdd/763a5/event-loop.png 2804w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;자바스크립트-엔진-영역&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84-%EC%98%81%EC%97%AD&quot; aria-label=&quot;자바스크립트 엔진 영역 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;자바스크립트 엔진 영역&lt;/h2&gt;
&lt;h3 id=&quot;call-stack&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#call-stack&quot; aria-label=&quot;call stack permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Call Stack&lt;/h3&gt;
&lt;p&gt;작업이 요청되면 순차적으로 콜스택에 쌓이게 되고 순서에 따라 처리된다. 자바스크립트는 하나의 콜스택을 사용하기 때문에 해당 작업이 종료되기 전까지 다른 작업을
진행할 수 없다.&lt;/p&gt;
&lt;h3 id=&quot;heap&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#heap&quot; aria-label=&quot;heap permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Heap&lt;/h3&gt;
&lt;p&gt;동적으로 생성된 객체 인스턴스가 할당되는 영역이다.&lt;/p&gt;
&lt;h2 id=&quot;자바스크립트-엔진을-구동하는-환경-browser-node-영역&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EC%97%94%EC%A7%84%EC%9D%84-%EA%B5%AC%EB%8F%99%ED%95%98%EB%8A%94-%ED%99%98%EA%B2%BD-browser-node-%EC%98%81%EC%97%AD&quot; aria-label=&quot;자바스크립트 엔진을 구동하는 환경 browser node 영역 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;자바스크립트 엔진을 구동하는 환경 (Browser, node) 영역&lt;/h2&gt;
&lt;h3 id=&quot;event-loop&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#event-loop&quot; aria-label=&quot;event loop permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Event Loop&lt;/h3&gt;
&lt;p&gt;콜 스택 내에서 현재 실행 중인 작업이 있는지 작업 큐에 작업이 있는지 반복하여 확인하고, 만약 콜 스택이비어 있다면 작업 큐의 작업을 꺼내 콜 스택으로 전달한다.&lt;/p&gt;
&lt;h3 id=&quot;web-api&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#web-api&quot; aria-label=&quot;web api permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Web API&lt;/h3&gt;
&lt;p&gt;Timer 함수, 네트워크 요청, 파일 입출력, 이벤트 처리 등 브라우저에서 제공하는 다양한 API를 포괄한다. Web API는 브라우저에서 처리된다.
브라우저는 멀티 스레드를 제공하기 때문에 비동기 작업을 처리하는 동안 메인 스레드를 차단하지 않고 다른 스레드를 사용하여 작업을 처리한다. 이렇게 처리된 작업들의
콜백이 텍스크 큐에 담겨 관리된다.&lt;/p&gt;
&lt;h3 id=&quot;task-queue&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#task-queue&quot; aria-label=&quot;task queue permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Task Queue&lt;/h3&gt;
&lt;p&gt;비동기 처리 함수의 콜백 함수나 비동기식 이벤트 핸들러, Timer 함수 (setTimeout, setInterval)의 콜백 함수가 보관되는 영역이다. &lt;strong&gt;이벤트 루프에 의해
콜 스택이 비어있는 시점에 순차적으로 콜 스택으로 작업이 이관되어 실행된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;여기서 비동기 작업들도 모두 우선순위를 가지고 있고, 이를 구분하기 위해 세 가지 큐로 구성되어 있다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Micro Task Queue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;현재 실행되고 있는 작업 이후 바로 처리되어야 하는 우선 순위가 높은 비동기 작업을 가지고 있다. Promise, Observer API, node의 process.nextTick 등
일반적인 우선 순위의 작업들보다 우선적으로 실행되고, 마이크로 텍스크 큐의 작업들이 모두 처리되어야만 매크로 텍스크 큐의 작업이 실행된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Macro Task Queue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;기본적인 작업들의 작업 큐이다. 해당 큐의 단일 작업을 처리하고 난 직후 다른 작업들을 진행하기 전에 마이크로 텍스크 큐의 작업들을 모두 처리한 후 돌아와 다음 작업을
처리한다. 스크립트를 실행하거나, DOM 이벤트, Timer 함수가 이곳에서 관리된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Animation Frame Queue&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트 애니메이션 동작을 제어하는 requestAnimationFrame 메서드를 통해 등록된 콜백이 해당 큐에서 관리되고,
브라우저가 리페인트를 진행하기 직전에 본 큐에 있는 작업들을 순차적으로 처리한다. 해당 작업들 또한 마이크로 텍스크 큐가 비어있을 때만 처리된다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[실행 컨텍스트]]></title><description><![CDATA[모든 실행 가능한 코드(전역, 함수, eval…]]></description><link>https://youthfulhps.dev/TIL/javascript/execution-context/</link><guid isPermaLink="false">https://youthfulhps.dev/TIL/javascript/execution-context/</guid><pubDate>Wed, 04 Oct 2023 01:05:26 GMT</pubDate><content:encoded>&lt;p&gt;모든 실행 가능한 코드(전역, 함수, eval, 모듈)는 코드 실행 이전에 평가 단계를 거치는데, 이는 실행 가능한 코드가
실행되기 위한 환경을 생성하기 위함이다. 평가 과정을 거쳐 생성된 실행 환경을 물리적인 객체로 관리하며 이를 실행 컨텍스트라 한다.
해당 코드의 식별자(변수, 함수, 클래스 등의 이름)을 등록하고 관리하는 스코프를 &lt;strong&gt;렉시컬 환경&lt;/strong&gt;에서 관리하며,
이러한 실행 컨텍스트는 코드 실행 순서를 보장받기 위해 &lt;strong&gt;실행 컨텍스트 스택&lt;/strong&gt;으로 관리된다.&lt;/p&gt;
&lt;h3 id=&quot;실행-컨텍스트-스택&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%8A%A4%ED%83%9D&quot; aria-label=&quot;실행 컨텍스트 스택 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;실행 컨텍스트 스택&lt;/h3&gt;
&lt;p&gt;실행 컨텍스트는 스택 자료 구조로 관리된다. 코드 실행과 흐름에 따라 새롭게 생성되어 추가되거나, 제거되는데 이를 통해
코드 실행 순서를 보장한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 1. 2. 3.
const x = 1;

function foo() {
  // 6.
  const y = 2;
  function bar() {
    // 9.
    const z = 3;
    // 10.
    console.log(x + y + z);
    // 11.
  }
  // 7. 8.
  bar();
  // 12.
}

// 4. 5.
foo();
// 13.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4 id=&quot;1-전역-실행-컨텍스트가-생성-및-스택에-추가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%A0%84%EC%97%AD-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8%EA%B0%80-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%8A%A4%ED%83%9D%EC%97%90-%EC%B6%94%EA%B0%80&quot; aria-label=&quot;1 전역 실행 컨텍스트가 생성 및 스택에 추가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 전역 실행 컨텍스트가 생성 및 스택에 추가&lt;/h4&gt;
&lt;p&gt;자바스크립트 엔진의 코드 실행권이 전역 코드에 진입하기 전 전역 실행 컨텍스트가 생성된다.&lt;/p&gt;
&lt;h4 id=&quot;2-전역-식별자-등록&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%A0%84%EC%97%AD-%EC%8B%9D%EB%B3%84%EC%9E%90-%EB%93%B1%EB%A1%9D&quot; aria-label=&quot;2 전역 식별자 등록 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 전역 식별자 등록&lt;/h4&gt;
&lt;p&gt;이후 전역 변수 x와 전역 함수 foo가 전역 실행 컨텍스트에 등록된다.&lt;/p&gt;
&lt;h4 id=&quot;3-전역-코드-실행&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EC%A0%84%EC%97%AD-%EC%BD%94%EB%93%9C-%EC%8B%A4%ED%96%89&quot; aria-label=&quot;3 전역 코드 실행 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 전역 코드 실행&lt;/h4&gt;
&lt;p&gt;전역 실행 컨텍스트가 생성되고, 전역 코드가 실행되어 전역 변수 x와 foo 함수가 호출된다.&lt;/p&gt;
&lt;h4 id=&quot;4-foo-호출&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-foo-%ED%98%B8%EC%B6%9C&quot; aria-label=&quot;4 foo 호출 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. foo 호출&lt;/h4&gt;
&lt;p&gt;foo 함수가 호출되면, foo 함수를 실행하기 위한 실행 컨텍스트가 생성되어야 한다. 따라서 전역 코드의 실행이 중단되고,
foo 함수 내부로 코드 제어권이 넘어간다.&lt;/p&gt;
&lt;h4 id=&quot;5-foo-함수-실행-컨텍스트-생성-및-스택-추가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-foo-%ED%95%A8%EC%88%98-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%8A%A4%ED%83%9D-%EC%B6%94%EA%B0%80&quot; aria-label=&quot;5 foo 함수 실행 컨텍스트 생성 및 스택 추가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. foo 함수 실행 컨텍스트 생성 및 스택 추가&lt;/h4&gt;
&lt;p&gt;foo 함수가 실행되기 위한 실행 컨텍스트를 생성하고, 실행 컨텍스트 스택에 푸시한다.&lt;/p&gt;
&lt;h4 id=&quot;6-foo-함수의-식별자-등록&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#6-foo-%ED%95%A8%EC%88%98%EC%9D%98-%EC%8B%9D%EB%B3%84%EC%9E%90-%EB%93%B1%EB%A1%9D&quot; aria-label=&quot;6 foo 함수의 식별자 등록 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. foo 함수의 식별자 등록&lt;/h4&gt;
&lt;p&gt;foo 함수 실행 컨텍스트에 지역 변수 y와 중첩 함수 bar가 등록된다.&lt;/p&gt;
&lt;h4 id=&quot;7-bar-호출&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#7-bar-%ED%98%B8%EC%B6%9C&quot; aria-label=&quot;7 bar 호출 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7. bar 호출&lt;/h4&gt;
&lt;p&gt;foo 내부에서 bar 함수가 호출되면, bar 함수를 실행하기 위한 실행 컨텍스트가 생성되어야 한다. 따라서 foo 함수 코드의 실행이
중단되고, bar 함수 내부로 코드 제어권이 넘어간다.&lt;/p&gt;
&lt;h4 id=&quot;8-bar-함수-실행-컨텍스트-생성-및-스택-추가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#8-bar-%ED%95%A8%EC%88%98-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%83%9D%EC%84%B1-%EB%B0%8F-%EC%8A%A4%ED%83%9D-%EC%B6%94%EA%B0%80&quot; aria-label=&quot;8 bar 함수 실행 컨텍스트 생성 및 스택 추가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;8. bar 함수 실행 컨텍스트 생성 및 스택 추가&lt;/h4&gt;
&lt;p&gt;bar 함수가 실행되기 위한 실행 컨텍스트가 생성되고, 실행 컨텍스트 스택에 푸시한다.&lt;/p&gt;
&lt;h4 id=&quot;9-bar-함수의-식별자-등록&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#9-bar-%ED%95%A8%EC%88%98%EC%9D%98-%EC%8B%9D%EB%B3%84%EC%9E%90-%EB%93%B1%EB%A1%9D&quot; aria-label=&quot;9 bar 함수의 식별자 등록 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;9. bar 함수의 식별자 등록&lt;/h4&gt;
&lt;p&gt;bar 함수 실행 컨텍스트에 지역 변수 z가 등록된다.&lt;/p&gt;
&lt;h4 id=&quot;10-consolelog-메서드-호출-후-bar-함수-종료&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#10-consolelog-%EB%A9%94%EC%84%9C%EB%93%9C-%ED%98%B8%EC%B6%9C-%ED%9B%84-bar-%ED%95%A8%EC%88%98-%EC%A2%85%EB%A3%8C&quot; aria-label=&quot;10 consolelog 메서드 호출 후 bar 함수 종료 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;10. console.log 메서드 호출 후 bar() 함수 종료&lt;/h4&gt;
&lt;p&gt;bar 함수에 의해 console.log 메서드가 호출되고 bar 함수의 코드 실행이 종료된다.&lt;/p&gt;
&lt;h4 id=&quot;11-foo-함수-코드로-복귀-bar-함수-실행-컨텍스트-제거&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#11-foo-%ED%95%A8%EC%88%98-%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%B3%B5%EA%B7%80-bar-%ED%95%A8%EC%88%98-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%A0%9C%EA%B1%B0&quot; aria-label=&quot;11 foo 함수 코드로 복귀 bar 함수 실행 컨텍스트 제거 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;11. foo 함수 코드로 복귀 bar 함수 실행 컨텍스트 제거&lt;/h4&gt;
&lt;p&gt;bar 함수의 코드 실행이 종료됨에 따라 foo 함수로 다시 코드 제어권이 복귀되고, bar 함수 실행 컨텍스트는 실행 컨텍스트 스택에서
pop되어 제거된다.&lt;/p&gt;
&lt;h4 id=&quot;12-전역-실행-코드로-복귀-및-foo-함수-실행-컨텍스트-제거&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#12-%EC%A0%84%EC%97%AD-%EC%8B%A4%ED%96%89-%EC%BD%94%EB%93%9C%EB%A1%9C-%EB%B3%B5%EA%B7%80-%EB%B0%8F-foo-%ED%95%A8%EC%88%98-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%A0%9C%EA%B1%B0&quot; aria-label=&quot;12 전역 실행 코드로 복귀 및 foo 함수 실행 컨텍스트 제거 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;12. 전역 실행 코드로 복귀 및 foo 함수 실행 컨텍스트 제거&lt;/h4&gt;
&lt;p&gt;foo 함수의 코드 실행이 종료됨에 따라 전역 실행 코드로 코드 제어권이 복귀되고, foo 함수 실행 컨텍스트는 실행 컨텍스트 스택에서
pop되어 제거된다.&lt;/p&gt;
&lt;h4 id=&quot;13-전역-실행-코드의-종료와-전역-실행-컨텍스트-제거&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#13-%EC%A0%84%EC%97%AD-%EC%8B%A4%ED%96%89-%EC%BD%94%EB%93%9C%EC%9D%98-%EC%A2%85%EB%A3%8C%EC%99%80-%EC%A0%84%EC%97%AD-%EC%8B%A4%ED%96%89-%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8-%EC%A0%9C%EA%B1%B0&quot; aria-label=&quot;13 전역 실행 코드의 종료와 전역 실행 컨텍스트 제거 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;13. 전역 실행 코드의 종료와 전역 실행 컨텍스트 제거&lt;/h4&gt;
&lt;p&gt;전역 코드 또한 더이상 전개할 이후 작업이 없으므로 전역 실행 컨텍스트 또한 pop되어 제거된다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 36%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2UlEQVQoz52SNwrEQAxFdf8bOuDCORvniLU8wRRbbLMCoaz/Nbbs+67jOOo0TabneSryvq/+I9L3vfq+r1EUmbL0OA7dts3sdV06z7Muy2I5Ykig+BAg72oCExyE4n3fNoxd19XYB0FgYHmefy2ijxh5nseWCo47E0tDWZYK87ZtjV2WZVpVldZ1bQBN0+gwDNbjZhEuEtAYoIlFsPI8zxglSWJPEIahxUVRGIhjjM9S5gAETDgtjmNN09ROAoUYEBgBwGLqXdfZkOsFjJybJ5Z/viTv/usv+AAgbBrGPD7mHQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;실행 컨텍스트 스택 전개&quot;
        title=&quot;실행 컨텍스트 스택 전개&quot;
        src=&quot;/static/88f117e2768adef6566670340a53ffd8/c1b63/execution-context-stack.png&quot;
        srcset=&quot;/static/88f117e2768adef6566670340a53ffd8/5a46d/execution-context-stack.png 300w,
/static/88f117e2768adef6566670340a53ffd8/0a47e/execution-context-stack.png 600w,
/static/88f117e2768adef6566670340a53ffd8/c1b63/execution-context-stack.png 1200w,
/static/88f117e2768adef6566670340a53ffd8/2e06c/execution-context-stack.png 1637w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;위와 같이 실행 컨텍스트를 관리하여 코드 순서를 보장받는다. 정리하자면,&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;실행 가능한 코드(전역, 함수, eval, 모듈)가 실행되기 전에&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;해당 코드의 실행 컨텍스트 생성&lt;/li&gt;
&lt;li&gt;식별자 등록&lt;/li&gt;
&lt;li&gt;실행 컨텍스트 스택에 추가&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;이후 코드 실행이 종료되면,&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;실행 컨텍스트 스택의 최상위 실행 컨텍스트(항상 현재 실행되고 있는 코드의 실행 컨텍스트)를 제거&lt;/li&gt;
&lt;li&gt;이전 실행 코드로 코드 제어권 복귀&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;렉시컬-환경&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A0%89%EC%8B%9C%EC%BB%AC-%ED%99%98%EA%B2%BD&quot; aria-label=&quot;렉시컬 환경 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;렉시컬 환경&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;렉시컬 환경(Lexical Environment)는 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록&lt;/strong&gt;하는
자료구조로 실행 컨텍스트를 구성하는 컴포넌트이다.&lt;/p&gt;
&lt;p&gt;실행 가능한 코드(전역, 함수, eval, 모듈)을 평가하여 키와 값을 가지는 객체 형태의 스코프를 생성하고, 해당 코드를
실행하기 위해 필요한 식별자를 키로 등록하고 식별자에 바인딩된 값을 관리한다. 즉 각각의 코드의 스코프를 구분하여
식별자를 등록하고 관리하는 저장소 역할이며 렉시컬 스코프의 실체이다.&lt;/p&gt;
&lt;p&gt;실행 컨텍스트는 &lt;code class=&quot;language-text&quot;&gt;LexicalEnvironment&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;VariableEnvironment&lt;/code&gt; 컴포넌트로 구성된다.
이 둘은 최초 실행 시 동일한 &lt;code class=&quot;language-text&quot;&gt;LexicalEnvironment&lt;/code&gt;를 참조한다. 다만, &lt;strong&gt;코드의 전개에 따라 변경되는 최신 상태를
&lt;code class=&quot;language-text&quot;&gt;LexicalEnvironment&lt;/code&gt;에 저장하고, &lt;code class=&quot;language-text&quot;&gt;VariableEnvironment&lt;/code&gt;는 초기 상태의 렉시컬 환경을 기억한다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;LexicalEnvironment&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;EnvironmentRecord&lt;/code&gt;와 &lt;code class=&quot;language-text&quot;&gt;OuterLexicalEnvironmentReference&lt;/code&gt;로 구성된다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 43.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABI0lEQVQoz61Sx66DQAzk//+KSy5EFJFARBFNhN6FaAp+GkfL9b3DW2nkLeOxx1qJflnneTL+ssCTqqoi0zTJsix6vV7k+z6fbdumaZoucpZlpKoqRVHEXHB0XWcYhkFt2zKPBW+3G93vd04AUVEUxjzPl2Bd1/zueR4DBR+PB2maRs/nk8Zx/ApiAyChaRruBPuu66jvezqOg7HvO9+XZcmcPM8JzeAM7mUZB7T7fr+pKAq2lKYpE0WEABzIssx3GI3jOBTHMQMNiTlLwzAwCTYQXdelIAguIRQT3UIU9+ItDEOOmKGYt4QEWAWQCBu4E1Gsbdu4GKzCDZAkCQtinsuyfAXXdWUhdIouEAEU+Hw+12ywF28CsIpc0R3P8L/+oeD8AHOBqHS7R5c2AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;실행 컨텍스트와 렉시컬 환경의 초기 참조 구조&quot;
        title=&quot;실행 컨텍스트와 렉시컬 환경의 초기 참조 구조&quot;
        src=&quot;/static/3038f03aff5c726ebeee5a3a9cf1bdb7/c1b63/init.png&quot;
        srcset=&quot;/static/3038f03aff5c726ebeee5a3a9cf1bdb7/5a46d/init.png 300w,
/static/3038f03aff5c726ebeee5a3a9cf1bdb7/0a47e/init.png 600w,
/static/3038f03aff5c726ebeee5a3a9cf1bdb7/c1b63/init.png 1200w,
/static/3038f03aff5c726ebeee5a3a9cf1bdb7/d61c2/init.png 1800w,
/static/3038f03aff5c726ebeee5a3a9cf1bdb7/e8f1b/init.png 2246w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;EnvironmentRecord&lt;/code&gt;는 &lt;strong&gt;스코프에 포함된 식별자를 등록하고 등록된 식별자에 바인딩된 값을 관리하는 저장소다.&lt;/strong&gt;
소스 코드 타입에 따라 관리하는 내용에 차이가 있다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;OuterLexicalEnvironmentReference&lt;/code&gt;는 상위 스코프를 가리킨다. 이때 &lt;strong&gt;상위 스코프는 외부 렉시컬 환경, 즉 해당 실행 컨텍스트를
생성한 소스코드를 포함하는 상위 코드의 렉시컬 환경을 뜻한다. 외부 렉시컬 환경에 대한 참조를 통해 단방향 링크드 리스트인 스코프 체인을
구현한다.&lt;/strong&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 1. 2. 3.
var x = 1;
const y = 2;

function foo(a) {
  var x = 3;
  const y = 4;

  function bar(b) {
    const z = 5;
    console.log(a + b + x + y + z);
  }

  bar(10);
}

foo(20);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h4 id=&quot;1-전역-코드가-평가되기-전-전역-객체-생성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%A0%84%EC%97%AD-%EC%BD%94%EB%93%9C%EA%B0%80-%ED%8F%89%EA%B0%80%EB%90%98%EA%B8%B0-%EC%A0%84-%EC%A0%84%EC%97%AD-%EA%B0%9D%EC%B2%B4-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;1 전역 코드가 평가되기 전 전역 객체 생성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. (전역 코드가 평가되기 전) 전역 객체 생성&lt;/h4&gt;
&lt;p&gt;전역 객체에는 빌트인 전역 프로퍼티, 함수, 표준 빌트인 객체가 추가된다. 또한 동작 환경에 따라 클라이언트 사이드의 경우 Web API나,
특정 환경을 참조하기 위한 호스트 객체가 포함된다.&lt;/p&gt;
&lt;h4 id=&quot;2-전역-코드-평가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%A0%84%EC%97%AD-%EC%BD%94%EB%93%9C-%ED%8F%89%EA%B0%80&quot; aria-label=&quot;2 전역 코드 평가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 전역 코드 평가&lt;/h4&gt;
&lt;p&gt;전역 객체가 생성되고 난 후, 전역 코드가 평가된다. 코드가 평가되는 플로우는 복잡해서 그림으로 그려봤는데 더 복잡하다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 40.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABHklEQVQoz41R2YqDQBD0/38oSF6ij74kikRJAsYj8cSYQ7ytpRqEzRLCNgwzzlTX0SrzPOPbYt1uN4RhiOfziTzP8Xg85P4TXsE/qus6WXEcY7VawbKsj4QsZRgGUaULOqB6XdeYpgl8G8dRzqwkSaDrOs7ns2D/FnFCWJYlrtcrHMfB4XCA67qy73Y72LYtOyOTkOJt2wrBfr+HqqrQNA3b7Ra+779HTtNU1IuikCZGJBEF7/e7iPI7iiK5I+50OokBYpumgfJ7BlmWSQMjc2Y8e54njUxCQboKgkAWHTH66/USvMxwGSYdmKYpUenyeDzicrkIGZs4HzaSiMKMTlxVVej7XgTfCJefsDzQ2Xq9xmazgWEYMksSfity/QB572Bf+6R6lgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;전역 코드가 평가될 때 일어나는 일들&quot;
        title=&quot;전역 코드가 평가될 때 일어나는 일들&quot;
        src=&quot;/static/7d0652f605b5ed039076617d0d725e6a/c1b63/execution-context-flow.png&quot;
        srcset=&quot;/static/7d0652f605b5ed039076617d0d725e6a/5a46d/execution-context-flow.png 300w,
/static/7d0652f605b5ed039076617d0d725e6a/0a47e/execution-context-flow.png 600w,
/static/7d0652f605b5ed039076617d0d725e6a/c1b63/execution-context-flow.png 1200w,
/static/7d0652f605b5ed039076617d0d725e6a/d61c2/execution-context-flow.png 1800w,
/static/7d0652f605b5ed039076617d0d725e6a/10b63/execution-context-flow.png 1897w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.1) 전역 실행 컨텍스트가 생성되고 실행 컨텍스트 스택에 추가된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.2) 글로벌 렉시컬 환경이 생성되고, 전역 실행 컨텍스트의 LexicalEnvironment에 바인딩된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.3) 글로벌 렉시컬 환경을 구성하는 글로벌 환경 레코드가 생성된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;글로벌 렉시컬 환경을 구성하는 글로벌 환경 레코드는 전역 변수를 관리하는 스코프, 전역 객체의 빌트인 전역 프로퍼티,
함수, 표준 빌트인 객체를 제공한다.&lt;/p&gt;
&lt;p&gt;여기서, 글로벌 환경 레코드는 객체 환경 레코드와 선언적 환경 레코드로 구성되어 있다. 이는 var 키워드로 선언된 전역 변수와
ES6에 추가된 let, const 키워드로 선언된 전역 변수를 구분짓기 위함이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.4.1) 글로벌 환경 레코드를 구성하는 객체 환경 레코드가 생성된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;객체 환경 레코드는 BindingObject라고 불리는 객체와 연결되고 등록되어, var로 선언한 전역 변수와 함수 선언문으로 정의된
전역 함수가 전역 객체의 프로퍼티와 메서드가 된다. (그래서 var로 선언된 변수나 함수 선언문으로 선언된 함수의 경우 전역 객체 식별자없이
참조가 가능해진다. (window.a -&gt; a));&lt;/p&gt;
&lt;p&gt;객체 환경 레코드에 추가된 var 키워드로 선언한 변수는 선언 단계와 초기화 단계가 함께 이루어진다. 초기화 단계에서 undefined로 초기화되어
호이스팅이 일어난다. 그러나 함수 선언문으로 정의한 함수가 평가되어 bindingObject를 통해 전역 객체의 메서드로서 등록될 때 함수 객체를
즉시 할당한다. 이러한 동작은 함수 선언문 이전에 함수를 호출하여도 문제없이 호출되도록 한다. &lt;strong&gt;이것이 변수 호이스팅과 함수 호이스팅의 차이점이다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.4.2) 글로벌 환경 레코드를 구성하는 선언적 환경 레코드가 생성된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;let, const로 선언된 전역 변수는 선언적 환경 레코드에 등록되고 관리된다. 이는 bindingObject에 의해 전역 객체의 키로 등록하지
않기 때문에 가령 window.a 와 같이 참조할 수 없다.&lt;/p&gt;
&lt;p&gt;추가적으로 let, const는 선언 단계와 초기화 단계가 분리되어 진행된다.
즉, 선언적 환경 레코드에 등록될 때 선언 단계가 이루어지지만, 초기화 단계가 이루어지지 않아 변수 선언문을 만나기 전까지 일시적 사각지대에
빠지게 된다. (let, const 또한 호이스팅되지만, 일시적 사각지대로 인해 호이스팅되지 않은 것처럼 동작한다.)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.5) 글로벌 환경 레코드의 [[GlobalThisValue]] 내부 슬롯에 this가 바인딩된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;일반적으로 전역 환경 레코드의 this의 경우 전역 객체가 바인딩된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.6) 외부 렉시컬에 대한 참조(Outer Lexical Environment Record)가 구현된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;현재 실행 중인 코드를 포함하는 외부 코드의 렉시컬 환경을 가리키며 이는 스코프 체인의 종점인 전역 스코프를 가지는 전역 렉시컬 환경까지
단방향 링크드 리스트 구조로 구현한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 전역 코드 실행&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;전역 코드가 실행되고 전역 변수(아래 코드 상에서 x, y)의 값이 할당되고, foo 함수가 호출된다.&lt;/p&gt;
&lt;p&gt;여기서 x, y의 할당이나 foo 함수를 호출하기 위해서 먼저 해당 변수나 함수의 식별자가 등록되어 있는지 확인해야 한다. 또한 여러 스코프가 동일한
식별자를 사용하고 있을 수 있다. 따라서, 어느 스코프의 식별자를 참조하면 좋을지 결정하는 단계를 거치는데 이를 식별자 결정이라 한다.&lt;/p&gt;
&lt;p&gt;식별자 결정은 해당 렉시컬 환경의 환경 레코드에서 가장 먼저 검색한다. 만약 검색되지 않았다면, OuterLexicalEnvironmentRecord
가 가리키는 상위 스코프의 렉시컬 환경의 환경 레코드에서 검색을 이어간다. 이러한 동작이 스코프 체인의 검색 메커니즘이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. foo 함수 코드 평가&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;foo 함수가 호출되면 foo 함수 내부로 코드의 제어권이 넘어가 foo 함수 코드 평가가 이루어진다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.1) foo 함수 실행 컨텍스트 생성&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;가장 먼저 함수 실행 컨텍스트가 생성된다. 전역 실행 컨텍스트와는 달리 함수 실행 컨텍스트는 함수의 렉시컬 환경이 생성된 후에 실행 컨텍스트
스택에 푸시된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.2) foo 함수 렉시컬 환경 생성&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;foo 함수의 렉시컬 환경이 생성되고, foo 함수의 실행 컨텍스트의 렉시컬 환경에 바인딩된다.
마찬가지로 렉시컬 환경은 환경 레코드와 외부 환경에 대한 참조로 구성된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.3) foo 함수 환경 레코드 생성&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;함수의 렉시컬 환경을 구성하는 컴포넌트 중 하나인 환경 레코드는 &lt;strong&gt;전역 객체와는 달리 매개변수, arguments 객체, 함수 내부에서
선언된 지역 변수와 중첩 함수를 등록하고 관리한다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.4) foo 함수 렉시컬 환경의 this 바인딩&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;foo 함수 환경 레코드의 내부 슬롯인 [[thisValue]]에 this가 바인딩된다. 함수는 호출 방식에 따라 this가 결정되는데,
foo 함수의 경우 일반 함수로 호출되었기 때문에 this에는 전역 객체가 바인딩된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.4) 외부 렉시컬 환경에 대한 참조 결정&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;외부 렉시컬 환경에 대한 참조는 foo 함수 정의가 평가되는 시점에 실행 중인 실행 컨텍스트의 렉시컬 환경의 참조가 할당된다.&lt;/p&gt;
&lt;p&gt;foo 함수의 정의는 전역 코드에 존재하기 때문에 전역 코드가 평가되는 시점에 순차적으로 평가된다. 즉 &lt;strong&gt;해당 시점에 실행되고 있는
실행 컨텍스트는 전역 실행 컨텍스트이다. 따라서 외부 렉시컬 환경에 대한 참조는 전역 렉시컬 환경의 참조가 할당된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;자바스크립트에서의 렉시컬 스코프는 &lt;strong&gt;함수를 어디서 호출했는지가 아니라, 어디에 정의했는지에 따라 상위 스코프가 결정된다.&lt;/strong&gt;
자바스크립트 엔진은 함수를 평가하여 함수 객체를 생성할 때 현재 실행 중인 실행 컨텍스트의 렉시컬 환경을 함수 객체의 내부 슬롯인
[[Environment]]에 저장한다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;외부 렉시컬 환경에 대한 참조에 할당되는 렉시컬 환경은 함수 객체의 내부 슬롯인 [[Environment]]에 저장된 렉시컬 환경의 참조이다.
이는 렉시컬 스코프를 구현하는 메커니즘이다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4.5) foo 함수 코드 실행&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;코드가 실행되면 매개변수에 인수가 할당되고, 변수할당문이 실행된다. 그리고 bar 함수가 호출된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5) bar 함수 내부에서 호출된 console 식별자 검색&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;bar 함수가 평가되는 과정은 foo 함수와 동일한 과정을 거치기 때문에 생략한다. 다만, bar 함수 내부에서 참조되는 console의 경우
bar 함수의 렉시컬 환경의 외부 렉시컬 환경에 대한 참조를 따라 전역 렉시컬 환경까지 올라가게 되고, 전역 렉시컬 환경의 객체 환경 레코드의
bindingObject를 통해 전역 객체를 찾아 console을 참조할 수 있게 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6) bar 함수 코드 실행 종료&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;console.log 메서드 호출 이후 더이상 실행할 코드가 없으므로 bar 함수 코드의 실행이 종료된다.
이때 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 팝되어 제거되고, foo 실행 컨텍스트가 현재 실행 중인 컨텍스트가 된다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7) foo 함수 코드 실행 종료&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;마찬가지로 foo 함수 또한 더이상 실행할 코드가 없으므로 foo 함수 코드의 실행이 종료되며 foo 함수 실행 컨텍스트는 스택에서 팝되어 제거되고,
현재 실행 중인 실행 컨텍스트는 전역 실행 컨텍스트가 된다.&lt;/p&gt;
&lt;h3 id=&quot;블록-레벨-스코프-메커니즘&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B8%94%EB%A1%9D-%EB%A0%88%EB%B2%A8-%EC%8A%A4%EC%BD%94%ED%94%84-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98&quot; aria-label=&quot;블록 레벨 스코프 메커니즘 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;블록 레벨 스코프 메커니즘&lt;/h3&gt;
&lt;p&gt;let, const는 함수의 코드 블록만 지역 스코프로 인정하는 것과는 달리, 모든 코드 블록을 블록 스코프로서 인정한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let a = 10;

if (true) {
  let a = 1;
  console.log(a); // 1;
}

console.log(a); // 10;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;만약 if문의 코드 블록이 실행되면, &lt;strong&gt;let, const의 식별자가 관리되는 선언적 환경 레코드를 갖는 렉시컬 환경이 새롭게 생성되고
이를 통해 글로벌 렉시컬 환경의 선언적 환경 레코드를 교체한다.이후 코드 블록의 실행이 종료되면 기존 글로벌 렉시컬 환경으로
다시 교체하여 코드 블록의 외부 코드의 전개를 보장한다.&lt;/strong&gt; 이는 블록 레벨 스코프를 구현하는 메커니즘이다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[tailwind-converter 제작기]]></title><description><![CDATA[tailwind-converter 라이브러리를 릴리즈하게 되었다.
styled-components를 통해 정의된 코드레벨의 컴포넌트 스타일을 추출하여
tailwindCSS…]]></description><link>https://youthfulhps.dev/development/tailwind-converter/</link><guid isPermaLink="false">https://youthfulhps.dev/development/tailwind-converter/</guid><pubDate>Tue, 05 Sep 2023 13:10:06 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/@youthfulhps/tailwind-converter&quot;&gt;tailwind-converter&lt;/a&gt; 라이브러리를 릴리즈하게 되었다.
&lt;a href=&quot;https://www.npmjs.com/package/styled-components&quot;&gt;styled-components&lt;/a&gt;를 통해 정의된 코드레벨의 컴포넌트 스타일을 추출하여
&lt;a href=&quot;https://tailwindcss.com/&quot;&gt;tailwindCSS&lt;/a&gt;에서 제공하는 유틸리티 클래스로 변환하고, 해당 컴포넌트의 사용처를 찾아 변환된 스타일 클래스들을 할당,
최종적으로 코드를 반환하는 도구이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;before&lt;/strong&gt;
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 95.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAADS0lEQVQ4y4WUy27bRhSG9RpdBEEiWTeSGo5404UUSYkUdXOlxKoT2ZaTOIoXQVJbji2lcIFu7AIBssgq66JP0Df8c4ZkIqV1kcWHIQHym3OZM5m3x39jN7jAJFgTV5iEKzwi9qIVpsR+f42j8e84HF/j6WBNrDAbJhyMVjjcXWE+fo9forf4ePUPMpP2OSr3q5AVF5VCEzxXhypZKOdM5B/oKGYNeq6hlLVQoPdtioKHOqSchXs/7eD17AaZ/e4aZq4F25ygWR2hUQrR1APYegjHCNHQAvByG6zoQS354CnV8lc8GEqHNtRxNv+AzF7wDkbBhq5H0FgIvzEGY33I+RZFTFHnXTBaWVGsLajFDbyUoEs+Rcvx69GflHKwhGPaGAYDhE4XkRdRRD6UvJsIScLo52+y0veyajkVPhTCW2TG4RJywYIu+zCZD0YfyTsOWN6JJXFkxY2M/0smMOjfEgnPhHAaXkDNNsCrESpSG2Ylgsl7UPgATO5ALdwhE6JUqMVCLxaez0m4113CNR102wPYVgCvFsGqhqjIARil/iOZJrVgpsLlMQkfhefQlDr8Wog692ExL/5QpPxNtp3itiyuHwkVD+Usx8WzW9GUMxisjmGnj64bot0IaNekbvz/ZNJGJrBS4TshnPbOoVBTDEXUz0NNTdK8q/h3yQw5EUokvHxOwv3+klpuUke9tJtufFj/I7pLJjmxsEaBSDmOqxcknPUv0KYp6BhDaLUuTJoQcQxY0aYj5KRpOt/VTJc3sljIEuHqxY1ImWqYb2KqT9Cu9tE0erAJhwVoURl02Y0x4ogSwUbmUENaqJNQJuH6RMxy/wxy1sSE7yKqj9AKSGwP0WvS1NQD+FaEwBnDp9Hs0Cbmlkg8bwvfvyThbLikw9uAUwlhlqm7FK1Ks61SurwkUhXQrFNUehzZV1myWkRDTYS/LUg4H1/SBVCjD9uUCt0cFRpBAR1Wg1I1lQ2WoOJSE1KYS9G5sDndRnkN16/ocjjovQF/oKFFnW1QNFyj4uviHNZoIzOGCQoJqqCYwFN0qY6d+yVqyh/IXJ58wsg7xl73FI/DBaYp+xHRW+AJ8bSfMBMMFjgYLnCYcjRa4PjnUzyJ5vh8/Re+AF8xindyJKdBAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;tailwind-converter를 통해 변환하기 전 코드&quot;
        title=&quot;tailwind-converter를 통해 변환하기 전 코드&quot;
        src=&quot;/static/13ba738127b9e0a50b34f4025d05e1a1/c1b63/before.png&quot;
        srcset=&quot;/static/13ba738127b9e0a50b34f4025d05e1a1/5a46d/before.png 300w,
/static/13ba738127b9e0a50b34f4025d05e1a1/0a47e/before.png 600w,
/static/13ba738127b9e0a50b34f4025d05e1a1/c1b63/before.png 1200w,
/static/13ba738127b9e0a50b34f4025d05e1a1/eee07/before.png 1628w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;after&lt;/strong&gt;
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 98.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAADdUlEQVQ4y3WU2XLaZhiGuY6epI0xi5AE2kEbQkICscWum9h4ARwbnOkknfYKepDBnUxOegs97FW+fSXBmKHJwTMf0ohH3/ar9HHxD66mn3Ezfcb1bIsbcksWZ1ssz5/x+O4LNldf8TT/is3lFzz8ssXj22esyebdNufD1V94uPgT29//Ralv3UL8UUNdcCCedCCfWJDrJqqvDZRfaRDKFoTTdh7rJyYqfDajmvFTgXBi4NUPNVwkH1Cauk+wqyE8+2e4ygRuI4ZvxXCNBJ4Rw9H6UIUQzWqAVr0HZYcqvKCLEUS+8GbyB0qp/R5a1YeiJNDkGJ45hSwPIfNes9YtqHZfftd8tDLq/A+jwqg1AmapYz7+hFLirBB2AgyjFJE7QBqO0GyEkCo+5Eq3EO/5hkwRjoSRs4QqOei0QpYX5g9Ipx5k0txnWd2JviFTGXUKG2Ud1+OPKA3sFYfhQJL6EGsB+xHnpUvyAM28dweyvYioO1kWdbEQ3kwoHLn3CNs9hCzVMWN0rRSWOoTUHOal77P6nkwjBoXiXhi7C3Q0F4HVZ9k92GqPPWGpFe//JR7LGgfCUx23UwqjzgK25iHtDTkUrose8uHdNI9lB1ntZTqjKRXCu0w4cJfQRAeOHsE3C45LVITvy/ZCicLFjMKhv0SVp0M65XTLXj7h1mF5wpGo8SIyxAJrJ1y+oXDq38Pl4nayxbYSWFrCh7LpZj0sUIhaf0ETSMODzqgztmUKKzpWmXDMDBM5whtrBptHzfZSOBT7Ro+EefSMAI4awNMDtiS7z99al9dd9rzLknkAMuFZlmG4RLvpYGSnCOMx4nSKcTjA+XDAmCB2YsQcVs+KMPT66Dsh+vYAiTdB3xshsQbwm2Ge4f1ZPpQ7tMo2Rq0xXGsI00n51ohrFHInuZ9tSv0ZQn4sEjVGp9llAkG+YvmasVyb100K359TOOmt2BcXrhTBEgIoVZcD8Yoh5NM96NkOQySMJqMpeflLMuFDJjzvP7DpDiwOwhR7MHimTZItqyEW/dljyQXtPRRlMoeZKjUT64tP2ffwBnrZhM8D3uZbVTZZY8Nb9Q4nbeW0MmoFyp66xewL9EYH9dcSlrMNSr/OP2MWrnAx2PCLu8bbmCSPuByucZlucEXmo4Lr0ZpflDXP7Bq3O+6ma+7fE+bpCs+//Y3/AHiCqt+4p0lPAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;tailwind-convert를 통해 변환된 코드&quot;
        title=&quot;tailwind-convert를 통해 변환된 코드&quot;
        src=&quot;/static/6606337acff3e876267a50f0c10223a6/c1b63/after.png&quot;
        srcset=&quot;/static/6606337acff3e876267a50f0c10223a6/5a46d/after.png 300w,
/static/6606337acff3e876267a50f0c10223a6/0a47e/after.png 600w,
/static/6606337acff3e876267a50f0c10223a6/c1b63/after.png 1200w,
/static/6606337acff3e876267a50f0c10223a6/eee07/after.png 1628w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;간단한 예제에서는 그럴싸하게 동작하지만, 아직 실무에서 사용되는 복잡한 정의의 컴포넌트를 완벽하게 변환하기까지, 혹은 완벽하게 변환이 가능한 것인지도 모를 단계이자,
아직 많은 이슈와 챌린지들을 직면하고 있다.&lt;/p&gt;
&lt;p&gt;그래도 1차적으로 목표했던 기능이 완성되었고, 라이브러리를 제작하면서 배우고 고민했던 것들을 기록하기 위해 회고를 남겨보려 한다.&lt;/p&gt;
&lt;h2 id=&quot;동기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8F%99%EA%B8%B0&quot; aria-label=&quot;동기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;동기&lt;/h2&gt;
&lt;p&gt;사내 내부적으로 프론트엔드 파트 통합을 준비하면서 각 파트의 기술 스택 통일에 대한 필요성을 느꼈다. 결과적으로 스타일링을 위해 사용되는 도구로는 tailwindCSS가
채택되고, styled-components를 사용하고 있는 레거시 스타일 정의에 대해 리팩토링과 마이그레이션이 필요한 상황이었다.&lt;/p&gt;
&lt;p&gt;다만 해당 작업이 지엽적이고 반복적인 작업에 피로가 꽤나 쌓일 만한 작업이었으며, 수반되는 QA도 무시할 수 없었다. 별수 있나 받아들이고 시간 날 때마다 마이그레이션
작업을 했다. 당연한 이야기지만, 다음과 같은 과정을 반복했다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;정의된 컴포넌트의 스타일을 확인한다.&lt;/li&gt;
&lt;li&gt;스타일 속성과 값에 대응하는 tailwind 유틸리티 클래스를 찾는다.&lt;/li&gt;
&lt;li&gt;해당 컴포넌트의 사용처에서 열린 태그를 찾아 className 속성에 해당 유틸리티 클래스를 할당한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;그러다 문뜩 코드 수정을 발생시키는 위 과정들을 수행하는 프로그램을 작성해 볼 수 있겠다는 생각이 들었다. 한정된 스타일 속성들과 이에 대응되는 유틸리티 클래스가
명확했고, styled 함수를 사용하는 코드 구조나 컴포넌트 사용처의 열린 태그가 가진 className 속성에 할당하는 과정 또한 문법적으로 제약이 있었기 때문이다.&lt;/p&gt;
&lt;p&gt;다만 코드란 게 다양한 스타일을 가지고 있기 때문에 모든 스타일을 대응할 수 있을 것이라고는 장담할 수는 없었지만, 우선 이러한 컨셉을 증명해 보기 위해 단순하게 정의된
기본적인 스타일 속성들에 대해 위 과정을 대신 수행해 주는 스크립트를 작성해 보자는 것을 첫 번째 목표로 삼았다.&lt;/p&gt;
&lt;h2 id=&quot;추상-구문-트리를-조작할-수-있구나&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%B6%94%EC%83%81-%EA%B5%AC%EB%AC%B8-%ED%8A%B8%EB%A6%AC%EB%A5%BC-%EC%A1%B0%EC%9E%91%ED%95%A0-%EC%88%98-%EC%9E%88%EA%B5%AC%EB%82%98&quot; aria-label=&quot;추상 구문 트리를 조작할 수 있구나 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;추상 구문 트리를 조작할 수 있구나&lt;/h2&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 733px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 24%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAuklEQVQY052OWw6CMBREuybFRBHaiiJKRWl5CCFBfLsCF+GmxxYNUT/9OJne6WlzibepMBpOQVnYwicCjAtYA/4XRJQnDCyGsRtg7ARw3AVG9gy9Pv0LYtMlXCr0R+EHQm+7ehPpjaMuGV+/87d79cR/3JGJBtvqhiQ9IC8uKMor0vyETGNmlewh1R6xbKC0I1XTulL3KjkgyY7aPbcO8VSJeF23l7HcdaI5m4ebuIY/zzpmfvo1f3YmnwKztoPYgOSTAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;openai 채팅의 일부분&quot;
        title=&quot;openai 채팅의 일부분&quot;
        src=&quot;/static/4a89866568256f698c0f46957fcdcdb0/00b70/chat-with-openai.png&quot;
        srcset=&quot;/static/4a89866568256f698c0f46957fcdcdb0/5a46d/chat-with-openai.png 300w,
/static/4a89866568256f698c0f46957fcdcdb0/0a47e/chat-with-openai.png 600w,
/static/4a89866568256f698c0f46957fcdcdb0/00b70/chat-with-openai.png 733w&quot;
        sizes=&quot;(max-width: 733px) 100vw, 733px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;처음엔 코드 파일을 스크랩해서 정규식을 통해 정의된 컴포넌트의 스타일을 추출해 보려 했으나 절대 안전한 방법이 아니라는 걸 금방 깨달았다.
컨벤션이 정해져 있다고 한들 다양한 코드 스타일을 감당할 만한 정규식을 기대하기는 어려웠고, 더 엄격한 정규식을 사용하면 예외적인 문자열이 포함되거나, 원하는 문자열이
제외되는 경우가 많았다.&lt;/p&gt;
&lt;p&gt;결론부터 말하자면 추상 구문 트리를 조작하는 것으로 접근 방식을 정했다. 사실 추상 구문 트리를 조작해야겠다는 생각이 쉽게 떠오른 것은 아니었는데, 한창 어떻게 풀어낼 수
있을 까 고민하던 중 우연히 익숙하게 사용한 &lt;a href=&quot;https://prettier.io/&quot;&gt;prettier&lt;/a&gt;로 코드 포매팅을 했는데, 자바스크립트 문법을 읽기 쉽게 코드를 포매팅해준다면,
prettier는 문자열 덩어리에서 자바스크립트를 어떻게 해석할 수 있는 것인가에 대한 의문이 생겼다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;추상 구문 트리는 프로그래밍 언어로 작성된 소스 코드의 추상 구문 구조의 트리이다. 이 트리의 각 노드는 소스 코드에서 발생되는 구조를 나타낸다.
[위키 백과/추상 구문 트리] 중&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;결국 코드 텍스트에서 트리 구조의 데이터 구조를 만들어내고, 코드에 있는 각각의 아이템을 통해 노드를 구성한 구조가 추상 구문 트리이다. &lt;a href=&quot;https://babeljs.io/&quot;&gt;babel&lt;/a&gt;에서
자바스크립트를 컴파일링할때나, prettier, eslint와 같이 포매팅 혹은 컨벤션 이슈를 체크하는 도구들 또한 추상 구문 트리를 기반으로 코드를 해석하고 조작한다.&lt;/p&gt;
&lt;p&gt;간단하게 예시를 살펴보자. 다음과 같은 코드로 추상 구문 트리를 생성한 결과이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const Title = styled.h1`
  font-size: 1.5em;
  text-align: center;
  color: #bf4f74;
`;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;type&amp;quot;: &amp;quot;File&amp;quot;,
  &amp;quot;start&amp;quot;: 0,
  &amp;quot;end&amp;quot;: 87,
  &amp;quot;loc&amp;quot;: {
    &amp;quot;start&amp;quot;: {...},
    &amp;quot;end&amp;quot;: {...},
  },
  &amp;quot;range&amp;quot;: [0, 87],
  &amp;quot;errors&amp;quot;: [],
  &amp;quot;program&amp;quot;: {
    &amp;quot;type&amp;quot;: &amp;quot;Program&amp;quot;,
    &amp;quot;start&amp;quot;: 0,
    &amp;quot;end&amp;quot;: 87,
    &amp;quot;loc&amp;quot;: {
      &amp;quot;start&amp;quot;: {...},
      &amp;quot;end&amp;quot;: {...},
    },
    &amp;quot;range&amp;quot;: [0, 87],
    &amp;quot;sourceType&amp;quot;: &amp;quot;module&amp;quot;,
    &amp;quot;interpreter&amp;quot;: null,
    &amp;quot;body&amp;quot;: [
      {
        &amp;quot;type&amp;quot;: &amp;quot;VariableDeclaration&amp;quot;,
        &amp;quot;start&amp;quot;: 0,
        &amp;quot;end&amp;quot;: 87,
        &amp;quot;loc&amp;quot;: {
          &amp;quot;loc&amp;quot;: {
            &amp;quot;start&amp;quot;: {...},
            &amp;quot;end&amp;quot;: {...},
          },
        },
        &amp;quot;range&amp;quot;: [0, 87],
        &amp;quot;declarations&amp;quot;: [
          {
            &amp;quot;type&amp;quot;: &amp;quot;VariableDeclarator&amp;quot;,
            &amp;quot;start&amp;quot;: 6,
            &amp;quot;end&amp;quot;: 86,
            &amp;quot;loc&amp;quot;: {
              &amp;quot;start&amp;quot;: {...},
              &amp;quot;end&amp;quot;: {...},
            },
            &amp;quot;range&amp;quot;: [6, 86],
            &amp;quot;id&amp;quot;: {
              &amp;quot;type&amp;quot;: &amp;quot;Identifier&amp;quot;,
              &amp;quot;start&amp;quot;: 6,
              &amp;quot;end&amp;quot;: 11,
              &amp;quot;loc&amp;quot;: {
                &amp;quot;start&amp;quot;: {...},
                &amp;quot;end&amp;quot;: {...},
              },
              &amp;quot;range&amp;quot;: [6, 11],
              &amp;quot;name&amp;quot;: &amp;quot;Title&amp;quot;
            },
            &amp;quot;init&amp;quot;: {
              &amp;quot;type&amp;quot;: &amp;quot;TaggedTemplateExpression&amp;quot;,
              &amp;quot;start&amp;quot;: 14,
              &amp;quot;end&amp;quot;: 86,
              &amp;quot;loc&amp;quot;: {
                &amp;quot;start&amp;quot;: {...},
                &amp;quot;end&amp;quot;: {...},
              },
              &amp;quot;range&amp;quot;: [14, 86],
              &amp;quot;tag&amp;quot;: {
                &amp;quot;type&amp;quot;: &amp;quot;MemberExpression&amp;quot;,
                &amp;quot;start&amp;quot;: 14,
                &amp;quot;end&amp;quot;: 23,
                &amp;quot;loc&amp;quot;: {
                  &amp;quot;start&amp;quot;: {...},
                  &amp;quot;end&amp;quot;: {...},
                },
                &amp;quot;range&amp;quot;: [14, 23],
                &amp;quot;object&amp;quot;: {
                  &amp;quot;type&amp;quot;: &amp;quot;Identifier&amp;quot;,
                  &amp;quot;start&amp;quot;: 14,
                  &amp;quot;end&amp;quot;: 20,
                  &amp;quot;loc&amp;quot;: {
                    &amp;quot;start&amp;quot;: {...},
                    &amp;quot;end&amp;quot;: {...},
                  },
                  &amp;quot;range&amp;quot;: [14, 20],
                  &amp;quot;name&amp;quot;: &amp;quot;styled&amp;quot;
                },
                &amp;quot;computed&amp;quot;: false,
                &amp;quot;property&amp;quot;: {
                  &amp;quot;type&amp;quot;: &amp;quot;Identifier&amp;quot;,
                  &amp;quot;start&amp;quot;: 21,
                  &amp;quot;end&amp;quot;: 23,
                  &amp;quot;loc&amp;quot;: {
                    &amp;quot;start&amp;quot;: {...},
                    &amp;quot;end&amp;quot;: {...},
                  },
                  &amp;quot;range&amp;quot;: [21, 23],
                  &amp;quot;name&amp;quot;: &amp;quot;h1&amp;quot;
                }
              },
              &amp;quot;quasi&amp;quot;: {
                &amp;quot;type&amp;quot;: &amp;quot;TemplateLiteral&amp;quot;,
                &amp;quot;start&amp;quot;: 23,
                &amp;quot;end&amp;quot;: 86,
                &amp;quot;loc&amp;quot;: {
                  &amp;quot;start&amp;quot;: {...},
                  &amp;quot;end&amp;quot;: {...},
                },
                &amp;quot;range&amp;quot;: [23, 86],
                &amp;quot;expressions&amp;quot;: [],
                &amp;quot;quasis&amp;quot;: [
                  {
                    &amp;quot;type&amp;quot;: &amp;quot;TemplateElement&amp;quot;,
                    &amp;quot;start&amp;quot;: 24,
                    &amp;quot;end&amp;quot;: 85,
                    &amp;quot;loc&amp;quot;: {
                      &amp;quot;start&amp;quot;: {...},
                      &amp;quot;end&amp;quot;: {...},
                    },
                    &amp;quot;range&amp;quot;: [24, 85],
                    &amp;quot;value&amp;quot;: {
                      &amp;quot;raw&amp;quot;: &amp;quot;\n  font-size: 1.5em;\n  text-align: center;\n  color: #BF4F74;\n&amp;quot;,
                      &amp;quot;cooked&amp;quot;: &amp;quot;\n  font-size: 1.5em;\n  text-align: center;\n  color: #BF4F74;\n&amp;quot;
                    },
                    &amp;quot;tail&amp;quot;: true
                  }
                ]
              }
            }
          }
        ],
        &amp;quot;kind&amp;quot;: &amp;quot;const&amp;quot;
      }
    ],
    &amp;quot;directives&amp;quot;: []
  },
  &amp;quot;comments&amp;quot;: [],
  &amp;quot;tokens&amp;quot;: [...]
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;즉 코드를 통해 생성된 추상 구문 트리를 조작하면 코드가 재생성될 때 유효하게 조작된 결과를 얻을 수 있을 것이다. 사실 매우 복잡한 추상 구문 트리를 직접 조작하기란
절대 쉽지 않다. 다만 가장 안전한 방법이다. &lt;strong&gt;추상 구문 트리의 조작이 유효하지 않다면 에러가 발생하게 되는데, 인위적인 조작이 유효한지 프로그래밍적으로
판단할 수 있다는 것은 정말 큰 장점이라고 생각했다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;이하 구현 과정과 예시에서 자바스크립트 코드를 파싱하고 조작하기 위한 도구로 prettier를 사용합니다. 일반적으로 babel에서 제공하는 parser, generator를
사용하지만, prettier에서도 내부적으로 동일한 parser를 사용하고 있다는 점과, 코드 조작을 위한 &lt;a href=&quot;https://prettier.io/docs/en/api&quot;&gt;API&lt;/a&gt;를 제공하고
있다는 점을 감안하여 선택하였습니다.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-선언된-컴포넌트-정보-추출하기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%84%A0%EC%96%B8%EB%90%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%A0%95%EB%B3%B4-%EC%B6%94%EC%B6%9C%ED%95%98%EA%B8%B0&quot; aria-label=&quot;1 선언된 컴포넌트 정보 추출하기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 선언된 컴포넌트 정보 추출하기&lt;/h2&gt;
&lt;p&gt;우선 추상 구문 트리에서 스타일된 컴포넌트에 대한 정보가 담긴 노드를 조건에 맞게 찾아내야 했다. 여기서 주의해야 하는 것은 변수 선언은 함수 선언문 혹은
if-else, switch와 같은 상태문 내부에서도 선언될 수 있다는 것이다. 개인적으로 스타일된 컴포넌트를 정의 할땐 디폴트 격의 함수와 같은 레벨에 작성했지만,
다른 스코프 내부에서 스타일된 컴포넌트를 정의해도 전혀 문제 될 것이 없다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// component variable declaration
const Title = styled.h1`
  font-size: 1.5em;
  text-align: center;
  color: #bf4f74;
`;

function Component() {
  return &amp;lt;Title&amp;gt;...&amp;lt;/Title&amp;gt;;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Component() {
  // component variable declaration
  const Title = styled.h1`
    font-size: 1.5em;
    text-align: center;
    color: #bf4f74;
  `;

  if (isOpen) {
    // component variable declaration
    const SubTitle = styled.h1`
      font-size: 0.5em;
      text-align: center;
      color: #bf4f74;
    `;

    return &amp;lt;SubTitle&amp;gt;...&amp;lt;/SubTitle&amp;gt;;
  }

  return &amp;lt;Title&amp;gt;...&amp;lt;/Title&amp;gt;;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;즉 추상 구문 트리에서 스타일된 컴포넌트 코드 정보가 담긴 노드를 찾으려면, 트리에 존재하는 모든 노드를 레벨에 상관없이 재귀적으로 순회해 주어야 했다. 또한 노드의
타입별로 구조가 달랐기 때문에 재귀 함수를 어떻게 짜야 될지 정말 감이 오질 않았다. 머리를 쥐어뜯다 결국 사수님께 조언을 구해 노드 객체의 프로퍼티의 값이 배열 혹은
객체인 경우 모두 재귀 호출을 하는 방식으로 순회를 구현할 수 있었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function recursion(node: unknown) {
  if (!isObject(node) || !(&amp;#39;type&amp;#39; in node)) {
    return;
  }

  // 객체를 이루는 모든 키와 값을 재귀 순회
  Object.entries(node).forEach(([key, value]) =&amp;gt; {
    if (key === &amp;#39;type&amp;#39;) {
      return;
    }

    if (Array.isArray(value)) {
      value.forEach((childNode: unknown) =&amp;gt; {
        recursion(childNode);
      });
      return;
    }

    recursion(value);
  });
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 모든 노드를 순회하면서 styled 라는 이름을 가진 TaggedTemplateExpression 타입의 표현문이 초기 할당된 변수 선언 타입을 가진 노드라는 주요 조건을 걸어
조건을 충족하는 노드에서 스타일된 컴포넌트의 이름과 태그 그리고 스타일 정의를 추출했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;if (
  node.type === &amp;#39;VariableDeclarator&amp;#39; &amp;amp;&amp;amp;
  &amp;#39;id&amp;#39; in node &amp;amp;&amp;amp;
  isObject(node.id) &amp;amp;&amp;amp;
  &amp;#39;type&amp;#39; in node.id &amp;amp;&amp;amp;
  &amp;#39;name&amp;#39; in node.id &amp;amp;&amp;amp;
  node.id.type === &amp;#39;Identifier&amp;#39; &amp;amp;&amp;amp;
  typeof node.id.name === &amp;#39;string&amp;#39; &amp;amp;&amp;amp; // 요게 컴포넌트 이름
  &amp;#39;init&amp;#39; in node &amp;amp;&amp;amp;
  isObject(node.init) &amp;amp;&amp;amp;
  &amp;#39;type&amp;#39; in node.init &amp;amp;&amp;amp;
  node.init.type === &amp;#39;TaggedTemplateExpression&amp;#39; &amp;amp;&amp;amp;
  &amp;#39;tag&amp;#39; in node.init &amp;amp;&amp;amp;
  isObject(node.init.tag) &amp;amp;&amp;amp;
  &amp;#39;object&amp;#39; in node.init.tag &amp;amp;&amp;amp;
  isObject(node.init.tag.object) &amp;amp;&amp;amp;
  &amp;#39;type&amp;#39; in node.init.tag.object &amp;amp;&amp;amp;
  &amp;#39;name&amp;#39; in node.init.tag.object &amp;amp;&amp;amp;
  node.init.tag.object.type === &amp;#39;Identifier&amp;#39; &amp;amp;&amp;amp;
  node.init.tag.object.name === &amp;#39;styled&amp;#39; &amp;amp;&amp;amp; // styled 함수를 사용했는가
  &amp;#39;property&amp;#39; in node.init.tag &amp;amp;&amp;amp;
  isObject(node.init.tag.property) &amp;amp;&amp;amp;
  &amp;#39;name&amp;#39; in node.init.tag.property &amp;amp;&amp;amp;
  typeof node.init.tag.property.name === &amp;#39;string&amp;#39; &amp;amp;&amp;amp; // 요게 태그 이름
  &amp;#39;quasi&amp;#39; in node.init &amp;amp;&amp;amp;
  isObject(node.init.quasi) &amp;amp;&amp;amp;
  &amp;#39;type&amp;#39; in node.init.quasi &amp;amp;&amp;amp;
  node.init.quasi.type === &amp;#39;TemplateLiteral&amp;#39; &amp;amp;&amp;amp;
  &amp;#39;quasis&amp;#39; in node.init.quasi &amp;amp;&amp;amp;
  Array.isArray(node.init.quasi.quasis) &amp;amp;&amp;amp;
  &amp;#39;type&amp;#39; in node.init.quasi.quasis[0] &amp;amp;&amp;amp;
  node.init.quasi.quasis[0].type === &amp;#39;TemplateElement&amp;#39; &amp;amp;&amp;amp;
  &amp;#39;value&amp;#39; in node.init.quasi.quasis[0] &amp;amp;&amp;amp;
  isObject(node.init.quasi.quasis[0].value)
) {
  const sassScript = generateConcatenatedCSSTemplateLiteral(
    node.init.quasi.quasis
  );

  const parsedCSS = parseSass(sassScript);

  const componentDeclaration: ComponentDeclaration = {
    name: node.id.name,
    tag: node.init.tag.property.name,
    styles: parsedCSS,
  };

  componentDeclarations.push(componentDeclaration);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;스타일 정의를 추출하는 작업은 sass, css 파서에게 맡겼다. sass 컴파일을 통해 css로 변환하고, 해당 css를 파싱해서 해당 컴포넌트의 스타일 정의와 값, 내부에
정의되어 있는 클래스 또한 추출할 수 있었다. 이렇게 정의된 컴포넌트의 정보를 추상 구문 트리에서 획득했다.&lt;/p&gt;
&lt;h2 id=&quot;2-추출된-스타일-정의를-유틸리티-클래스로-변환하기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%B6%94%EC%B6%9C%EB%90%9C-%EC%8A%A4%ED%83%80%EC%9D%BC-%EC%A0%95%EC%9D%98%EB%A5%BC-%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0&quot; aria-label=&quot;2 추출된 스타일 정의를 유틸리티 클래스로 변환하기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 추출된 스타일 정의를 유틸리티 클래스로 변환하기&lt;/h2&gt;
&lt;p&gt;이제 컴포넌트별로 추출된 스타일을 tailwindCSS의 정의되어 있는 유틸리티 클래스로 변환해 주어야 한다. 스타일 속성과 할당된 값에 대응되는 유틸리티 클래스 리스트가
필요했는데 우연히 CSS 정의를 tailwind 유틸리티 클래스로 변환해 주는 &lt;a href=&quot;https://tailwind-converter.netlify.app/&quot;&gt;웹 서비스&lt;/a&gt;의 소스 코드에서 constants
파일을 구할 수 있었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const TAILWINDCLASS: { [key: string]: any } = {
  ...
  &amp;#39;font-size&amp;#39;: {
      arbitrary: &amp;#39;text&amp;#39;,
      &amp;#39;0.75rem&amp;#39;: &amp;#39;.text-xs&amp;#39;,
      &amp;#39;0.875rem&amp;#39;: &amp;#39;.text-sm&amp;#39;,
      &amp;#39;1rem&amp;#39;: &amp;#39;.text-base&amp;#39;,
      &amp;#39;1.125rem&amp;#39;: &amp;#39;.text-lg&amp;#39;,
      &amp;#39;1.25rem&amp;#39;: &amp;#39;.text-xl&amp;#39;,
      &amp;#39;1.5rem&amp;#39;: &amp;#39;.text-2xl&amp;#39;,
      &amp;#39;1.875rem&amp;#39;: &amp;#39;.text-3xl&amp;#39;,
      &amp;#39;2.25rem&amp;#39;: &amp;#39;.text-4xl&amp;#39;,
      &amp;#39;3rem&amp;#39;: &amp;#39;.text-5xl&amp;#39;,
      &amp;#39;4rem&amp;#39;: &amp;#39;.text-6xl&amp;#39;,
  },
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;가령 font-size 라는 스타일 속성에 할당된 값이 해당 키 배열에 포함되어 있다면, tailwindCSS에서 제공하는 기본 클래스에 포함되어 있다고 간주하고 해당 값을
반환해 주었고, 그 외의 값에 대해서는 임의로 할당된 클래스를 생성하여 반환하도록 구현했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function convertCss({ property, value }: CSSStyleEntity) {
  property = preprocessProperty({ property, value });
  const processedValue = preprocessValue({ property, value });

  if (!TAILWINDCLASS[property]) {
    // 스타일 속성이 유효하지 않다면,
    // 빈 문자열을 반환한다.
    return &amp;#39;&amp;#39;;
  }

  if (!TAILWINDCLASS[property][processedValue]) {
    // 스타일 속성에 할당된 값과 대응되는 키가 없다면,
    // 즉 유효한 속성에 할당된 값과 대응되는 유틸리티 클래스가 없다면,
    // 임의의 값을 전달하는 형태로 클래스를 생성하여 반환한다.
    // ex) text-[7px]
    return `${TAILWINDCLASS[property][&amp;#39;arbitrary&amp;#39;]}-[${value}]`;
  }

  // 스타일 속성에 할당된 값과 대응되는 키가 있다면,
  // 해당 키의 값을 반환한다.
  // ex) text-base
  return TAILWINDCLASS[property][processedValue].slice(1);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위 코드에서 속성과 값이 전처리되고 있는 것을 볼 수 있다. 이는 가령 background 속성에 색상 값이 할당되어 있는 경우 background-color로 변경한다거나,&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function preprocessProperty({ property, value }: CSSStyleEntity) {
  if (property === &amp;#39;background&amp;#39;) {
    if (isColor(value)) {
      return &amp;#39;background-color&amp;#39;;
    }
    return property;
  }

  return property;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;px, rem, em으로 표현되는 치수를 통일시켜주거나,&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function preprocessDimension(value: string) {
  if (value === &amp;#39;0&amp;#39; || value === &amp;#39;0px&amp;#39;) {
    return &amp;#39;0&amp;#39;;
  }

  return convertUnit(value, &amp;#39;rem&amp;#39;);
}

export function preprocessSpacing(value: string) {
  return convertUnit(value, &amp;#39;rem&amp;#39;);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;축약된 값을 할당할 수 있는 padding, margin, border과 같은 속성을 쪼개는 과정이 포함된다.
(background 또한 축약 속성이나, 아직 값을 적절하게 쪼개내지 못했다..)&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function preprocessSpacingShorthand(
  property: &amp;#39;padding&amp;#39; | &amp;#39;margin&amp;#39;,
  value: string,
): StyleEntity[] {
  const values = value.split(&amp;#39; &amp;#39;);

  const propertyX = `${property}-x`;
  const propertyY = `${property}-y`;
  const propertyTop = `${property}-top`;
  const propertyRight = `${property}-right`;
  const propertyBottom = `${property}-bottom`;
  const propertyLeft = `${property}-left`;

  switch (values.length) {
    case 2:
      return [
        {
          property: propertyY,
          value: values[0],
        },
        {
          property: propertyX,
          value: values[1],
        },
      ];
  ...
  }
}

function preprocessBorderShorthand(value: string): StyleEntity[] {
  const values = value.split(&amp;#39; &amp;#39;);

  const borderStyle = findBorderStyle(values);
  const borderWidth = findBorderWidth(values);
  const borderColor = findBorderColor(values);

  if (!borderStyle) {
    return [];
  }

  const border: StyleEntity[] = [
    {
      property: &amp;#39;border-style&amp;#39;,
      value: borderStyle,
    },
  ];

  if (borderWidth) {
    ...
  }

  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;결과적으로 다음과 같은 스타일 정의에 대한 유틸리티 클래스를 묶어 얻어낼 수 있었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;text&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const before = [
  &amp;quot;font-size:1.5em&amp;quot;,
  &amp;quot;text-align:center&amp;quot;,
  &amp;quot;color:#bf4f74&amp;quot;
]

=&amp;gt; &amp;quot;text-2xl text-center text-[#bf4f74]&amp;quot;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;3-컴포넌트-사용처-조작하기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%82%AC%EC%9A%A9%EC%B2%98-%EC%A1%B0%EC%9E%91%ED%95%98%EA%B8%B0&quot; aria-label=&quot;3 컴포넌트 사용처 조작하기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 컴포넌트 사용처 조작하기&lt;/h2&gt;
&lt;p&gt;이제 컴포넌트 정의와 변환된 유틸리티 클래스를 얻었으니 컴포넌트의 열린 태그를 포함하고 있는 노드를 찾아 해당 노드의 className 속성에 변환된 유틸리티 클래스를
할당해 주어야 한다.&lt;/p&gt;
&lt;p&gt;마찬가지로 JSXElement 반환문에 사용되는 컴포넌트의 열린 태그는 여러 레벨의 상태문 안에서 사용될 수 있기 때문에 추상 구문 트리의 모든 레벨과 노드를 순회해야 한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Component() {
  if (isOpen) {
    return &amp;lt;Title&amp;gt;...&amp;lt;/Title&amp;gt;
  }

  switch(type) {
    case &amp;#39;primary&amp;#39;:
      return &amp;lt;PrimaryTitle&amp;gt;...&amp;lt;/PrimaryTitle&amp;gt;
    ...
  }

  return &amp;lt;SubTitle&amp;gt;...&amp;lt;/SubTitle&amp;gt;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;스타일된 컴포넌트의 사용처에서 열린 태그를 찾는 조건은 다음과 같은 조건을 걸었다. 그리고 조건에 충족한 노드를 만나면 className 속성에 변환된 유틸리티 클래스
문자열을 덮어쓰는 방식으로 속성 조작을 구현했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;if (
  node.type === &amp;#39;JSXOpeningElement&amp;#39; &amp;amp;&amp;amp;
  parentNode?.type === &amp;#39;JSXElement&amp;#39; &amp;amp;&amp;amp;
  &amp;#39;name&amp;#39; in node &amp;amp;&amp;amp;
  isObject(node.name) &amp;amp;&amp;amp;
  &amp;#39;type&amp;#39; in node.name &amp;amp;&amp;amp;
  node.name.type === &amp;#39;JSXIdentifier&amp;#39; &amp;amp;&amp;amp;
  &amp;#39;name&amp;#39; in node.name &amp;amp;&amp;amp;
  typeof node.name.name === &amp;#39;string&amp;#39; &amp;amp;&amp;amp;
  &amp;#39;attributes&amp;#39; in node &amp;amp;&amp;amp;
  Array.isArray(node.attributes) &amp;amp;&amp;amp;
  &amp;#39;selfClosing&amp;#39; in node
) {
  const elementName = node.name.name;

  // 추출된 컴포넌트 정보들에서 본 노드의 이름과 동일한 정보가 있는지 찾는다.
  const targetComponentDeclarations = componentDeclarations.filter(
    componentDeclaration =&amp;gt; componentDeclaration.name === elementName
  );

  if (targetComponentDeclarations.length) {
    // 만약 있다면,
    // 해당 노드의 속성 배열에 className 존재 여부를 판단한다.
    // 판단 여부에 따라 className의 값을 이어붙이거나, 새롭게 생성한다.
    const { tag, styles } = targetComponentDeclarations[0];
    const newAttributes = generateJSXOpeningElementClassNameAttribute(
      node.attributes,
      convertStyles(styles)
    );

    // 열린 태그의 컴포넌트 이름을 태그명으로 덮어쓴다.
    node.name.name = tag;
    // 열린 태그의 속성 배열을 새롭게 생성된 속성 배열로 덮어쓴다.
    node.attributes = newAttributes;

    // 만약 닫힌 태그가 있다면,
    // 닫힌 태그의 컴포넌트 이름을 태그명으로 덮어쓴다.
    if (!node.selfClosing) {
      if (
        &amp;#39;closingElement&amp;#39; in parentNode &amp;amp;&amp;amp;
        isObject(parentNode.closingElement) &amp;amp;&amp;amp;
        &amp;#39;name&amp;#39; in parentNode.closingElement &amp;amp;&amp;amp;
        isObject(parentNode.closingElement.name) &amp;amp;&amp;amp;
        &amp;#39;name&amp;#39; in parentNode.closingElement.name
      ) {
        parentNode.closingElement.name = tag;
      }
    }
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;결과적으로 다음과 같이 변환된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Component() {
  return (
    &amp;lt;Wrapper&amp;gt;
      &amp;lt;Title&amp;gt;Hello World!&amp;lt;/Title&amp;gt;
    &amp;lt;/Wrapper&amp;gt;
  );
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Component() {
  return (
    &amp;lt;section className=&amp;quot;p-16 bg-#ffefd5&amp;quot;&amp;gt;
      &amp;lt;h1 className=&amp;quot;text-2xl text-center text-[#bf4f74]&amp;quot;&amp;gt;Hello World!&amp;lt;/h1&amp;gt;
    &amp;lt;/section&amp;gt;
  );
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;남은-과제&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%82%A8%EC%9D%80-%EA%B3%BC%EC%A0%9C&quot; aria-label=&quot;남은 과제 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;남은 과제&lt;/h2&gt;
&lt;p&gt;단번에 모든 스타일된 컴포넌트 코드 스타일을 커버할 수 있는 변환기를 만들겠노라 목표하진 않았지만, 아직 조건부 스타일을 위한 보간 (interpolation)을 어떻게
처리해야 할 지 고민이 크다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const Card = styled.div&amp;lt;{ isSelected: boolean }&amp;gt;`
  ... border-width: ${({ isSelected }) =&amp;gt; (isSelected ? &amp;#39;4px&amp;#39; : &amp;#39;2px&amp;#39;)}; // ?
`;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;보간의 경우 그대로 열린 태그의 style 속성에 옮겨주면 괜찮지 않을까 싶지만, 열린 태그를 반환하는 스코프 내에서 아래와 같이 참조 가능한 변수 선언인지 판단이
필요하다. 우선 옮겨주고 에러 픽스는 작업자에게 맡겨도 되지 않을까 싶지만 에러가 담긴 코드를 뱉어 일을 두번 만들고 싶지는 않다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// card
&amp;lt;div style={{
  borderWidth: isSelected ? &amp;#39;4px&amp;#39; : &amp;#39;2px&amp;#39;
              // &amp;#39;isSelected&amp;#39; is not defined
}}&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;스타일 추출을 위해 sass 컴파일을 진행할 때 보간을 만나면 문법 에러를 발생시키기 때문에 현재 버전에서는 보간문을 모두 unset 속성으로 대체하여 변환하고 있다.&lt;/p&gt;
&lt;h2 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h2&gt;
&lt;p&gt;실무에서 사용하려 제작한 스크립트를 라이브러리로 제작하면서 배운 점이 많다. 추상 구문 트리를 조작하여 코드를 전처리한다는 접근법은 이후에도 유사한 작업을 처리할 때
유용하게 사용될 것 같다. 위에서 언급한 과제들이 남아있지만 유사한 작업을 진행 중이신 분들에게 개선된 개발자 경험에 있어 작게나마 도움이 될 수 있으면 좋겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[클로저]]></title><description><![CDATA[TL;TR…]]></description><link>https://youthfulhps.dev/TIL/javascript/closure/</link><guid isPermaLink="false">https://youthfulhps.dev/TIL/javascript/closure/</guid><pubDate>Thu, 10 Aug 2023 13:05:26 GMT</pubDate><content:encoded>&lt;h3 id=&quot;tltr&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#tltr&quot; aria-label=&quot;tltr permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;TL;TR&lt;/h3&gt;
&lt;p&gt;클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수 중 언젠가 자신이 실행될 때 사용할 변수들만 기억하여 유지시키는 함수다.&lt;/p&gt;
&lt;p&gt;이는 자바스크립트에서의 함수가 일급 객체(함수)로 평가되어 함수의 반환값으로 사용될 수 있는 특성과, 클로저라 칭하는 내부 함수 객체가
생성될 때 [[Environment]] 내부 슬롯이 현재 실행되고 있는 실행 컨텍스트의 스코프를 저장하고, 이를 렉시컬 환경의 외부 렉시컬 환경에
대한 참조를 구성할 때 사용되어 외부 스코프가 소멸되어도 자신이 참조하고 있는 식별자를 기억할 수 있게 된다.&lt;/p&gt;
&lt;h2 id=&quot;일급-객체함수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%BC%EA%B8%89-%EA%B0%9D%EC%B2%B4%ED%95%A8%EC%88%98&quot; aria-label=&quot;일급 객체함수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;일급 객체(함수)&lt;/h2&gt;
&lt;p&gt;클로저는 함수를 일급 객체로 취급하는 함수형 프로그래밍 언어에서 사용되는 중요한 특성이다.
여기서 일급 객체이자 일급 함수라는 것은 다음과 같은 조건을 충족한다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;변수에 담을 수 있다.&lt;/li&gt;
&lt;li&gt;함수나 메서드의 인자로 넘길 수 있다.&lt;/li&gt;
&lt;li&gt;함수나 메서드에서 리턴할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;렉시컬-스코프&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A0%89%EC%8B%9C%EC%BB%AC-%EC%8A%A4%EC%BD%94%ED%94%84&quot; aria-label=&quot;렉시컬 스코프 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;렉시컬 스코프&lt;/h2&gt;
&lt;p&gt;자바스크립트는 렉시컬 스코프를 따르는 프로그래밍 언어이다. 자바스크립트 엔진은 함수가 어디서 호출되었는지가 아니라
어디서 정의되었는지에 따라 상위 스코프를 결정한다. 이를 렉시컬 스코프 (정적 스코프)라고 한다. 즉 함수의 상위 스코프는
함수를 정의한 위치에 의해 정적으로 결정되고 변하지 않는다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const x = 1;

function foo() {
  const x = 10;
  console.log(x);
}

function bar() {
  console.log(x);
}

foo(); // 10
bar(); // 1&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;렉시컬 환경의 외부 렉시컬 환경에 대한 참조에 저장할 참조값인 상위 스코프에 대한 참조는 함수 정의가 평가되는 시점에 함수가
정의된 환경에 의해 결정된다.&lt;/p&gt;
&lt;h2 id=&quot;environment&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#environment&quot; aria-label=&quot;environment permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;[[Environment]]&lt;/h2&gt;
&lt;p&gt;렉시컬 스코프가 가능하려면 함수는 자신이 정의된 환경인 상위 스코프를 기억해야 한다.
이는 &lt;strong&gt;함수 객체의 내부 슬롯인 [[Environment]]가 자신이 정의된 환경을 기억하고 있다.&lt;/strong&gt; 이는 해당 함수가 평가되고 있는 시점(해당 함수를
포함하는 상위 코드가 평가되거나 실행되고 있는 시점)에 저장된다.&lt;/p&gt;
&lt;p&gt;이후 해당 함수가 호출되었을 때 해당 함수의 실행 컨텍스트가 생성되고 해당 함수의 렉시컬 환경이 생성된다. 여기서 &lt;strong&gt;렉시컬 환경의
외부 렉시컬 환경에 대한 참조값에 함수 객체의 [[Environment]]에 저장되어 있는 상위 스코프의 참조값을 통해 채워진다.&lt;/strong&gt;
이러한 과정을 통해 상위 스코프를 기억하고 렉시컬 스코프를 구현할 수 있다.&lt;/p&gt;
&lt;h3 id=&quot;클로저&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%81%B4%EB%A1%9C%EC%A0%80&quot; aria-label=&quot;클로저 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;클로저&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;클로저는 외부 함수보다 내부 함수가 더 오래 유지되는 경우 내부 함수는 이미 생명 주기가 종료한 외부 함수의 변수를 참조할 수 있게 된다.&lt;/strong&gt;
이러한 내부 함수!!를 클로저라 한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const x = 1;

function outer() {
  const x = 10;
  const inner = function() {
    console.log(x);
  };
  return inner;
}

const innerFunc = outer();
innerFunc(); // 10;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;outer 함수를 호출하면 inner를 반환하고 생명 주기를 종료(실행 컨텍스트 스택에서 outer의 실행 컨텍스트를 제거)한다.
그러나 inner는 outer에서 선언된 x라는 식별자를 참조할 수 있다.&lt;/p&gt;
&lt;p&gt;이는 &lt;strong&gt;inner 함수가 평가되어 inner 함수 객체를 생성할 때
inner 함수의 [[Environment]] 내부 슬롯에 outer의 렉시컬 환경을 기억하고 inner 함수의 실행 컨텍스트가 생성될 때 렉시컬 환경의
외부 렉시컬 환경에 대한 참조에 사용된다.&lt;/strong&gt; 즉 outer의 실행 컨텍스트는 소멸되지만, outer의 렉시컬 환경까지 소멸되는 것이 아니다.&lt;/p&gt;
&lt;h2 id=&quot;상위-스코프를-기억하는-모든-함수는-클로저인가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%83%81%EC%9C%84-%EC%8A%A4%EC%BD%94%ED%94%84%EB%A5%BC-%EA%B8%B0%EC%96%B5%ED%95%98%EB%8A%94-%EB%AA%A8%EB%93%A0-%ED%95%A8%EC%88%98%EB%8A%94-%ED%81%B4%EB%A1%9C%EC%A0%80%EC%9D%B8%EA%B0%80&quot; aria-label=&quot;상위 스코프를 기억하는 모든 함수는 클로저인가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;상위 스코프를 기억하는 모든 함수는 클로저인가&lt;/h2&gt;
&lt;p&gt;이론적으로 자바스크립트의 모든 함수는 상위 스코프를 기억하므로 모든 함수는 클로저이다. 하지만, 일반적으로 모든 함수를 클로저라 하지 않는다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수 중 언젠가 자신이 실행될 때 사용할 변수들만 기억하여 유지시키는 함수다.&lt;/strong&gt; [함수형 자바스크립트 프로그래밍]&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;자신의 상위 스코프에서 알 수 있는 변수를 자신이 사용하고 있지 않다면 그 환경을 기억해야 할 필요가 없다.
자바스크립트 엔진에 따라 기억하는 경우도 있지만 사용하지 않기 때문에 메모리 낭비이다.&lt;/p&gt;
&lt;p&gt;외부 스코프에 있었던 변수 중 클로저 혹은 다른 누군가가 참조하고 있지 않는 모든 변수는 실행 컨텍스트가 제거된 후 가비지 컬렉션 대상이 된다.
어떤 함수가 외부 스코프의 변수를 사용하지 않았고, 그래서 외부 스코프의 환경이 가비지 컬렉션 대상이 된다면 그렇게 내버려 두는 함수를 클로저라
보기 어렵다.&lt;/p&gt;
&lt;p&gt;V8과 파이어폭스는 내부 함수가 사용하는 변수 중 외부 스코프의 변수가 하나도 없는 경우에는 클로저가 되지 않는다. 클로저가 된 경우에도
자신이 사용한 변수만 기억하며 외부 스코프의 나머지 변수는 전혀 기억하지 않는다.&lt;/p&gt;
&lt;h3 id=&quot;1-outer에서-a-b를-참조하기-때문에-a-b의-식별자가-관리되는-전역-렉시컬-환경이-살아있는-것인가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-outer%EC%97%90%EC%84%9C-a-b%EB%A5%BC-%EC%B0%B8%EC%A1%B0%ED%95%98%EA%B8%B0-%EB%95%8C%EB%AC%B8%EC%97%90-a-b%EC%9D%98-%EC%8B%9D%EB%B3%84%EC%9E%90%EA%B0%80-%EA%B4%80%EB%A6%AC%EB%90%98%EB%8A%94-%EC%A0%84%EC%97%AD-%EB%A0%89%EC%8B%9C%EC%BB%AC-%ED%99%98%EA%B2%BD%EC%9D%B4-%EC%82%B4%EC%95%84%EC%9E%88%EB%8A%94-%EA%B2%83%EC%9D%B8%EA%B0%80&quot; aria-label=&quot;1 outer에서 a b를 참조하기 때문에 a b의 식별자가 관리되는 전역 렉시컬 환경이 살아있는 것인가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. outer에서 a, b를 참조하기 때문에 a, b의 식별자가 관리되는 전역 렉시컬 환경이 살아있는 것인가&lt;/h3&gt;
&lt;p&gt;아니다. 전역 렉시컬 환경의 스코프에서 관리되는 전역 변수나 함수는 사용되든, 사용되지 않든 관계없이 유지된다.
즉, a, b 변수가 outer 함수에서 참조했다고 살아있는 것이 아니기 때문에 outer는 클로저가 아니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;var a = 10;
var b = 20;

function outer() {
  return a + b;

  debugger;
}

outer();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;2-inner에서-outer의-식별자를-사용하지-않아도-inner-함수는-클로저인가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-inner%EC%97%90%EC%84%9C-outer%EC%9D%98-%EC%8B%9D%EB%B3%84%EC%9E%90%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EC%95%84%EB%8F%84-inner-%ED%95%A8%EC%88%98%EB%8A%94-%ED%81%B4%EB%A1%9C%EC%A0%80%EC%9D%B8%EA%B0%80&quot; aria-label=&quot;2 inner에서 outer의 식별자를 사용하지 않아도 inner 함수는 클로저인가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. inner에서 outer의 식별자를 사용하지 않아도 inner 함수는 클로저인가&lt;/h3&gt;
&lt;p&gt;inner 함수에서 outer 스코프에서 관리되는 식별자인 a, b를 참조하고 있지 않다. 즉, inner에서 기억해야 할
outer의 식별자는 없다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function outer() {
  var a = 10;
  var b = 20;

  function inner(c, d) {
    console.log(c + d);

    debugger;
  }

  return inner;
}

var innerFunc = outer();
innerFunc(5, 7);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;3-진짜-클로저&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EC%A7%84%EC%A7%9C-%ED%81%B4%EB%A1%9C%EC%A0%80&quot; aria-label=&quot;3 진짜 클로저 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 진짜 클로저&lt;/h3&gt;
&lt;p&gt;outer가 반환한 innerFunc는 호출될 때마다 outer의 식별자인 a가 사용된다. 즉 클로저의 조건을 충족하는 함수이다.
내부 함수가 상위 스코프의 식별자를 참조하고 있고 중첩 함수가 외부 함수보다 더 오래 유지되는 경우이기 때문이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function outer() {
  var a = 10;

  function inner(b) {
    console.log(a + b);
  }

  return inner;
}

var innerFunc = outer();
innerFunc(10); // 20
innerFunc(20); // 30&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 37.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABUklEQVQoz32SbW+CMBSF+f8/a5+WZVu2ZMlUhiDyIgWFIn215ewK0bglepOTtGn79NzTBvt1A8UVnPOw1sF7j3Ec7+pcxhhkeYEda1Duqkl5UU4KbKsgS46mNuBc0naH+zUDrbUo8gys2CDebBGtE4RRjMUyRKCVR7YasF4IlJVB02qInqNjBaS0UAak8SptgUFYbPMvhJtXpOkTWP2CYXhHf3xDoLTH9yfDx/MOcdqianp05FRKA0lrt7AL8CgMkpRcJQnBSgjVQ8huUuDsCV5qykVAaXlt62HLlCFjDA1l2LY9RdXjdDpnDwIaByfpZmVhTwR348OHOZfWM5AVDbKspnEFpdS0FvA9p2BLhEuOw2FAsospIzH7uYFc5jNQT8COzva9IgNkys2PGVR5jSzeoq4EZaDBdQc/+j+A/8Dzt9mkWyzDCKufiDJUdFaREYlfmK1pCzOLMNMAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;클로저 디버거&quot;
        title=&quot;클로저 디버거&quot;
        src=&quot;/static/3ca5ca200d99f28402cac16a7b1162fa/c1b63/closure-debugger.png&quot;
        srcset=&quot;/static/3ca5ca200d99f28402cac16a7b1162fa/5a46d/closure-debugger.png 300w,
/static/3ca5ca200d99f28402cac16a7b1162fa/0a47e/closure-debugger.png 600w,
/static/3ca5ca200d99f28402cac16a7b1162fa/c1b63/closure-debugger.png 1200w,
/static/3ca5ca200d99f28402cac16a7b1162fa/1628f/closure-debugger.png 1232w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;활용&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%99%9C%EC%9A%A9&quot; aria-label=&quot;활용 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;활용&lt;/h2&gt;
&lt;h3 id=&quot;1-은닉&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%EC%9D%80%EB%8B%89&quot; aria-label=&quot;1 은닉 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 은닉&lt;/h3&gt;
&lt;p&gt;클로저는 상태를 안전하게 변경하고 유지하기 위해 사용되는데 리엑트의 useState가 클로저의 은닉 활용의 사례를 잘 보여준다.
특정 함수(useState)에게만 상태 변경을 허용하도록 하여 예상치 못한 상태 변경의 가능성을 제거할 뿐만 아니라 외부에서
지역 변수에 접근하지 못하도록 private한 지역 변수(_idx)를 통해 외부에서 참조하거나 변경할 수 없도록 한다.&lt;/p&gt;
&lt;p&gt;(리엑트의 useState를 클로저를 통해 간단하게 구현한 것.)&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let hooks = [];
let idx = 0;

function useState(initialValue) {
  const state = hooks[idx] || initialValue;
  const _idx = idx;

  function setState(newValue) {
    hooks[_idx] = newValue;
  }
  idx++;

  return [state, setState];
}

const [count, setCount] = useState(0);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;실수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%8B%A4%EC%88%98&quot; aria-label=&quot;실수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;실수&lt;/h2&gt;
&lt;p&gt;var은 함수 스코프를 가진다. 따라서 for문에서 정의된 i의 경우 전역 변수가 된다.
해당 전역 변수는 for문에 의해 0~3까지 할당된다. 이후 i를 반환하는 함수를 호출했으니, 3이 세 번 반환된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;var funcs = [];

for (var i = 0; i &amp;lt; 3; i++) {
  funcs[i] = function() {
    return i;
  };
}

for (var j = 0; j &amp;lt; funcs.length; j++) {
  console.log(funcs[j]());
}

// 3
// 3
// 3&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;즉시 실행 함수에서 반환하는 클로저를 생성하여 클로저로 하여금 즉시 실행 함수의 매개변수의 값을 기억하도록 하는 방법으로 해결할 수 있다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;var funcs = [];

for (var i = 0; i &amp;lt; 3; i++) {
  funcs[i] = (function(id) {
    return function() {
      return id;
    };
  })(i);
}

for (var j = 0; j &amp;lt; funcs.length; j++) {
  console.log(funcs[j]());
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;또한 블록 스코프를 따르는 let을 사용하면 쉽게 해결 가능하다. 다음과 같이 for문이 반복해서 실행될 때 마다 해당 블록에서 선언과 할당된
지역 변수의 값을 유지하기 위해 전역 렉시컬 환경의 선언적 환경 레코드가 새롭게 생성되어 대체된다.
이후 해당 코드 블록이 종료되면 기존의 선언적 환경 레코드로 다시 복구된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const funcs = [];

for (let i = 0; i &amp;lt; 3; i++) {
  funcs[i] = function() {
    return i;
  };
}

for (let j = 0; j &amp;lt; funcs.length; j++) {
  console.log(funcs[j]());
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;</content:encoded></item><item><title><![CDATA[함수 호출 방식에 따라 동적으로 결정되는 this]]></title><description><![CDATA[자바스크립트의 this는 함수가 어떻게 호출되는지에 따라 동적으로 할당된다. 함수가 생성자 함수로서 호출되었다면, new 키워드를 통해 새롭게 생성된 객체에 this…]]></description><link>https://youthfulhps.dev/TIL/javascript/this/</link><guid isPermaLink="false">https://youthfulhps.dev/TIL/javascript/this/</guid><pubDate>Sat, 10 Jun 2023 13:05:26 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트의 this는 함수가 어떻게 호출되는지에 따라 동적으로 할당된다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;함수가 생성자 함수로서 호출되었다면, new 키워드를 통해 새롭게 생성된 객체에 this가 바인딩된다.&lt;/li&gt;
&lt;li&gt;함수가 객체의 메서드로서 호출되었다면, 해당 메서드를 소유하는 객체에 this가 바인딩된다.&lt;/li&gt;
&lt;li&gt;apply, call, bind를 통해 함수에 전달된 thisArg 객체에 this가 바인딩된다.&lt;/li&gt;
&lt;li&gt;위 세 가지 경우를 제외한 호출 방식은 모두 전역 객체가 this에 바인딩된다.&lt;/li&gt;
&lt;li&gt;또한 중첩 구조를 가지는 함수(외부 함수의 내부 함수, 콜백 함수)의 경우도 마찬가지로 전역 객체에 this가 바인딩된다.&lt;/li&gt;
&lt;li&gt;화살표 함수의 경우 항상 자기 자신의 상위 스코프를 this에 바인딩한다. 이를 렉시컬 this라 한다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;함수-호출&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C&quot; aria-label=&quot;함수 호출 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;함수 호출&lt;/h2&gt;
&lt;p&gt;전역 객체는 모든 객체의 유일한 최상위 객체이다. 브라우저의 경우 &lt;code class=&quot;language-text&quot;&gt;window&lt;/code&gt;, 서버의 경우 &lt;code class=&quot;language-text&quot;&gt;global&lt;/code&gt; 객체를 의미한다.
전역 객체는 전역 스코프를 갖는 전역 변수를 프로퍼티로 소유한다. 글로벌 영역에서 선언된 함수의 경우 전역 객체의 프로퍼티로
접근할 수 있는 전역 변수의 메서드이다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// browser
this === window;

// server (node.js)
this === global;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;기본적으로 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;는 전역 객체에 바인딩되는데 추가적으로 다음과 같은 케이스 또한 전역 객체에 바인딩된다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;중첩된 함수 구조를 가진,&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;내부 함수&lt;/li&gt;
&lt;li&gt;메서드의 내부 함수&lt;/li&gt;
&lt;li&gt;콜백 함수&lt;/li&gt;
&lt;/ol&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function a() {
  console.log(this); // window
  function b() {
    console.log(this); // window
  }
}

var obj = {
  a: function() {
    console.log(this); // window
    function b() {
      console.log(this); // window
    }
  },
};

var obj = {
  a: function() {
    setTimeout(function b() {
      console.log(this); // window
    }, 100);
  },
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;즉, 내부 함수는 일반 함수, 메서드, 콜백 함수 어디에서 선언되었는지 관계없이 this는 전역 객체에 바인딩된다.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;메서드-호출&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A9%94%EC%84%9C%EB%93%9C-%ED%98%B8%EC%B6%9C&quot; aria-label=&quot;메서드 호출 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;메서드 호출&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;함수가 객체의 프로퍼티 값이면 메서드로서 호출된다. 이때 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;는 해당 메서드를 소유한 객체가 바인딩된다.&lt;/strong&gt;
프로토타입 객체도 메서드를 가질 수 있는데, 프로토타입 객체 메서드 내부에서 사용된 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;도 일반 메서드 방식과
동일하게 해당 메서드를 호출한 객체에 바인딩된다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;var obj1 = {
  name: &amp;#39;Lee&amp;#39;,
  sayName: function() {
    console.log(this.name);
  },
};

var obj2 = {
  name: &amp;#39;Kim&amp;#39;,
};

obj2.sayName = obj1.sayName;

obj1.sayName(); // Lee
obj2.sayName(); // Kim

function Person(name) {
  this.name = name;
}

Person.prototype.getName = function() {
  return this.name;
};

var me = new Person(&amp;#39;Lee&amp;#39;);
console.log(me.getName());

Person.prototype.name = &amp;#39;Kim&amp;#39;;
console.log(Person.prototype.getName());&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;생성자-함수-호출&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%83%9D%EC%84%B1%EC%9E%90-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C&quot; aria-label=&quot;생성자 함수 호출 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;생성자 함수 호출&lt;/h2&gt;
&lt;p&gt;기존 함수에 new 연산자를 붙여 호출한 해당 함수는 생성자 함수로 동작한다. 생성자 함수로 호출된 함수는 this 바인딩이 다르게 동작하게 되는데,
new 연산자와 함께 생성자 함수를 호출하면 다음과 같은 순서로 동작한다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;빈객체 생성 및 바인딩, 생성자 함수의 코드가 실행되기 전에 new 키워드를 통해 빈 객체가 생성된다. 이후 생성자 함수 내에서 사용되는 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;
는 생성된 빈 객체를 가리키게 된다. 추가적으로 생성자 함수의 prototype 프로퍼티가 가리키는 객체를 자신의 프로토타입 객체로 설정한다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;를 통한 프로퍼티 생성, 생성된 빈 객체에 &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;를 사용하여 동적으로 프로퍼티와 메서드를 생성할 수 있다. &lt;code class=&quot;language-text&quot;&gt;this&lt;/code&gt;는 새로 생성된
객체를 가리키므로 this를 통해 생성한 프로퍼티와 메서드는 새로 생성된 객체에 추가된다.&lt;/li&gt;
&lt;li&gt;생성된 객체 반환, 반환문이 없는 경우 this에 바인딩된 새로 생성된 객체가 반환된다. (명시적으로 this를 반환하여도 동일),
반환문이 this가 아닌 다른 객체를 명시적으로 반환하는 경우, this가 아닌 해당 객체가 반환된다. (해당 방식은 생성자 함수로서의 역할이 잠식되는
동작이기 때문에 생성자 함수에서는 명시적으로 반환문을 사용하지 않는다.)&lt;/li&gt;
&lt;/ol&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Person(name) {
  // 생성자 함수 코드 실행 전 -------- 1
  this.name = name; // --------- 2
  // 생성된 함수 반환 -------------- 3
}

var me = new Person(&amp;#39;Lee&amp;#39;);
console.log(me.name); // Lee&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;apply-call-bind-호출&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#apply-call-bind-%ED%98%B8%EC%B6%9C&quot; aria-label=&quot;apply call bind 호출 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;apply, call, bind 호출&lt;/h2&gt;
&lt;p&gt;위처럼 자바스크립트 엔진에 의해 동적으로 할당되는 this와는 달리, 명시적으로 바인딩할 수 있는 방법을 제공한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;func.apply(thisArg, [argsArray]);

// thisArg, 함수 내부의 this에 바인딩할 객체
// argsArray, 함수에 전달할 argument의 배열&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;call과 apply의 기능은 동일하지만, apply는 배열 형태로, call은 하나씩 넘긴다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;Person.apply(foo, [1, 2, 3]);
Person.call(foo, 1, 2, 3);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;bind의 경우 ES5에 추가되었다. 함수에 인자로 전달한 this가 바인딩된 새로운 함수를 반환한다. 즉, apply, call과의 차이점은 바로 함수가
호출되는 것이 아닌 함수를 반환받는다는 점이다.&lt;/p&gt;
&lt;h2 id=&quot;화살표-함수&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%99%94%EC%82%B4%ED%91%9C-%ED%95%A8%EC%88%98&quot; aria-label=&quot;화살표 함수 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;화살표 함수&lt;/h2&gt;
&lt;p&gt;화살표 함수의 경우 ES6에 새롭게 추가되었다. 일반적으로 함수는 어떻게 호출되었는지에 따라 this에
바인딩할 객체가 동적으로 결정되는데, 화살표 함수의 경우는 다르다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다. 이를 렉시컬 this라고 한다.&lt;/strong&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Prefixer(prefix) {
  this.prefix = prefix;
}

Prefixer.prototype.prefixArray = function(arr) {
  // this는 상위 스코프인 prefixArray 메소드 내의 this를 가리킨다.
  return arr.map(x =&amp;gt; `${this.prefix}  ${x}`);
};

const pre = new Prefixer(&amp;#39;Hi&amp;#39;);
console.log(pre.prefixArray([&amp;#39;Lee&amp;#39;, &amp;#39;Kim&amp;#39;]));&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이러한 특성 때문에 화살표 함수의 사용을 피해야 하는 몇 가지 경우가 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;메서드에서 화살표 함수를 사용하면 메서드를 소유하는 객체를 this에 바인딩하지 못하기 때문에 동작상 적절하지 않을 수 있다.&lt;/li&gt;
&lt;li&gt;프로토타입의 메서드를 선언할때도 메서드와 동일한 문제가 발생한다.&lt;/li&gt;
&lt;li&gt;화살표 함수는 생성자 함수로서 사용할 수 없다. 화살표 함수는 prototype 프로퍼티를 가지고 있지 않다.&lt;/li&gt;
&lt;li&gt;addEventListener 함수의 콜백 함수를 화살표 함수로 정의하게 되면 this가 상위 컨텍스트인 전역 객체 window를 가리키게 된다.&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[2023 상반기 회고]]></title><description><![CDATA[벌써 202…]]></description><link>https://youthfulhps.dev/essay/2023-first-half-retrospect/</link><guid isPermaLink="false">https://youthfulhps.dev/essay/2023-first-half-retrospect/</guid><pubDate>Sun, 14 May 2023 01:05:26 GMT</pubDate><content:encoded>&lt;p&gt;벌써 2023년 상반기가 지나갔다. 정말 정신없이 시간이 빠르게 흐르는 것 같아, 지나간 시간에 대한
회고와 함께 남은 하반기에 대한 목표 정리와 계획을 간단히 정리해 보려 한다.&lt;/p&gt;
&lt;p&gt;사실 회고록을 적겠노라 시도한 적이 여러 번 있었지만 투박한 글 솜씨와 밋밋한 인생사에 접었던 적이 많았는데,
이번 상반기는 더 바쁘고 엄격하게, 그럼에도 더 행복한 하반기를 시작하기 위한 세이브 기점으로 나쁘지 않은
단락이었던 것 같아 기쁜 마음으로 첫 회고록을 남긴다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 57.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAADGUlEQVQozx2Q20/bBRTH+6JG9+QUXbJMw1QMbmOjrIA0XbiDBUnD2qIOSrl2pdCO0vsN6YW20NGOwuhWBowiK1e1JcJgI7oZt/hofNS9+OyD+gd8/GUPJznJOef7/ZyvyGruY1B/DcNQJzrdl3T3qtBor5IYH+K7BR/7K0EeroZ4uj3LD/cnmRrVYmiSkXTr2F8KkEt5OBLmR5lJHgq7oqEb/eiMPRiMWkaM3dgt/WTnvByuhMkv+nkQt7N208a010hUKHOnAle/+qXBj9kZDlZCHGbCgrif3TkHIpNzGJPDgGlsgLmwmZ0FL7u3vWRvOTnKzpNLh1gKG7H2ttHWWEW3Sk7crufRWoS9e34OV6P8tJngeD0miE8ickxYGfOOYrAb8Nv6WIuY2BYI9+4FuROxMWEzEHbqCVh6UNRIOIhs8F/+L/75/k+eZZfZue1iUzDfmnUL3wiEoaiTxaSPhbiL+9ERNmIjZMJDAoWGmE2D/qtmlAo53oCbJ7YtSP3L35k/yChn+HV0k4NMhHzaz6NvptlfFgjnxnXM+wbJRE3k7vh4vDbJsRBwXuifPggSs1yjvrKYemkpSwU+ds7e5HFgh610iifJLX75Ns3xRkK4HWcvPYEobu0m4ewlMtrJLdcAd0NGtoUMd1Nfsz6lJ3fXzYxHR7u8nN6TdTheU1N7SsKL1d958fw3pv120skpluNe8ktRRKtTZraTbhYDw6jrytDKSumSXUJbeY7BGjEhdSMeZT1jcinKmjLkb4uRnirGeVnHz7YcQY+N6vJPaKkpR91agyhm0TDr7GNl0oiyuYLzr75C/VtvUv3GCZrfLeCz108IIifpPHuGjgYJtVfESCouIa0Sc/79QlxWC/N+M57rV1E3ShAZvmjC1NWCo0/xslTVpaiqSmiXnKOp5EPaxMVIi96j/HQB9Z9epLXuCiVFhVz46AxFhe/QLLvMYvAG6wkHmRk7olmXkN+YBlt/O4OqBuzXVUQF4lTAgE3Tgm9AgUxSzOe1FTRUXaTiwgd0tcqoLvsYVUMl4VENQUMHgeEOZuw9/A+uLgXpJjWO0QAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Save flag for Alt F42 game&quot;
        title=&quot;Save flag for Alt F42 game&quot;
        src=&quot;/static/e085041a6a7bd2b0812cfec93dbd2fd9/c1b63/save-point.png&quot;
        srcset=&quot;/static/e085041a6a7bd2b0812cfec93dbd2fd9/5a46d/save-point.png 300w,
/static/e085041a6a7bd2b0812cfec93dbd2fd9/0a47e/save-point.png 600w,
/static/e085041a6a7bd2b0812cfec93dbd2fd9/c1b63/save-point.png 1200w,
/static/e085041a6a7bd2b0812cfec93dbd2fd9/64639/save-point.png 1568w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;개인-프로젝트-gitglances&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B0%9C%EC%9D%B8-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-gitglances&quot; aria-label=&quot;개인 프로젝트 gitglances permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;개인 프로젝트; GitGlances&lt;/h2&gt;
&lt;p&gt;22년 10월 말, ‘오늘의 깃헙 로그를 한눈에 볼 수는 없을까?’ 라는 개인적인 니즈로 시작된 프로젝트로
올해 3월 말 v2.1.1 릴리즈 버전으로 목표했던 크롬 익스텐션을 배포했다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 49.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABxklEQVQoz2VSSY7bQAz0KQkw1tabpNbW2qzAii17BolPmUOCAeL/P6hCti3YwBwoUFyKrGJvhBCI4xgJW5Lc7e4LNgHxZGuN9++98VPvhj/WWqRpBqUNtJIwJoORBjIikJAKQx74AFqXEBTLqNeWFkppH99womkaONeiLCvUdY3C1XCvE/IfDuJ7DrWzyKkxz3MPKqVEluVwjfP1bddSzt42lEIiJsc5h+PxiNPxhGbuoT9G6L8D1MeA4XpC3Tm0VMNslFZo2w6/399xuVywLAumaUIUxdiEQYD96xuGw4JvX78geAmgXI703wT9p0d5nbG7npERLaM1NBmzKooCXdf7TdM0pbi5UY6iCCOh//x1oaktlFTQRQZ77mDmCsXSoj6QT01KKU9XEmhOgBVJZIzx+vMgD8jXtVWJeZ6RUSKkAZoEzlSK6CVEvI3wVjU+568eRhB9hbR3KGg7HsJAPOgGSPqxoKwhC9z3PV2txDDtcCBN+RCCgBoSfhjHW6MUvqeuW6Jek188KK/oLPZ+v8f5fIIj6iWBjwTAGiWJgCWKLWnGA1aaaWY9kNZPGq5vi4UOwxDbbQDWNSbj/+c8xx+P/7Nx3X/5cAGtwOzq3wAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Git glances app view&quot;
        title=&quot;Git glances app view&quot;
        src=&quot;/static/ce68ca638d873dbdad38db1221c7afde/c1b63/git-glances.png&quot;
        srcset=&quot;/static/ce68ca638d873dbdad38db1221c7afde/5a46d/git-glances.png 300w,
/static/ce68ca638d873dbdad38db1221c7afde/0a47e/git-glances.png 600w,
/static/ce68ca638d873dbdad38db1221c7afde/c1b63/git-glances.png 1200w,
/static/ce68ca638d873dbdad38db1221c7afde/21b4d/git-glances.png 1280w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;아침에 출근하면 습관적으로 깃헙을 살펴보면서 읽지 않은 알림이나, 오늘 핫한 저장소는 어떤 것이 있고,
작업이 끝나거나 공부를 마무리하고서는 오늘의 기여도나, 매일 커밋을 목표로 하고 있는 TIL 저장소의 커밋을
확인하며 스스로 자극을 구하곤 했는데, 생각보다 깃헙을 서핑하는 데 오래 걸린다는 단순한 이유가 동기부여이다.&lt;/p&gt;
&lt;p&gt;훌륭한 접근성을 가진 크롬 익스텐션으로 한 번이라도 더 로그를 흘겨 보면서 고군분투하고자 했던 결과물이자,
스스로 기술 스택에 대한 궁금증을 풀기 위한 제품이다. 아직 남은 이슈 티켓도 많고, 개선할 여지가 충분한 만큼,
하반기에는 더 나은 제품으로 강화해보고 싶다.&lt;/p&gt;
&lt;p&gt;개인 프로젝트에 대해 첨언한다면, 완벽보다는 완성을 목표로 했던 것이 유효했다. ‘아, 좀 못생겼는데 스타일
수정해 볼까’ 하면 하루가 가고 목표했던 기능 개발은 시작도 못한 채 지친다. 항상 한 단락이 마무리된 동작하는
제품으로 오늘 개발을 끝맺어놔야 다음 개발할 때도 새롭게 시작하는 마음으로 힘이 생겼다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACGklEQVQoz3WS+0/aUBTH/f+X/WKW4GKMjyyZ2djmRoz4yNAQdQoTC0jloUItjxVtaQsthZbPbosSnNlJmtx7zj3fnu/3exYmkwlhWKaJqrZptlqonQ4+TyHqkyCIvv9G+OYJZ+H5oGkaqWScX/Ev/N5KoOQl1PIl8zDNVoX+g8bY6OHW7+nks7Tv5RegM0Bv6HKdT+Faveiu18oUtz9hX0j0r2TsfBHp4zKd8zOcugIjn2x6n8TXD3ODzgGOx2N2Dw5wBwPcR5305zjFnT3SK2tYxRKZtQ2O3y1xuLyCksmiXZVIrq6zFXvP0da3GegMMBAaud6QkdrCzOaoX+Ro3d6h21ZUfzB0ytWKyN0y6HbR5WuuT09pNhpo7fbrCU1hiizLFAoFur0p7eHII/ADRt4IXzAIWYSajnyfcahZyEzUA3EO/jWl37cplQooyj1ap41t6dO8bdIztCedB5jGH+H4tGfo2Dx21Yjd3ITTi9a+RTpLROe76iWX5zuEfbVylpJ0FOWV+hW5zN5Mr/qdTPZs/9mSl5R9f4zZM6K/Oc6Am1o1ylcLeaRMJnrcajY5TO5SEdIEgr4m2OROTtFU9bWGHbHQ6Z8pQc+gJhrOj09oKAqrb96yEVui3lBYWlxkPRZj+/sPKpJEYn2Ng81NTpLJ1y47joMhwMIwdJ2hO8QTZnSFo5ZlRZOHpoSGRFshpDKF7o7nMZnbw79Z7DRMCG5eIQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Making sense of MVP&quot;
        title=&quot;Making sense of MVP&quot;
        src=&quot;/static/7aa3c4d3f75932571c2232cbb4a99dbe/c1b63/mvp.png&quot;
        srcset=&quot;/static/7aa3c4d3f75932571c2232cbb4a99dbe/5a46d/mvp.png 300w,
/static/7aa3c4d3f75932571c2232cbb4a99dbe/0a47e/mvp.png 600w,
/static/7aa3c4d3f75932571c2232cbb4a99dbe/c1b63/mvp.png 1200w,
/static/7aa3c4d3f75932571c2232cbb4a99dbe/89048/mvp.png 1242w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;
&lt;a href=&quot;https://blog.crisp.se/2016/01/25/henrikkniberg/making-sense-of-mvp&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MVP 프로젝트를 기획하는 방식에 대해 잘 표현한 그림을 다시금 꺼내보며, 스케이트보드 단계의 제품을 다운로드
해주신 8분께 감사드린다. (그렌절)&lt;/p&gt;
&lt;h2 id=&quot;앓고리즘&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%95%93%EA%B3%A0%EB%A6%AC%EC%A6%98&quot; aria-label=&quot;앓고리즘 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;앓고리즘&lt;/h2&gt;
&lt;p&gt;정말이지 알고리즘 공부는 꺼내들기 쉽지 않았는데, 성장 그래프의 가파른 경사는 도대체 어디 있는지 성취감을 느끼기
쉽지 않은 카테고리가 아닌가 싶다.&lt;/p&gt;
&lt;p&gt;사실 코딩 테스트를 준비하기 위해 알고리즘 공부를 하는 건 구직 과정에서 가성비가 너무 떨어지더라는 이야기를 자주
듣곤 했는데, 이상하게 이 조언이 알고리즘을 공부하고 싶게 만든 동기부여가 됐다. 정말 이상하게도 가성비가 떨어진다는
조언을 해준 사람들 목소리에 후련한 뿌듯함(?)이 묻어있다고 느꼈다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 53%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAADCklEQVQoz22TXUybdRTGX2CjoEJLYaxDxSVuM45uLS3YD0qhA/oBpR9vKf0YMBgwOr66BlpAAxPYsrkVFJhMjNNpdJkxQWOMMcaYYVyWcKHTLMuShcxlM3Hbjbfu5rc3IyZeePFLnpz/ycnJeZ6/kJGRgSAIT/mv3iTjf2qbff/Wn8krJmtrrqQzN9/3qHXs2rsfrbEKi72JF14uQ1H4PLvLtBxo9FJpqeeArYHysr2Izlo8bhf9wQZmDrkYC1mZ6GwhEfUzGm3mSGMFQpnezL5KE1ZHM6Y6NwXbdlJUvBNVSSkv7d5Htd1Li8dH2OdnKjVCem6OldkkF5IRFocDLCcCLMT9LA97mWmrQVCr9aj3V2C1uaiSeE5eQtH2UrZm57Lr1XKGjo0T9flodjg5fSrN2pUrfP/5Jyyn2nknvjnsfCrK0oCbNztsCHptJRXa17DZnNIAHcqiF1EoSxgcSLG+dp0/bz3k3s2/WHprieTIOCvn0qycneb96WMsjHVxZrCFswMi80c9THXaEerqXTgkYkNxvOGD0mFlVFvsXPtunY31P7j/2yP+vvMPjx/AZ+99yuLxFJPS1o11TuqrbRg0WswS1ToNFgmhuyvG4Y5eRkdf59K3X6Mq3UNPxyAXZt/m45OL/HjxS3795iq3137nxtoNvnj3Mnd/3kC1TUVOdjbyZ/PYIjlca64i5mtEcDpE2qPdpJKTfHD5ErVNHsTmEG/0DjEWaed4W4T5/hg/XFxlfuY8w9E+Nr76iYg7hJAlo0BeSKawBW+Tj9TBAEKBcgc1VjuxWILDPQOkxqc4OXOGsNNHsNZOp9NFq8VIItjKbFcnqx+tko5PMNGfIE+xA1lOPrLcAtSvqBlqsiLI8wvRSMZ4/CF6+wY5t7DCiek5etp6CbpFRtoOMRkN0l1fxYfpRa7/co/+I6PE+45ilTKqVKqkYOdhkXKcFCVTMjOzkMlyMJnMWK01BMQAGk05fr8oaRFHQwNupwNDhQ6T0UyoNUwkHEWv02M0GDEYDE9/iUKuoFiezxM41a2VR2+bAwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;A scene from &amp;quot;Kim Egg&amp;#39;s Motivation&amp;quot; on YouTube&quot;
        title=&quot;A scene from &amp;quot;Kim Egg&amp;#39;s Motivation&amp;quot; on YouTube&quot;
        src=&quot;/static/9302339b3308ae17cfaa941e77818189/c1b63/motivation.png&quot;
        srcset=&quot;/static/9302339b3308ae17cfaa941e77818189/5a46d/motivation.png 300w,
/static/9302339b3308ae17cfaa941e77818189/0a47e/motivation.png 600w,
/static/9302339b3308ae17cfaa941e77818189/c1b63/motivation.png 1200w,
/static/9302339b3308ae17cfaa941e77818189/d61c2/motivation.png 1800w,
/static/9302339b3308ae17cfaa941e77818189/97a96/motivation.png 2400w,
/static/9302339b3308ae17cfaa941e77818189/db806/motivation.png 3424w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;
&lt;a href=&quot;https://www.youtube.com/watch?v=Qd1MBEhkWU8&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;그래서 다시 시작했다. 나도 언젠가 이제 막 코딩 테스트를 준비하는 분을 만나게 된다면, 뿌듯하게 뱉어보고 싶다.
그때까지는 반클러치 딱 잡고 가파른 경사를 이 악물고 기다리는 게 맞다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 20.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAnElEQVQY05WMzQqCQBgAff8X6N6fRuETRNShJwgppA5BqZQmuivS7n5OSfeogWFu46VpRhRFxPsD+yRhq26cmzs9Hf/jtU1NWWRUZUGuK466oLb6fRNEHE76ftc5wRiLdQ7PphtMPEAuM7j6kPp02RTKMaddwMgPmS1Cgvl3h5OA5WqNp6oHTZ0jRtFZhdhPEYV5apTSaP2bbdvyAoq5KX2nGb/LAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Ranking of Baekjun Algorithm&quot;
        title=&quot;Ranking of Baekjun Algorithm&quot;
        src=&quot;/static/83ef27a68cf696654b0f4060f0b332ed/c1b63/baekjoon.png&quot;
        srcset=&quot;/static/83ef27a68cf696654b0f4060f0b332ed/5a46d/baekjoon.png 300w,
/static/83ef27a68cf696654b0f4060f0b332ed/0a47e/baekjoon.png 600w,
/static/83ef27a68cf696654b0f4060f0b332ed/c1b63/baekjoon.png 1200w,
/static/83ef27a68cf696654b0f4060f0b332ed/d61c2/baekjoon.png 1800w,
/static/83ef27a68cf696654b0f4060f0b332ed/97a96/baekjoon.png 2400w,
/static/83ef27a68cf696654b0f4060f0b332ed/22284/baekjoon.png 2428w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이렇게까지 넋두리 적었는데 플레5까지 집중 못하면 김계란님 헤어스타일 따라가는 건 더 맞다.&lt;/p&gt;
&lt;h2 id=&quot;헬스와-탈장&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%97%AC%EC%8A%A4%EC%99%80-%ED%83%88%EC%9E%A5&quot; aria-label=&quot;헬스와 탈장 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;헬스와 탈장&lt;/h2&gt;
&lt;p&gt;헬스를 꾸준히 해오긴 했는데, 올해 초부터 다시 열심히 했다. 3월에 계획해둔 배트남 여행에서 나시를 입겠다는
목표, 그리고 등으로 대화하며, 잘 커팅된 팔뚝을 탑재한 채 멸치 탈출을 선언하고 싶었다. 꽤나 개운한 땀을 흘리며
술자리 대신 헬스장을 택했다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1125px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 76.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAwAC/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAASNhl3LH/8QAGxAAAQUBAQAAAAAAAAAAAAAAAgABAxESISL/2gAIAQEAAQUC30ZbWkWAJm8jHHX/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPwFH/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8BV//EABsQAAIDAQEBAAAAAAAAAAAAAAABAhEhQSJR/9oACAEBAAY/AqXXwuX2jyXDJNDTmtMcj//EABkQAQEBAQEBAAAAAAAAAAAAAAERACFBMf/aAAgBAQABPyFM82DkEOBWtlcyXRCKevuksHgH7hcO983/2gAMAwEAAgADAAAAEDsP/8QAFREBAQAAAAAAAAAAAAAAAAAAECH/2gAIAQMBAT8Qg//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/EBY//8QAGxABAQEBAQEBAQAAAAAAAAAAAREhADFBodH/2gAIAQEAAT8Qq0IoXW5P52lCRVtt1z5yVeHZHfzklEcIy8XnOiIpQ2tDzrEvQCL99e//2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;The scene where I work out my lower body&quot;
        title=&quot;The scene where I work out my lower body&quot;
        src=&quot;/static/1fbfb95284ec3386addb6c21645531a3/ec605/training.jpg&quot;
        srcset=&quot;/static/1fbfb95284ec3386addb6c21645531a3/f93b5/training.jpg 300w,
/static/1fbfb95284ec3386addb6c21645531a3/b4294/training.jpg 600w,
/static/1fbfb95284ec3386addb6c21645531a3/ec605/training.jpg 1125w&quot;
        sizes=&quot;(max-width: 1125px) 100vw, 1125px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;퇴근 후 꾸준히 헬스장을 다니던 6개월 정도가 되던 시기에 하체 운동 빈도를 늘렸다. 친구 벨트를 빌려 기세 좋게
무게를 치고선, 다음날 하체에 배긴 알에 뿌듯함을 느꼈다. 다만, 알 배긴 것이 아닌 것이 있었는데 바로 탈장이었다.&lt;/p&gt;
&lt;p&gt;회고록을 작성하고 있는 시점 2주 전 정도에 처음 탈장이라고 의심이 들었고, 어제 수술을 마치고 아무래도 개발하긴
힘들어, 회고록을 끄적이고 있다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1162px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 52.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACoElEQVQozyWSS2/bZhBFtQ+QZbsrkE26KrooigRoAxiNE9Sy0lgvP2RLVEWJtF6kSEp0KJG0KNEPWrYsxXZlt0mTxmgQ5LVKF/kL3bb/5+RLspjFAIMzd+6d2Cy02Du1Gf0V8ezRlIvZPqOBzsivUSsu8c31r8in5okchYFZpG/k6Wkr2NUkpnKPenERJXcXt12l2/qV2KHfEACNUaAx9uscbou+3+Bkr8PdW99x7eoV7tz4lpFXZdeuEFgSfmuNbiOLvZlEl+9RkxbYakr09AKxYwGcbmtMA5PpwGI8NAjsTfTKMtk7N2n89D2enKK4Gqe9ucxOT8E31nG15U8qO2oKrZSga8h4pkxsImBHQRPTlzn2VY68Csn4z0hSnaW0wtdffoGiOHTsAWFPJdyS6FtFXP2jygzllXnUfByvLRaZpc/AcV9nKE4d2mUxmBdq7uOFjwmn7ykVHRrO35jBK9zoOVEUEbQL+PoGlpIS/s5RLyRwLRXfKouTt5tMtnWmfZODfotgS6W0FqfR8jm9/Jc/XvyP6T5lpTQk9A6JRo8I/Q5ufVmEEaeWX8QU9nTUVUz5PrGx3+QjdCygB24do5ImMX+TdGadjneBoYW0simGpRxj4ZVes3DaDQwlTTr+I12zwcXpb8yOD0VFnxX2zQKdWo6WnGH1lzluz90mnsiyITWp1jxOzt9Rbe5QEkvevv+PwHUoZ+dYWbghPsIWoF3Oj3eYjXeI7T1QKW8kySwtkMsmiM//wGIiQ269iNE0eHz+hNcv/6HviVDcB/x5NmESOkyHlngxi4eRz2R/gLSW5OhAAPfdFh1NxWzK9GyNzYrE6to6xYLMnmsydAwGXZOjgYNrm5ydzIh2d3nz8jWz0zN+n824fPJUhOpx+eySD+NP0hkVp4wJAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Kim Jong-kook is waiting for hernia surgery&quot;
        title=&quot;Kim Jong-kook is waiting for hernia surgery&quot;
        src=&quot;/static/8f874b9d9182233275bc448007fb40ac/84bf8/kimjongkook-1.png&quot;
        srcset=&quot;/static/8f874b9d9182233275bc448007fb40ac/5a46d/kimjongkook-1.png 300w,
/static/8f874b9d9182233275bc448007fb40ac/0a47e/kimjongkook-1.png 600w,
/static/8f874b9d9182233275bc448007fb40ac/84bf8/kimjongkook-1.png 1162w&quot;
        sizes=&quot;(max-width: 1162px) 100vw, 1162px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;‘스쿼트 한 200 쳤어? 김종국도 탈장 수술 했다더라.’ 라는 이야기에 정말 스스로 어이없고 웃겼다.
탈장이 터지는 임계치라는 것이 달라도 너무 달라서 정말 민망하고 웃긴 해프닝이다. 그래도 꾸준히 해왔던 운동을
몇 주 쉬어야 한다는 말에 갓종국님이 슬퍼하셨는데, 파렴치하게도 공감한다.&lt;/p&gt;
&lt;h2 id=&quot;다낭&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8B%A4%EB%82%AD&quot; aria-label=&quot;다낭 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;다낭&lt;/h2&gt;
&lt;p&gt;마스크를 쓰는 것이 어색해질 줄은 몰랐다. 그리고 해외여행은 정말 행복했다. 회사 슬랙은 항상 시끌시끌하고 리액션이
좋아 카톡만큼이나 습관적으로 들어가 이슈는 없는지, 재밌는 일은 있는지 연차인 날에도 들여다보곤 했는데, 다낭에서
만큼은 보지 않기로 마음먹었다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;과거와 미래를 철문으로 닫아버리고, 오늘이라는 공간에서 살아가라., ‘데일 카네기 자기 관리론’ 중&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;다낭에서는 나름 잘 지켜냈다. (배포하는 날, 한번 봤다.)&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1080px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 133.33333333333331%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAbABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAMEBQL/xAAWAQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAcS6Sk1jJMXhrmkpeW//xAAaEAACAwEBAAAAAAAAAAAAAAAAAQIDERAS/9oACAEBAAEFAiFSHIwjPB3PayHrXWIXP//EABYRAQEBAAAAAAAAAAAAAAAAABEAEP/aAAgBAwEBPwE0v//EABgRAAIDAAAAAAAAAAAAAAAAAAABAhAR/9oACAECAQE/AXIy/wD/xAAaEAACAwEBAAAAAAAAAAAAAAAAEQECIDFx/9oACAEBAAY/Ah2l+Y4JMk7bH//EABwQAQACAgMBAAAAAAAAAAAAAAEAESExQWFxUf/aAAgBAQABPyGVzwIIaKANfIYSrnJxNVh2S1iza6gAJWKiXwQk1v2OGp//2gAMAwEAAgADAAAAEFg+/P/EABcRAAMBAAAAAAAAAAAAAAAAAAABERD/2gAIAQMBAT8QQpMf/8QAFxEAAwEAAAAAAAAAAAAAAAAAABARUf/aAAgBAgEBPxDBqf/EAB8QAQEAAgEEAwAAAAAAAAAAAAERACExQWGBkVGx0f/aAAgBAQABPxAcsFQJqPL+e8AQQA4E4MphOryAajm+3jWxco1KKqe2SgFMW7nJ8OVYS2Fs84IYGmYDi3F9YqgIdu2f/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;A scene from a trip to Da Nang&quot;
        title=&quot;A scene from a trip to Da Nang&quot;
        src=&quot;/static/6b2adb69219333ca5a417e3b08611c6f/47311/danang.jpg&quot;
        srcset=&quot;/static/6b2adb69219333ca5a417e3b08611c6f/f93b5/danang.jpg 300w,
/static/6b2adb69219333ca5a417e3b08611c6f/b4294/danang.jpg 600w,
/static/6b2adb69219333ca5a417e3b08611c6f/47311/danang.jpg 1080w&quot;
        sizes=&quot;(max-width: 1080px) 100vw, 1080px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;입사-1주년&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%85%EC%82%AC-1%EC%A3%BC%EB%85%84&quot; aria-label=&quot;입사 1주년 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;입사 1주년&lt;/h2&gt;
&lt;p&gt;4월 25일부로 입사 1주년이 되었다. 입사 동기 만큼이나 포부있는 경험을 쌓았는가.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1114px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 16.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAvElEQVQI1xWN21KDMAAF+xVOoVZoE0yAkJAECbda9EH//4tWfNsze2b29GF79m0nfq/EMfF7cJo3YggMcWP0nwxp42Gf/ISJtMy0YcfHifH4K6VpqxuqcVSq4fSlLEk7uvkQpmMRDWNnCaYh1iuuXkjuwbPfGQZN8JZcrUjVHVFPozWTEfTDjLGek6967L+sJK0waGmZXEsjWpx0XO+C4iapyzuiMsj3liy/kL8WnPOC7FLykpecs+ux3/gDsDpbj+ouM1sAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;First anniversary slack message&quot;
        title=&quot;First anniversary slack message&quot;
        src=&quot;/static/8a9a0c3f7a66fcaef866b30a79343876/cd536/first-anniversary.png&quot;
        srcset=&quot;/static/8a9a0c3f7a66fcaef866b30a79343876/5a46d/first-anniversary.png 300w,
/static/8a9a0c3f7a66fcaef866b30a79343876/0a47e/first-anniversary.png 600w,
/static/8a9a0c3f7a66fcaef866b30a79343876/cd536/first-anniversary.png 1114w&quot;
        sizes=&quot;(max-width: 1114px) 100vw, 1114px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;충분한 비즈니스에 대한 이해가 선행되어야 할 것, 이를 토대로 우리가 제공하는 비즈니스를 사용자 관점에서
바라보고 개발할 것, 그러기 위해 사용자와 더 가까워질 것.&lt;/p&gt;
&lt;p&gt;사용자 관점이라는 키워드와 친해지고 싶었지만, 막상 개발자로서 실제 제품을 개발하다 보니 개발 관점에 갇혀 오히려
시야가 좁아지고 있다는 느낌을 받을 때가 많았다. 그럴 때마다 한창 개발 공부를 하던 시절 친구들에게 개인 프로젝트를
보여주면서 여러 유명 앱들과 어떻게 다른지 팩트 폭행 당하며 개발하던 동기 충만한 시기가 떠올랐다.&lt;/p&gt;
&lt;p&gt;그래서, 무식하지만 물리적으로 사용자 옆에 있을 수 있는 공간 플랫폼 비즈니스 모델을 가진 회사에 개발자로 입사했다.
잘 사용하고 계신지, 혹은 실제로 어떤 불편함이 있는지 직접 여쭤볼 수 있었다. 추상적이고 정답이 없게 느껴지는 사용자
관점을 나름대로 경험하고 알아가고 있는 중이다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 600px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 65.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHrzspgwf/EABsQAAEEAwAAAAAAAAAAAAAAAAEAAhESEBMh/9oACAEBAAEFArytraAyFzH/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAACAwEAAAAAAAAAAAAAAAAAAQIRMRD/2gAIAQEABj8ClSwcnaEzDOf/xAAbEAACAwEBAQAAAAAAAAAAAAAAAREhMVFB8P/aAAgBAQABPyFV9MSRqlLq00y16SpfR8NjvKP/2gAMAwEAAgADAAAAEJPP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGxABAQADAQEBAAAAAAAAAAAAAREAITFRQXH/2gAIAQEAAT8QuCCxPnWZ8KO6fj3IvBYIuC6FDW9w3q3bBUMV0ANQz//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Technical debt&quot;
        title=&quot;Technical debt&quot;
        src=&quot;/static/7667859191c6069617f7ce6e3cd0dcac/b4294/technicaldebt.jpg&quot;
        srcset=&quot;/static/7667859191c6069617f7ce6e3cd0dcac/f93b5/technicaldebt.jpg 300w,
/static/7667859191c6069617f7ce6e3cd0dcac/b4294/technicaldebt.jpg 600w&quot;
        sizes=&quot;(max-width: 600px) 100vw, 600px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;
&lt;a href=&quot;https://christierney.com/2015/12/04/technical-debt-in-an-image/&quot;&gt;이미지 출처&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;덩달아 함께 개발하는 팀원들의 개발 경험에 대해 여전히 고민한다. 입사 후 내가 쳐낼 수 있는 부채들을 덜어보려 노력했고,
개선 POC를 정리해 디스커션을 열기도 했다. 머지된 것도 있지만, 반려된 것들도 많았다. 내가 개선하고 제안한 개발 환경과
구성의 사용자는 팀원이다. 팀원이 곧 사용자라는 걸 항상 상기하려 한다.&lt;/p&gt;
&lt;h2 id=&quot;독서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8F%85%EC%84%9C&quot; aria-label=&quot;독서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;독서&lt;/h2&gt;
&lt;p&gt;자기 전 잡히는 대로 골라 쌓아두고 읽고 있다. 하반기까지 완독이 목표인데, 사실 핸드폰이 가장 잘 잡히고 그립감이 좋다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 46.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAGQAAAgMBAAAAAAAAAAAAAAAAAAUBAgME/8QAFgEBAQEAAAAAAAAAAAAAAAAAAgAB/9oADAMBAAIQAxAAAAG+nSoKkUm3/8QAGhABAAMAAwAAAAAAAAAAAAAAAgABBAMRMf/aAAgBAQABBQIBGlyWItS7qbPZ/8QAFhEAAwAAAAAAAAAAAAAAAAAAAAER/9oACAEDAQE/AUqQ/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAHhAAAAQHAAAAAAAAAAAAAAAAAAEQERITITJxgZH/2gAIAQEABj8CaUWRaQpDxNJ//8QAHBABAAIBBQAAAAAAAAAAAAAAAQARICFBUYGx/9oACAEBAAE/ISdhNwX7DNT6Jwhgr//aAAwDAQACAAMAAAAQ/wAf/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIf/aAAgBAwEBPxBbaQf/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPxBZ/8QAHRAAAgEEAwAAAAAAAAAAAAAAAAERITFxsUFhof/aAAgBAQABPxCJvKt2yODTNI16JQVOyFiwa22I/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Books I started reading in the first half of the year&quot;
        title=&quot;Books I started reading in the first half of the year&quot;
        src=&quot;/static/365cdee80c701c7e394830ac9ec86279/e5166/book.jpg&quot;
        srcset=&quot;/static/365cdee80c701c7e394830ac9ec86279/f93b5/book.jpg 300w,
/static/365cdee80c701c7e394830ac9ec86279/b4294/book.jpg 600w,
/static/365cdee80c701c7e394830ac9ec86279/e5166/book.jpg 1200w,
/static/365cdee80c701c7e394830ac9ec86279/63c98/book.jpg 1392w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;하반기-목표&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%95%98%EB%B0%98%EA%B8%B0-%EB%AA%A9%ED%91%9C&quot; aria-label=&quot;하반기 목표 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;하반기 목표&lt;/h2&gt;
&lt;p&gt;더 다치지 않고 꾸준히 운동할 수 있고, 상반기 때 벌려놓은 일들을 잘 마감할 수 있는 지속력을 구하고 싶다.
더 욕심 내보면, 한동안 리엑트 동시성이 궁금해 관련 레퍼런스를 찾아보고 소스 코드를 들여다보면서 나름대로
톺아봤는데, 결론은 바닐라 자바스크립트와 영어에 더 친숙한 사람이 되고 싶다는 생각이 들었다.&lt;/p&gt;
&lt;p&gt;리엑트팀이 동시성 기능을 구현하기 위해 로우한 레벨에서부터 패키지를 업데이트했는데, 관련 PR들에서 구현체에
대한 구체적인 개념들을 설명해 주고 있고, 이슈 티켓들이 직면한 문제들과 고민거리들을 가까이 보여주고 있다.
까막눈으로 살기엔 너무 아까운 내용들이다. 더 열심히 사는 연습을 할 수 있다면, 자바스크립트와 영어를 꾸준히
공부할 수 있는 시작점이 될 수 있으면 좋겠다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[긴급한 작업에 낮은 우선순위를 부여하는 리엑트 훅]]></title><description><![CDATA[…]]></description><link>https://youthfulhps.dev/react/concurrent-feature-hooks/</link><guid isPermaLink="false">https://youthfulhps.dev/react/concurrent-feature-hooks/</guid><pubDate>Mon, 24 Apr 2023 13:05:20 GMT</pubDate><content:encoded>&lt;p&gt;리엑트 동시성 기능을 공부하면서 어렵고 복잡한 메커니즘이지만, 결국 사용자 경험을 개선하기 위한 목표들을 추상화해서
기술적으로 풀어낸 결과물이라고 생각하면 꽤나 여운이 남습니다.&lt;/p&gt;
&lt;p&gt;가령 현재 실행권을 가지고 있는 무거운 랜더링 연산 작업을 진행하면서도, 작업 처리 우선순위가 높은 사용자 이벤트에
대한 처리 작업이 들어와 대기 중이라면, 진행 중인 작업을 즉시 중단하고 실행권을 우선순위가 높은 작업에게 양보해서
우선적으로 처리될 수 있게 하는 동작처럼요.&lt;/p&gt;
&lt;p&gt;간단해 보이지만 무거운 랜더링 연산 작업을 잘 개 쪼개고, 쪼개진 작업을 처리하고 우선순위가 높은 작업이 대기 중인지
확인해야 하고, 작업을 중단할 수 있어야 하며, 실행권을 양보한 후 다시 돌려받을 수 있어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 978px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAADC0lEQVQozw2Sa0+aBxTHH0QuAgJy9QJIFQyC1WcoVEFQFAqlgJembKLQGRSkbex0WbF1w2pmbLM1dkvd1iVb071amtTt5dZ0/QJ7s2RLtn2LfYPfnhf/nOTk5Jz/5Qh2TYTZdoGIWovGtILaVqXdfpMxo8iKUaBoUjDV7UUcTKAwlXAZZ1mV+nZTGrmxiFy/hE0TIq8VKJnlCD2dbmI6OVOqDjSaOApdCkGdZFTrpmqTI2pUVEJj/LxRIHhhin5dgHVLG27TRbSGMEZziB61g4JOxg1pXjBZdDhsRiIdSsYHg0yHMkxP5rnsHKDcJbA81M+z8hLntfe4dXWB5fAMFb3EPH6FWDhN0D/JiMUpMZSx1dOG0KZSYepQkdWrEftHGPZOkEkVWfIFaPSpOEmGOb9V4s1ulcVQFH+njXW3lWwsieiL4uwWcWtdZDRy6i41gkyuwNXezppNRWujxvm3zznavcdKdomNXI6FSIKHxWs8Xpznm6NjHtUbVDxORl0BfA4Rlz2AQ2EmqlaTlg4JgkKFVyHwWdzDP29+5b+//iQXT6FVWRkamiAZjHBWLnE3v0AqluGLvSZ5zyBTzgDvT8zgMPnpU9qIKpVEbAaJoUyJUZDxNBvk37dv+eHxEyz6XvqsA3RqermTzfL7UZPWWk2SN4zVIPl1McyLapmzyhricIJJ/zSi3Y231ysxlJZ1ywSeXR3j799e0yjdwGbqJ+Adp/Fuje9u1nl5/xMe7hzhl0JzWT3U4nP8cdxkf73B5FyF6NwqYqSI79J1BL3RwbhrmEYszucf7hAYCKBqM0jeeKjkVhmyukmELtPc3JPkDaAVOqRf7KWZnuPSeArfaJKxUI6AeAXvSBLB1iViNrxDIVfndm2HQvYa6fkMydl5ZqIJlheuc9Bs8eXJE6k+oLG+xZaE08MTFqU3KuQXsZr76DLYMegtCI1Sne3ybZ6fnvH6p1cctg7YrG4Sj8ZZloI4+fSYe3f3OLi/z972Lq2PPubBwSF3tj/gx+9f8MvLV3x19IivJZzuH/I/p1+Du2inuHAAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;A man who keeps telling me to wait&quot;
        title=&quot;A man who keeps telling me to wait&quot;
        src=&quot;/static/5e4096669fde9b4abaa7cb54a6acc677/914c7/thumbnail.png&quot;
        srcset=&quot;/static/5e4096669fde9b4abaa7cb54a6acc677/5a46d/thumbnail.png 300w,
/static/5e4096669fde9b4abaa7cb54a6acc677/0a47e/thumbnail.png 600w,
/static/5e4096669fde9b4abaa7cb54a6acc677/914c7/thumbnail.png 978w&quot;
        sizes=&quot;(max-width: 978px) 100vw, 978px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;우선순위&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84&quot; aria-label=&quot;우선순위 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;우선순위&lt;/h2&gt;
&lt;p&gt;리엑트는 산발적으로 발생하는 작업들을 교통정리하고 스케쥴링, 중단, 양보할 수 있도록 모든 작업에 우선순위를
부여합니다. 마우스, 키보드 입력과 같은 이산적인 사용자 상호작용에 대한 업데이트부터, 드래그처럼 연속적인
사용자 상호작용, 네트워크 요청, setTimeout에 의해 생성된 업데이트와 같은 작업들이 모두 각각의 우선순위를
가지게 됩니다.&lt;/p&gt;
&lt;p&gt;물론 리엑트가 지정한 작업 우선순위는 모두 사용자 경험에 대한 HCI 연구 결과가 반영되어 있습니다.
가령 화면 간 전환에서 로딩 중 상태를 너무 많이 표시하면 UX 품질이 낮아지는 문제라든지, 빠르게 처리되기를
기대하는 상호작용들과 느려도 문제없는 상호작용을 구분 짓고 이를 적용해서 우선순위를 할당하게 됩니다.&lt;/p&gt;
&lt;p&gt;실제 리엑트에서 우선순위를 표현하는 &lt;a href=&quot;https://github.com/facebook/react/pull/18796&quot;&gt;Lane 모델&lt;/a&gt;
을 살펴보면 31개의 비트맵으로 표현된 우선순위들이 레인이라는 명칭으로 표현되고 있고, 더 작은 숫자로 표현된 레인부터
높은 우선순위를 가지고 표현되어 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-reconciler/src/ReactFiberLane.new.js

export type Lanes = number;
export type Lane = number;
export type LaneMap&amp;lt;T&amp;gt; = Array&amp;lt;T&amp;gt;;

export const TotalLanes = 31;

export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;
export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;
export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000010;
export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000000100;
export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000001000;
export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000010000;
const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000000100000;
const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111111000000;
const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000001000000;
...
const RetryLanes: Lanes = /*                            */ 0b0000111110000000000000000000000;
const RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;
...

export const SomeRetryLane: Lane = RetryLane1;
export const SelectiveHydrationLane: Lane = /*          */ 0b0001000000000000000000000000000;
const NonIdleLanes: Lanes = /*                          */ 0b0001111111111111111111111111111;
export const IdleHydrationLane: Lane = /*               */ 0b0010000000000000000000000000000;
export const IdleLane: Lane = /*                        */ 0b0100000000000000000000000000000;
export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;SyncLane, 이산적인(discrete) 사용자 상호 작용에 대한 업데이트&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;InputContinuousLane, 연속적인(continuous) 사용자 상호 작용에 대한 업데이트&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;DefaultLane, setTimeout, 네트워크 요청 등에 의해 생성된 업데이트&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;TransitionLane, Suspense, useTransition, useDefferredValue에 의해 생성된 업데이트&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;레인들 중에서 큰 비중을 차지하는 &lt;code class=&quot;language-text&quot;&gt;TransitionLane&lt;/code&gt;은 비교적 낮은 우선순위를 가지고 있는데요. 해당 레인들은
이 글의 주제처럼, 긴급한 작업에 인위적으로 낮은 우선순위를 부여할 때 할당받을 수 있는 레인들입니다. 그리고
이후 살펴볼 훅들은 긴급한 작업에 대한 업데이트에 인위적으로 낮은 우선순위를 부여할 때 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;우선순위에 대해 더 자세히 알아보고 싶다면, &lt;a href=&quot;https://youthfulhps.dev/react/react-concurrent-mode-01/#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84&quot;&gt;동시성 메커니즘; 우선순위&lt;/a&gt;
를 참고하시면 좋습니다.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;usedeferredvalue&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#usedeferredvalue&quot; aria-label=&quot;usedeferredvalue permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;useDeferredValue&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;useDeferredValue()&lt;/code&gt;는 일부 UI 업데이트를 연기할 수 있도록 해주는 훅입니다. 훅에 초깃값으로 전달한
상태 값의 업데이트 우선순위를 Transition으로 낮춥니다.&lt;/p&gt;
&lt;p&gt;가령 검색창 입력값이 변경됨에 따라 쿼리를 생성해서 API 요청을 보내야 하는 경우, 사용성을 고려하여 입력창에
입력된 값 변경이 긴급하게 업데이트되어야 합니다. 하지만, 입력값의 완성도를 고려하지 않고 모든 입력값 변경에
요청 이펙트를 발생시키는 것은 좋지 못하다는 걸 잘 알고 있습니다. &lt;code class=&quot;language-text&quot;&gt;useDeferredValue()&lt;/code&gt;는 어쩌면 디바운스
기법을 대체할 수 있는 훅일 수도 있겠습니다.&lt;/p&gt;
&lt;p&gt;다음 예제와 같이 입력으로 받은 검색어를 통해 &lt;code class=&quot;language-text&quot;&gt;AlbumList&lt;/code&gt; 컴포넌트에서 API 요청을 보낸다고 생각해봅시다.
검색어가 변경될때마다 &lt;code class=&quot;language-text&quot;&gt;AlbumList&lt;/code&gt;에서는 새로운 요청을 보내게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { useDeferredValue, useState, Suspense } from &amp;#39;react&amp;#39;;
import AlbumList from &amp;#39;./AlbumList&amp;#39;;

function AlbumSearch() {
  const [query, setQuery] = useState(&amp;#39;&amp;#39;);

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;label&amp;gt;
        Search todo:
        &amp;lt;input value={query} onChange={e =&amp;gt; setQuery(e.target.value)} /&amp;gt;
      &amp;lt;/label&amp;gt;
      &amp;lt;AlbumList query={query} /&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}

export default AlbumSearch;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 &lt;code class=&quot;language-text&quot;&gt;useDeferredValue()&lt;/code&gt;를 사용해서 검색어의 완성도를 고려할 수 있도록 &lt;code class=&quot;language-text&quot;&gt;AlbumList&lt;/code&gt;에
속성값으로 전달되는 검색어 업데이트를 지연시켜 봅시다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { useDeferredValue, useState, Suspense } from &amp;#39;react&amp;#39;;
import AlbumList from &amp;#39;./AlbumList&amp;#39;;

function AlbumSearch() {
  const [query, setQuery] = useState(&amp;#39;&amp;#39;);
  const deferredQuery = useDeferredValue(query);
  const isStale = query !== deferredQuery;

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;label&amp;gt;
        Search todo:
        &amp;lt;input value={query} onChange={e =&amp;gt; setQuery(e.target.value)} /&amp;gt;
      &amp;lt;/label&amp;gt;
      &amp;lt;AlbumList query={deferredQuery} /&amp;gt;
    &amp;lt;/div&amp;gt;
  );
}

export default AlbumSearch;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;업데이트가 지연된 검색어를 전달함으로써 해당 검색어로 인한 사이드 이펙트 발생을 미루어 조금 더 완성도 높은
검색어에 대한 요청만 기대해 볼 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;usetransition&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#usetransition&quot; aria-label=&quot;usetransition permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;useTransition&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;useTransition()&lt;/code&gt;은 UI를 차단하지 않고 상태를 업데이트할 수 있는 훅입니다. &lt;code class=&quot;language-text&quot;&gt;useTransition()&lt;/code&gt;의
&lt;code class=&quot;language-text&quot;&gt;startTransition()&lt;/code&gt; 함수 내부에 정의된 상태 세터 함수의 우선순위를 낮춰 상태 업데이트로 발생된 작업을
처리할 수 있습니다.&lt;/p&gt;
&lt;p&gt;탭을 통해 컨텐츠를 전환하는 네비게이터가 있다고 생각해 봅시다. (&lt;a href=&quot;https://react.dev/reference/react/useTransition#usage&quot;&gt;예제&lt;/a&gt;는 리엑트 공식 문서에서 발췌했습니다.)&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { useState } from &amp;#39;react&amp;#39;;
import TabButton from &amp;#39;./TabButton&amp;#39;;
import About from &amp;#39;./About&amp;#39;;
import Contact from &amp;#39;./Contact&amp;#39;;
import PostsTab from &amp;#39;./Posts&amp;#39;;

function Navigator() {
  const [tab, setTab] = useState(&amp;#39;about&amp;#39;);

  return (
    &amp;lt;&amp;gt;
      &amp;lt;nav&amp;gt;
        &amp;lt;TabButton isActive={tab === &amp;#39;about&amp;#39;} onClick={() =&amp;gt; setTab(&amp;#39;about&amp;#39;)}&amp;gt;
          About
        &amp;lt;/TabButton&amp;gt;
        &amp;lt;TabButton isActive={tab === &amp;#39;posts&amp;#39;} onClick={() =&amp;gt; setTab(&amp;#39;posts&amp;#39;)}&amp;gt;
          Posts (slow)
        &amp;lt;/TabButton&amp;gt;
        &amp;lt;TabButton
          isActive={tab === &amp;#39;contact&amp;#39;}
          onClick={() =&amp;gt; setTab(&amp;#39;contact&amp;#39;)}
        &amp;gt;
          Contact
        &amp;lt;/TabButton&amp;gt;
        &amp;lt;hr /&amp;gt;
      &amp;lt;/nav&amp;gt;
      {tab === &amp;#39;about&amp;#39; &amp;amp;&amp;amp; &amp;lt;About /&amp;gt;}
      {tab === &amp;#39;posts&amp;#39; &amp;amp;&amp;amp; &amp;lt;PostsTab /&amp;gt;}
      {tab === &amp;#39;contact&amp;#39; &amp;amp;&amp;amp; &amp;lt;Contact /&amp;gt;}
    &amp;lt;/&amp;gt;
  );
}

export default Navigator;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서 유독 &lt;code class=&quot;language-text&quot;&gt;Posts&lt;/code&gt; 페이지는 랜더링 과정이 1초가 걸리는 매우 무거운 작업을 수행하도록 구현되어 있어
포스트탭을 클릭하면 잠시 UI 인터렉션이 블로킹되고, 랜더링에 몰두하게 됩니다. 즉 우선순위가 높은 유저
인터렉션 처리를 할 수 없게 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 35.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAV0lEQVQoz9WOMQoAIQwE/f8bU9hIHqBRgiErBq675rS6halChkkigt47VBVjDMw5sefuR6RSCnLOARGBmeOwxWb2mfSUtdZQa8UuvirEy05lIbx5/qdwAe3pKYFhqmXWAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;User interaction blocked due to rendering operation&quot;
        title=&quot;User interaction blocked due to rendering operation&quot;
        src=&quot;/static/cf088e3313fb7da63d6f49e9e15230fa/1cfc2/use-transition.png&quot;
        srcset=&quot;/static/cf088e3313fb7da63d6f49e9e15230fa/5a46d/use-transition.png 300w,
/static/cf088e3313fb7da63d6f49e9e15230fa/0a47e/use-transition.png 600w,
/static/cf088e3313fb7da63d6f49e9e15230fa/1cfc2/use-transition.png 900w&quot;
        sizes=&quot;(max-width: 900px) 100vw, 900px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;여기서 클릭을 통한 선택된 탭 전환 트리거를 &lt;code class=&quot;language-text&quot;&gt;useTransition()&lt;/code&gt;로 감싸주고 우선순위를 낮춰봅시다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { ReactNode, useTransition } from &amp;#39;react&amp;#39;;

type TabButtonProps = {
  children: ReactNode;
  isActive: boolean;
  onClick: () =&amp;gt; void;
};

function TabButton({ children, isActive, onClick }: TabButtonProps) {
  const [isPending, startTransition] = useTransition();
  if (isActive) {
    return &amp;lt;b&amp;gt;{children}&amp;lt;/b&amp;gt;;
  }
  if (isPending) {
    return &amp;lt;b className=&amp;quot;pending&amp;quot;&amp;gt;{children}&amp;lt;/b&amp;gt;;
  }
  return (
    &amp;lt;button
      onClick={() =&amp;gt; {
        startTransition(() =&amp;gt; {
          onClick();
        });
      }}
    &amp;gt;
      {children}
    &amp;lt;/button&amp;gt;
  );
}

export default TabButton;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 다시 포스트탭을 클릭해 보면, UI 인터렉션이 블로킹되지 않고 활성화되어 있으며 포스트 컨텐츠를
로딩하다가 발생한 탭 전환 인터렉션에 대해 즉시 처리할 수 있게 됩니다.&lt;/p&gt;
&lt;p&gt;리엑트에서 동시성 메커니즘을 구현하기 위해 적용된 ‘양보’의 개념으로, 탭 전환에 의해 발생한 랜더링 작업을
잘 개 쪼개서 작업을 진행하다가 우선순위가 높은 사용자의 인터렉션(이 예제에서는 다른 탭 클릭)이 들어왔을 때,
랜더링 작업이 소유하고 있던 실행권을 우선순위가 높은 작업 처리에 양보하는 모습을 확인할 수 있습니다.
(양보에 대한 이야기는 &lt;a href=&quot;https://youthfulhps.dev/react/react-concurrent-mode-01/#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98-%EC%96%91%EB%B3%B4&quot;&gt;여기&lt;/a&gt;를 참고하시면 좋습니다!)&lt;/p&gt;
&lt;h2 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h2&gt;
&lt;p&gt;결국 두 훅은 업데이트 작업의 우선순위를 인위적으로 낮추는데 사용하는데요. 리엑트 자체적으로 정한 우선순위와
상충하는 작업 처리를 해야 하는 케이스에 대해 우선순위를 인위적으로 변경할 수 있는 기능을 제공함으로서
작업자의 자유도를 높여주는 훅들이라 생각이 듭니다. 성능 개선과 사용자 경험 향상을 위해 더 좋은 사용 케이스들을
살펴보고 적용해 보면 좋겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://react.dev/reference/react/useDeferredValue&quot;&gt;https://react.dev/reference/react/useDeferredValue&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://react.dev/reference/react/useTransition&quot;&gt;https://react.dev/reference/react/useTransition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://iyu88.github.io//react/2022/11/01/react-concurrent-mode.html&quot;&gt;https://iyu88.github.io//react/2022/11/01/react-concurrent-mode.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Vite preview]]></title><description><![CDATA[‘이렇게나 빠른 Vite…]]></description><link>https://youthfulhps.dev/web/vite-preview/</link><guid isPermaLink="false">https://youthfulhps.dev/web/vite-preview/</guid><pubDate>Mon, 20 Mar 2023 13:03:35 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;‘이렇게나 빠른 Vite를 사용하지 않을 이유가 있나요?’&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;웹 개발을 하면서 가장 익숙하고 자주 접한 번들러를 꼽자면 단연 웹팩일텐데요. 아무래도 많은 프로젝트나 스타터
보일러 플레이트에서 번들러로 웹팩을 사용하고 있어, 비교적 복잡한 설정과 상대적으로 느린 개발 모드 속도에도
자연스럽게 알고 있어야 하는 번들러로 입지를 굳혀 왔습니다.&lt;/p&gt;
&lt;p&gt;하지만, 개발 경험을 최대한 끌어올리기 위한 많은 번들러들이 등장하기 시작했는데, Rust 프로그래밍 언어의 특성을
살려 작성된 번들러 (e.g. Turbopack)부터, Native ESM을 사용하여 극적으로 개발 속도를 끌어올린 번들러
(e.g. Vite)까지 웹팩보다 10-100배 빠른 번들링 속도를 언급하며 관심을 모으고 있습니다.&lt;/p&gt;
&lt;p&gt;실무에서도 웹팩 외 주목을 받고 있는 번들러를 적용해보고 있는데요. 그 시작으로 최근 팀 내 스쿼드별로 중복 개발의
우려가 있는 유틸성 함수나 비즈니스 로직의 단위를 일치시키고 효율성을 끌어올리고자 팀내 라이브러리를 구축하고 있고,
Vite를 통해 해당 프로젝트를 번들링하고 있습니다. 프러덕션 레벨에서 웹팩 외 타 번들러를 처음 사용하는 만큼,
번들러에 대해 다시 이해해보고, Vite에 대해 찍먹해보는 글을 적어보려 합니다.&lt;/p&gt;
&lt;h2 id=&quot;번들링-작업은-왜-필요할까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B2%88%EB%93%A4%EB%A7%81-%EC%9E%91%EC%97%85%EC%9D%80-%EC%99%9C-%ED%95%84%EC%9A%94%ED%95%A0%EA%B9%8C&quot; aria-label=&quot;번들링 작업은 왜 필요할까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;번들링 작업은 왜 필요할까&lt;/h2&gt;
&lt;p&gt;애당초 정적인 웹 페이지의 간단한 동적인 요소를 구현하고자 탄생한 자바스크립트는 표준 모듈 시스템을 가지고 있지
않았는데요. 점점 스크립트의 크기가 커지고, 자바스크립트 런타임의 등장과 함께 언어의 역할 범위가 넓어짐에 따라
&lt;code class=&quot;language-text&quot;&gt;CommonJS&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;AMD&lt;/code&gt; 그리고 &lt;code class=&quot;language-text&quot;&gt;import&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;export&lt;/code&gt;을 사용하는 &lt;code class=&quot;language-text&quot;&gt;ESModules&lt;/code&gt; 와 같은 표준 모듈 시스템이
등장하게 되었어요. 이후 런타임 뿐만 아니라, 브라우저와 같은 네이티브 레벨에서도 자바스크립트 모듈 시스템을
해석할 수 있게 되었습니다.&lt;/p&gt;
&lt;p&gt;하지만 모듈 시스템을 해석할 수 있는 능력이 있더라도, 웹 페이지를 구성하는 수많은 모듈들을 각각 요청해서 받아와야
하는 이슈가 남아있었습니다. 모듈 갯수와 비례하게 요청 횟수 또한 늘어난다는 것인데, 비동기적인 대기로 인한 병목과
모듈 응답 순서 또한 보장받을 수 없는 문제들이 있었습니다.&lt;/p&gt;
&lt;p&gt;번들러는 모듈 시스템 기반으로 개발되었던 프로젝트의 모듈들을 빌드 과정에서 하나의 파일로 번들링해서 브라우저에게
전달하면 요청 횟수를 최소화할 수 있지 않을까 라는 목적으로 등장하게 되었습니다.&lt;/p&gt;
&lt;h2 id=&quot;개발서버에서의-번들링&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B0%9C%EB%B0%9C%EC%84%9C%EB%B2%84%EC%97%90%EC%84%9C%EC%9D%98-%EB%B2%88%EB%93%A4%EB%A7%81&quot; aria-label=&quot;개발서버에서의 번들링 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;개발서버에서의 번들링&lt;/h2&gt;
&lt;p&gt;번들링을 통해 네이티브에서 원하는 모듈을 불러오기 위한 요청 횟수를 극적으로 줄여 모듈의 병목 이슈를 해결할 수
있었는데요. 하지만 번들링은 일종의 우회적인 방법으로 자바스크립트의 모듈 시스템을 풀이한 방식이라는 점은 여전히
짚고 넘어가야 합니다.&lt;/p&gt;
&lt;p&gt;개발서버에서 런타임에 제품을 올리기 위해 빌드를 할때면, 번들러에서 열심히 번들링하고 결과물을 로드하는데까지
적게는 수십초가 걸립니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ yarn dev
$ webpack serve...
&amp;lt;i&amp;gt; [webpack-dev-server] Project is running at:
&amp;lt;i&amp;gt; [webpack-dev-server] Loopback: http://localhost:3000/, http://127.0.0.1:3000/
&amp;lt;i&amp;gt; [webpack-dev-server] Content not from webpack is served from &amp;#39;.../public&amp;#39; directory
&amp;lt;i&amp;gt; [webpack-dev-server] 404s will fallback to &amp;#39;/index.html&amp;#39;
&amp;lt;i&amp;gt; [webpack-dev-middleware] wait until bundle finished: /
...
webpack 5.75.0 compiled successfully in 18337 ms&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;코드를 수정하고 다시 빌드할때도 HMR 도움을 받지만, 몇초는 기다려야 하는 것이 사실인데요. Vite는 번들링이
개발 경험에 마이너스가 되는 요소라는 점을 해결 문제로 인식합니다.&lt;/p&gt;
&lt;h2 id=&quot;native-esm&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#native-esm&quot; aria-label=&quot;native esm permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Native ESM&lt;/h2&gt;
&lt;p&gt;Vite는 다시금 네이티브에서 ES 모듈을 해석할 수 있다는 점에 집중하는데요. Evan You 님은 기존 네이티브가
각각의 모듈을 요청하는 방식에 문제가 없었나 싶은 생각이 들 정도로, 네이티브에서 모듈을 처리하는 방식이
개발 속도를 극적으로 빠르게 끌어올려 줄 수 있다고 설명합니다.&lt;/p&gt;
&lt;p&gt;굳이 번들링하지 않아도 네이티브가 자바스크립트 파일을 파싱하고, 임포트 구문을 만나면 HTTP를 통해 원하는
모듈에 대한 요청을 보낼 수 있고, 이 과정이 개발 서버에서 상당히 가벼운 처리로 네이티브 영역에서 수행되기
때문에 서버를 시작할 때 많은 준비가 필요 없다고 말하는데요.&lt;/p&gt;
&lt;p&gt;여기서, 잠시 Vite에서 제공하는 스크립트를 통해 생성된 프로젝트의 &lt;code class=&quot;language-text&quot;&gt;index.html&lt;/code&gt; 파일을 보면 스크립트
태그를 통해 메인 모듈을 가져오고 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ yarn create vite&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;script type=&amp;quot;module&amp;quot; src=&amp;quot;./main.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서 &lt;code class=&quot;language-text&quot;&gt;index.html&lt;/code&gt; 파일이 &lt;code class=&quot;language-text&quot;&gt;public&lt;/code&gt; 에 위치하지 않은 것도 의도적으로 추가 번들링 없이 진입점으로 사용할 수
있도록 하기 위함이라고 합니다.&lt;/p&gt;
&lt;h2 id=&quot;부분적인-번들링&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B6%80%EB%B6%84%EC%A0%81%EC%9D%B8-%EB%B2%88%EB%93%A4%EB%A7%81&quot; aria-label=&quot;부분적인 번들링 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;부분적인 번들링&lt;/h2&gt;
&lt;p&gt;Vite가 번들링을 아예 배제하는 것은 아닙니다. 공식 문서에서 알 수 있듯 ESM 말고도 기존 번들러에서 제공하는 기능을
대부분 지원하고 있으며, 만약 프로젝트가 큰 의존성 모듈을 가지고 있다면, 요청 수를 줄이기 위해 esbuild를 통해
pre-bunling을 진행합니다.&lt;/p&gt;
&lt;p&gt;또한, 프러덕션을 위한 빌드시에는 번들링 과정을 거칩니다. 프러덕션 레벨에서는 여전히 번들되지 않은 ESM을 가져오는 것이
중첩된 모듈 불러오기로 인한 네트워크 통신이 발생하는 것이 여전히 비효율적입니다. 번들링 단계에서 트리쉐이킹, 청크 분할
등 더 나은 캐싱을 위해 번들링을 사용하는 것이 좋다고 설명합니다.&lt;/p&gt;
&lt;h2 id=&quot;왜-vite는-빠른가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%99%9C-vite%EB%8A%94-%EB%B9%A0%EB%A5%B8%EA%B0%80&quot; aria-label=&quot;왜 vite는 빠른가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;왜 vite는 빠른가?&lt;/h2&gt;
&lt;h2 id=&quot;결국-빌드에는-번들링을-한다는-점&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B2%B0%EA%B5%AD-%EB%B9%8C%EB%93%9C%EC%97%90%EB%8A%94-%EB%B2%88%EB%93%A4%EB%A7%81%EC%9D%84-%ED%95%9C%EB%8B%A4%EB%8A%94-%EC%A0%90&quot; aria-label=&quot;결국 빌드에는 번들링을 한다는 점 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;결국 빌드에는 번들링을 한다는 점&lt;/h2&gt;</content:encoded></item><item><title><![CDATA[효율적인 문자열 검색을 위한 정규 표현식]]></title><description><![CDATA[…]]></description><link>https://youthfulhps.dev/javascript/regular-expression/</link><guid isPermaLink="false">https://youthfulhps.dev/javascript/regular-expression/</guid><pubDate>Wed, 07 Dec 2022 15:12:26 GMT</pubDate><content:encoded>&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 982px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 61%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAAC70lEQVQoz3WTy28TVxSH7ZCSAiZ1zHsBArUlqRpYdAEINlEDtLuqIkK0VVUkJJCyQIKyKAiKoAjEI0FskAqJsR2/xx6PPTMeezwe2+Nk7JAXAbVC6h/z9TopCl2wOJr7mu+c3/2d6/F4PLwLv9/PwP5+vj1+krM//szp70/RJ9Y6e75NPgJ9Ad4//4Hw8MPIKVLBCFo8zWunxT8LS7x2W7yacUgEJ/j92lUysQhmIU/k+QRXLl7i66EhDh44IJL0/R84sGcXLaPI29YCWjSCIaUpSnGSwacCMoEqhVmadaioEmUlzV9L8yy6MxiKxELb5db1Gyugrq6uVeBQ/24qySi1gk4uPIkUCVIzNEriZ12OIccnqZUV5FSQXGpKVKlgFvNIsRcUchliE8/o9r5X4dG9OzCjIVoVi5KorKYpvJlvYxdl1GyYSjHDXNtGz01R0tPUTA2nWqKsZdHyMoacIrCxZwXm7QAP79lCMxtn2X2JnpiiUVaZbzk0zAJOTRfVZHjZEsnUOHo+RtmQaNiGWJdxGhWmLZN9O7etAr1ePINbfdiJIHP1JnUtz2zDYrEDFDIbZo6mXVwB2hUFp15iplnBKmeR0y9Q8xLzbpOv+j9fvccO8NPe9chPH7NQb6AnI9R0hdm6SamQJJ+cRJPDzLpVITnCdF2nPV3BbZpinkCWYizPtfnm2KE1Y3b7ukk9uYtrWmRDf1JVsyIywsWEMCCNmgljGzkxj9OsFtCVmKhQQS+kMETyv5cXGTk5tAbctWEdybE7tKuOkKwLWH7FSSUdxSp27tHEFHJty8AyFGpWEVsYoxcywmUhud3i/Mh3a8C+j7xkH9yiFE0QejTG8wf3Gf/tCuOXRwndv03ij2vcGzlB6OFttFQUUxamiL6tl3ThtIo743J99NyqKR1glxjs6/WxNxBgu/8Ttmzuxf9xDz7RWzt6uvlsnfiKM0e2+Tk++AXDg19yZniYC+J1XT77C49u3OTXn87814de/gWiYErQL2cqVgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;thumbnail&quot;
        title=&quot;thumbnail&quot;
        src=&quot;/static/a65b2232e630f4aa48f714908c7ef8ce/84a90/thumbnail.png&quot;
        srcset=&quot;/static/a65b2232e630f4aa48f714908c7ef8ce/5a46d/thumbnail.png 300w,
/static/a65b2232e630f4aa48f714908c7ef8ce/0a47e/thumbnail.png 600w,
/static/a65b2232e630f4aa48f714908c7ef8ce/84a90/thumbnail.png 982w&quot;
        sizes=&quot;(max-width: 982px) 100vw, 982px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;최근 정규 표현식을 마주하는 일이 잦아진 것 같습니다. 주로 문자열의 유효성 검사를
위해 작성되었던 정규 표현식들과, 에디터에서 특정 문자열 검색을 위해 정규식 검색을
사용하곤 했는데요.&lt;/p&gt;
&lt;p&gt;사실 정규 표현식을 사용할 때면, 이미 작성되어 있는 표현식들을 꿰맞추어 사용하거나,
구글링해야 하는 경우가 부지기수였습니다. 해서 거창한 이유보다는, 잘 사용해 보고 싶은
생각이 들어 공부하게 된 내용을 정리해 보려 합니다.&lt;/p&gt;
&lt;h2 id=&quot;정규-표현식&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D&quot; aria-label=&quot;정규 표현식 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;정규 표현식&lt;/h2&gt;
&lt;p&gt;정규 표현식(Regular Expression)은 특정 규칙을 가진 문자열의 집합을 표현하고자
고안된 형식 언어입니다. 정규 표현식은 자바스크립트에서 한정적으로 제공하는 기능이 아니라,
대부분의 텍스트 에디터, 프로그래밍 언어에서 문자열의 검색과 치환을 위해 정규 표현식을
문법으로 내장하고 있거나, 표준 라이브러리를 제공하고 있습니다.&lt;/p&gt;
&lt;p&gt;간단한 예제부터 살펴봅시다. 다음은 특정 문자열에서 ‘Hello’라는 단어를 찾고자
작성된 정규 표현식으로, 문자열의 ‘Hello’가 검색된 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAx0lEQVQoz82RzQqCUBSEryhW4E9oRmlSCwsCc2GLIpW78RXa3cxFUIKQT+CrTyG0SkPChYth4Ax8zDmHEELQsZpDjuO+9Jn/Bey0oeu6YIwhCAL4vo84jmFZFmzbrjJFUdoDDcNAFIbIsgeK4okkuSDPc6RpCkopyrKEaZpN638DRVF8e/2dBEGApmmVt27I8wSH/QT0NEN0nGKsDiBJClRVhSzLv2D1wNGQBzuvcb9ucWMbrJY65uYCnreD4zjQdb0HX+4N8AXy5fD1MeRqygAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Introduction regular expression example&quot;
        title=&quot;Introduction regular expression example&quot;
        src=&quot;/static/4dd573b2f77564ddf70812a8938f21fc/c1b63/intro-regex-example.png&quot;
        srcset=&quot;/static/4dd573b2f77564ddf70812a8938f21fc/5a46d/intro-regex-example.png 300w,
/static/4dd573b2f77564ddf70812a8938f21fc/0a47e/intro-regex-example.png 600w,
/static/4dd573b2f77564ddf70812a8938f21fc/c1b63/intro-regex-example.png 1200w,
/static/4dd573b2f77564ddf70812a8938f21fc/d61c2/intro-regex-example.png 1800w,
/static/4dd573b2f77564ddf70812a8938f21fc/df88b/intro-regex-example.png 1906w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;자바스크립트의-정규-표현식&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D&quot; aria-label=&quot;자바스크립트의 정규 표현식 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;자바스크립트의 정규 표현식&lt;/h2&gt;
&lt;p&gt;자바스크립트는 RegExp 객체를 제공하여 정규 표현식의 문법과 프로그래밍 기능을 담은
메서드들을 사용할 수 있도록 하며, 리터럴 방식 혹은 생성자 함수로 호출하여 RegExp
객체를 생성할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 정규식 리터럴
/ab+c/i;

// 생성자
new RegExp(/ab+c/, &amp;#39;i&amp;#39;);
new RegExp(&amp;#39;ab+c&amp;#39;, &amp;#39;i&amp;#39;);

// ES6 생성자
new RegExp(/ab+c/i);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;RegExp 생성자의 인스턴스들은 대표적으로 다음과 같은 메서드를 가지고 있습니다.
아래 예제들에서 사용되는 메서드들이니, 간단하게 그 역할만 알아보고 넘어가겠습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 문자열 매개변수에 대해 검색을 실행합니다.
RegExp.prototype.exec();

// 문자열 매개변수에 대해 판별을 실행합니다.
RegExp.prototype.test();

// 주어진 문자열 내의 일치를 새로운 문자열로 대치합니다.
RegExp.prototype.replace();

// 주어진 문자열에 대해 일치하는 결과를 반환합니다.
RegExp.prototype.match();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;정규-표현식의-구성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D%EC%9D%98-%EA%B5%AC%EC%84%B1&quot; aria-label=&quot;정규 표현식의 구성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;정규 표현식의 구성&lt;/h2&gt;
&lt;p&gt;정규 표현식은 크게 패턴(Pattern)과 플래그(Flag)로 구성되어 있는데요. 패턴의 시작과
끝을 &lt;code class=&quot;language-text&quot;&gt;/&lt;/code&gt;로 묶고, 그 뒤로 플래그를 옵션으로 붙여 완성합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAzElEQVQ4y+VSuwqDQBA8X7+h2AmComeh2Cn4QEQUK238AxErv37EDYZoDCSQzmLYY3dmWGaPMcbwZ9zeUBRFqoIg0HvHlXjnvBluA0VRvtpAkiSCLMsH4ydHVVUEQYCu6zDPM6qqwjAM6PseTdOgKAqUZQnXdcE5h+d5mKYJ4zgiyzK0bUscXdcfhoZhwLZthGEI3/dJvBHrukae59RPkgRxHMNxHJimiSiKYFkW0jTFsiy0jKZpvx3lNdvz7BTXUXTGVfBb78NB7vixVxfMIr87KQKOAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Regular expression composition&quot;
        title=&quot;Regular expression composition&quot;
        src=&quot;/static/0df3995cc64ea59baf72cbb68462534b/c1b63/regex-composition.png&quot;
        srcset=&quot;/static/0df3995cc64ea59baf72cbb68462534b/5a46d/regex-composition.png 300w,
/static/0df3995cc64ea59baf72cbb68462534b/0a47e/regex-composition.png 600w,
/static/0df3995cc64ea59baf72cbb68462534b/c1b63/regex-composition.png 1200w,
/static/0df3995cc64ea59baf72cbb68462534b/d61c2/regex-composition.png 1800w,
/static/0df3995cc64ea59baf72cbb68462534b/97a96/regex-composition.png 2400w,
/static/0df3995cc64ea59baf72cbb68462534b/5fe07/regex-composition.png 3422w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;패턴은 말 그대로 검색하고자 하는 텍스트가 준수해야 하는 패턴을 표현하기 위해 사용하고,
&lt;strong&gt;우리가 흔히 사용하는 정규 문자들과, 그 문자가 가진 뜻이 아닌 특별한 용도로 사용하는
메타 문자들로 구성&lt;/strong&gt;할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;. ^ $ * + ? { } [ ] \ | ( ) // 메타 문자&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다음으로 플래그는 검색 조건을 표현하기 위한 역할로 사용되며 옵션입니다. 즉, 사용하지
않아도 되며, 사용하지 않는다면 문자열 내 매칭 대상의 첫 번째 대상을 찾게 되면
검색을 종료하고 이를 반환하게 됩니다.&lt;/p&gt;
&lt;h2 id=&quot;플래그&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%94%8C%EB%9E%98%EA%B7%B8&quot; aria-label=&quot;플래그 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;플래그&lt;/h2&gt;
&lt;p&gt;정규 표현식 소개 글에서 언급했던 예제가 이제 눈에 들어오시나요? 또 다른 예제들을 보면서
다양하게 조합해 봅시다. 다음과 같이 플래그를 사용하지 않는다면, 문자열에서의 매칭 대상의
첫 번째 대상이 반환됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const target = &amp;#39;가장 큰 약점은 약점을 보일 것에 대한 두려움이다.&amp;#39;;

const regexr = /약점/;
console.log(target.match(regexr)); // [&amp;#39;약점&amp;#39;, index: 5, input: &amp;#39;가장 큰 약점은...&amp;#39;];&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;만약 문자열 내 패턴에 일치하는 대상을 모두 반환하고 싶다면, &lt;code class=&quot;language-text&quot;&gt;g&lt;/code&gt; 플래그를 사용할 수
있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const target = &amp;#39;가장 큰 약점은 약점을 보일 것에 대한 두려움이다.&amp;#39;;
const regexr = /약점/g;

console.log(target.match(regexr)); // [&amp;#39;약점&amp;#39;, &amp;#39;약점&amp;#39;];&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;참고로 자바스크립트의 &lt;code class=&quot;language-text&quot;&gt;String.prototype.match()&lt;/code&gt; 메서드는 정규 표현식에
&lt;code class=&quot;language-text&quot;&gt;g&lt;/code&gt;가 포함되어 있지 않다면, 첫 번째 매칭 대상과 함께 인덱스와 입력값이 포함된
RegExpExecArray 인터페이스 형태로 반환되며, 반대로 &lt;code class=&quot;language-text&quot;&gt;g&lt;/code&gt;가 포함되어 있다면
일치하는 모든 대상을 포함하는 배열을 반환합니다.&lt;/p&gt;
&lt;p&gt;또한 플래그는 다중으로 사용할 수 있는데요. 영문을 패턴으로 검색할 때 대소문자 구분 없이
모든 대상을 반환받고 싶다면, 대소문자 구분을 무시하라는 의미의 &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt;와 모든 대상 검색을
의미하는 &lt;code class=&quot;language-text&quot;&gt;g&lt;/code&gt; 플래그를 함께 사용하여 표현할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const target = &amp;#39;The biggest weakness is the fear of showing weakness.&amp;#39;;
const regexr = /The/g;
const regexrWithIgnoreCase = /The/gi;

console.log(target.match(regexr)); // [&amp;#39;The&amp;#39;]
console.log(target.match(regexrWithIgnoreCase)); // [&amp;quot;The&amp;quot;, &amp;quot;the&amp;quot;]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;개인적으로 가장 많이 사용하는 &lt;code class=&quot;language-text&quot;&gt;g&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;i&lt;/code&gt; 플래그들과 함께 자바스크립트가 지원하는
플래그 6개들은 다음과 같습니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;플래그&lt;/th&gt;
&lt;th&gt;역할&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;대소문자 구분을 무시하고 검색합니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;g&lt;/td&gt;
&lt;td&gt;패턴과 일치하는 모든 대상을 검색합니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;m&lt;/td&gt;
&lt;td&gt;다중 행 모드로 검색합니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;s&lt;/td&gt;
&lt;td&gt;메타문자 &lt;code class=&quot;language-text&quot;&gt;.&lt;/code&gt;이 개행 문자 &lt;code class=&quot;language-text&quot;&gt;\n&lt;/code&gt;도 포함하는 ‘dot all’ 모드로 검색합니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u&lt;/td&gt;
&lt;td&gt;유티코드 전체를 지원하여 검색합니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;y&lt;/td&gt;
&lt;td&gt;문자 내 특정 위치에서 검색을 진행하는 ‘sticky’ 모드로 검색합니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&quot;패턴&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%8C%A8%ED%84%B4&quot; aria-label=&quot;패턴 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;패턴&lt;/h2&gt;
&lt;p&gt;패턴은 우리가 흔히 사용하는 정규 문자와 메타 문자로 이루어져 있다고 언급했었는데요.
메타 문자를 함께 사용한 매칭 패턴을 구성하여 보다 더 유연한 검색 정규식을 만들어
봅시다.&lt;/p&gt;
&lt;h3 id=&quot;문자-클래스&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%AC%B8%EC%9E%90-%ED%81%B4%EB%9E%98%EC%8A%A4&quot; aria-label=&quot;문자 클래스 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;문자 클래스&lt;/h3&gt;
&lt;p&gt;문자 클래스는 문자 그대로의 가진 뜻이 아닌 특별한 용도로 사용하기 위해 역할을 부여한
정규 표현식의 가장 기본적인 개념으로 사용되고 있습니다. 그중 먼저 &lt;code class=&quot;language-text&quot;&gt;[]&lt;/code&gt;를 살펴봅시다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;[]&lt;/code&gt; 안의 문자들은 모두 ‘또는’으로 검색됩니다. 가령, 검색 문자의 범위를 나타내는
&lt;code class=&quot;language-text&quot;&gt;-&lt;/code&gt;와 함께 사용되어 문자열 범위에 해당하는 모든 값을 검색할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const target = &amp;#39;가장 큰 약점 is the fear of showing weakness.&amp;#39;;
const regexrForEnglish = /[a-zA-z]/g;
const regexrForKorean = /[ㄱ-ㅎ가-힣]/g;

console.log(target.match(regexrForEnglish)); // [&amp;#39;i&amp;#39;, &amp;#39;s&amp;#39;, &amp;#39;t&amp;#39;, &amp;#39;h&amp;#39;, &amp;#39;e&amp;#39;, ...]
console.log(target.match(regexrForKorean)); // [&amp;#39;가&amp;#39;, &amp;#39;장&amp;#39;, &amp;#39;큰&amp;#39;, &amp;#39;약&amp;#39;, &amp;#39;점&amp;#39;]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;숫자만 검색하고 싶을 때는 어떻게 할 수 있을까요? 숫자 검색은 정규 표현식은 &lt;code class=&quot;language-text&quot;&gt;[0-9]&lt;/code&gt;
혹은 문자 클래스로 지정되어 있는 &lt;code class=&quot;language-text&quot;&gt;\d&lt;/code&gt;를 사용할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const target = &amp;#39;하나2삼4오여섯7팔90&amp;#39;;
const regexr = /[0-9]/g;
const regexrUsingCharClass = /\d/g;

console.log(target.match(regexr)); // [&amp;#39;2&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;7&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;0&amp;#39;]
console.log(target.match(regexrUsingCharClass)); // [&amp;#39;2&amp;#39;, &amp;#39;4&amp;#39;, &amp;#39;7&amp;#39;, &amp;#39;9&amp;#39;, &amp;#39;0&amp;#39;]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서 &lt;code class=&quot;language-text&quot;&gt;\d&lt;/code&gt;와 같은 표현은 숫자 검색을 위한 &lt;code class=&quot;language-text&quot;&gt;[0-9]&lt;/code&gt; 정규 표현식처럼 자주 사용되는
표현에 대해 간단하게 작성할 수 있도록 별도로 정의된 문자 클래스입니다. 이와 같은 문자
클래스들은 대표적으로 다음과 같은 클래스들이 정의되어 있습니다.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;문자 클래스&lt;/th&gt;
&lt;th&gt;역할&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;숫자를 검색합니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;숫자가 아닌 것을 검색합니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;공백 (Whitespace) 를 검색합니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;공백이 아닌 것을 검색합니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;알파벳, 숫자, 언더스코어 (_)를 검색합니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;알파벳, 숫자, 언더스코어 (_)가 아닌 것을 검색합니다.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&quot;dot-&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#dot-&quot; aria-label=&quot;dot  permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Dot (.)&lt;/h3&gt;
&lt;p&gt;그 외 자주 사용되는 메타 문자들도 예제를 통해 알아봅시다. 먼저, &lt;code class=&quot;language-text&quot;&gt;.&lt;/code&gt; 은 줄바꿈(&lt;code class=&quot;language-text&quot;&gt;\n&lt;/code&gt;)을
제외한 모든 문자와 매칭됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const target = &amp;#39;가장 큰 약점 is \n the fear of showing weakness.&amp;#39;;
const regexr = /./g;

console.log(target.match(regexr)); // [&amp;quot;가&amp;quot;, &amp;quot;장&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;큰&amp;quot;, &amp;quot; &amp;quot;, &amp;quot;약&amp;quot;, &amp;quot;점&amp;quot;, ...]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;반복---&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%B0%98%EB%B3%B5---&quot; aria-label=&quot;반복    permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;반복 (*, +, {})&lt;/h3&gt;
&lt;p&gt;반복 패턴을 의미하는 &lt;code class=&quot;language-text&quot;&gt;*&lt;/code&gt;은 바로 앞 문자가 없거나 무한대로 반복될 수 있음을 표현하며,
이에 매칭되는 대상을 검색합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const target = &amp;#39;B AB AAB AAAB AAAAB AAAAC&amp;#39;;
const regexr = /A*B/g;

console.log(target.match(regexr)); // [&amp;quot;B&amp;quot;, &amp;quot;AB&amp;quot;, &amp;quot;AAB&amp;quot;, &amp;quot;AAAB&amp;quot;, &amp;quot;AAAAB&amp;quot;]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;+&lt;/code&gt;는 바로 앞 문자가 하나 이상이거나 무한대로 반복될 수 있음을 표현하며 이에
매칭되는 대상을 검색합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const target = &amp;#39;B AB AAB AAAB AAAAB AAAAC&amp;#39;;
const regexr = /A+B/g;

console.log(target.match(regexr)); // [&amp;quot;AB&amp;quot;, &amp;quot;AAB&amp;quot;, &amp;quot;AAAB&amp;quot;, &amp;quot;AAAAB&amp;quot;]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;반복을 표현할 때, 반복 횟수를 제한할 수도 있습니다. &lt;code class=&quot;language-text&quot;&gt;{시작 횟수, 끝 횟수}&lt;/code&gt;로 표현하여
이에 매칭되는 대상을 검색합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const target = &amp;#39;B AB AAB AAAB AAAAB AAAAC&amp;#39;;
const regexr = /A{1,3}B/g;

console.log(target.match(regexr)); // [&amp;quot;AB&amp;quot;, &amp;quot;AAB&amp;quot;, &amp;quot;AAAB&amp;quot;, &amp;quot;AAAB&amp;quot;]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;자주-사용되는-정규-표현식&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EC%A3%BC-%EC%82%AC%EC%9A%A9%EB%90%98%EB%8A%94-%EC%A0%95%EA%B7%9C-%ED%91%9C%ED%98%84%EC%8B%9D&quot; aria-label=&quot;자주 사용되는 정규 표현식 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;자주 사용되는 정규 표현식&lt;/h2&gt;
&lt;p&gt;위에서 언급하지 못한 패턴들은 자주 사용되는 정규 표현식들을 살펴보면서 하나씩
이해해 보면 좋을 것 같아요. 개인적으로는 사용자 입력에 대한 검증이나, 에디터에서
넓은 범위의 표현을 담은 문자열을 검색하기 위해 사용하곤 하는데, 다양한 사용처들이
있을 것 같습니다.&lt;/p&gt;
&lt;h3 id=&quot;url&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#url&quot; aria-label=&quot;url permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;URL&lt;/h3&gt;
&lt;p&gt;해당 문자열이 URL 인지 판별하기 위해 정규 표현식을 이용할 수 있습니다.
여기서 &lt;code class=&quot;language-text&quot;&gt;?&lt;/code&gt;는 바로 앞 문자가 최대 한 개(0 혹은 1) 존재하는지 테스트합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const target = &amp;#39;http://youthfulhps.dev&amp;#39;;
const regexr = /^https?/;

console.log(regexr.test(target)); // true&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;사용자-이름&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%82%AC%EC%9A%A9%EC%9E%90-%EC%9D%B4%EB%A6%84&quot; aria-label=&quot;사용자 이름 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;사용자 이름&lt;/h3&gt;
&lt;p&gt;입력창으로부터 사용자 이름을 전달받게 됩니다. 이때 한글만 허용된다는 가정과,
한국에서 가장 긴 이름인 17자까지 허용한다는 정규식으로 입력받은 이를 검증할
수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const target = &amp;#39;유병호&amp;#39;;
const regexr = /^[ㄱ-ㅎ|가-힣]{3,17}$/;

console.log(regexr.test(target)); // true&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서, &lt;code class=&quot;language-text&quot;&gt;^&lt;/code&gt;는 바로 다음으로 오는 문자 혹은 패턴으로 문자열이 시작되는지, &lt;code class=&quot;language-text&quot;&gt;$&lt;/code&gt;는
바로 직전의 문자 혹은 패턴으로 문자열이 끝나는지를 검색하는 문자 클래스입니다.&lt;/p&gt;
&lt;p&gt;이때, 천지인 키보드에서 사용되는 중간점 특수문자 또한 허용해 주어야 한다면,
다음과 같이 작성해 줄 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const target = &amp;#39;가브링·&amp;#39;; // 천지인 키보드에서 가브리엘 입력 시
const regexr = /^[ㄱ-ㅎ|가-힣|\u318D\u119E\u11A2\u2022\u2025\u00B7\uFE55]{3,17}$/;

console.log(regexr.test(target)); // true&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;핸드폰-번호&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%95%B8%EB%93%9C%ED%8F%B0-%EB%B2%88%ED%98%B8&quot; aria-label=&quot;핸드폰 번호 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;핸드폰 번호&lt;/h3&gt;
&lt;p&gt;위에 등장했던 &lt;code class=&quot;language-text&quot;&gt;\d&lt;/code&gt; 문자 클래스와 &lt;code class=&quot;language-text&quot;&gt;{}&lt;/code&gt;를 통해 핸드폰 번호 검증을 위한
정규식을 표현할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const target = &amp;#39;010-1234-5678&amp;#39;;
const regexr = /^\d{3}-\d{3,4}-\d{4}$/;

console.log(regexr.test(target)); // true&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;메일-주소&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A9%94%EC%9D%BC-%EC%A3%BC%EC%86%8C&quot; aria-label=&quot;메일 주소 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;메일 주소&lt;/h3&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const email = &amp;#39;ybh942002@gmail.com&amp;#39;;
const regexr = /^[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_\.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/;

console.log(regexr.test(email)); // true&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;숫자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%88%AB%EC%9E%90&quot; aria-label=&quot;숫자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;숫자&lt;/h3&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const regexrForWholeNumber = /^\d+$/gm; // 정수
// 45 true
// 45.5
// .5
// 0 true

const regexrForDecimalNumber = /^\d*\.\d+$/gm; // 소수
// 45
// 45.5 true
// .5 true
// 0&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h2&gt;
&lt;p&gt;이번 글에서는 정규 표현식을 알아보았습니다. 글에서 언급하지 못한 패턴들도 충분히 사용
가치가 있기 때문에 참고 자료에서 한 번씩 사용해 보면서 익혀두면 좋을 것 같아요.&lt;/p&gt;
&lt;p&gt;본 글은 자바스크립트에서 제공하는 정규 표현식 문법에 대해서 언급했지만, 여러 언어에서
정규 표현식을 사용하는 방식이 상이할 수 있으니 주의하시길 바랍니다. 긴 글 읽어주셔서
감사합니다.&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/match&quot;&gt;https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/String/match&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%A0%95%EA%B7%9C_%ED%91%9C%ED%98%84%EC%8B%9D&quot;&gt;https://ko.wikipedia.org/wiki/%EC%A0%95%EA%B7%9C_%ED%91%9C%ED%98%84%EC%8B%9D&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://curryyou.tistory.com/234&quot;&gt;https://curryyou.tistory.com/234&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wikidocs.net/4308&quot;&gt;https://wikidocs.net/4308&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[리엑트 개발 환경 구축기]]></title><description><![CDATA[실무에서 create-react-app…]]></description><link>https://youthfulhps.dev/development/react-boilerplate/</link><guid isPermaLink="false">https://youthfulhps.dev/development/react-boilerplate/</guid><pubDate>Fri, 21 Oct 2022 00:10:16 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;실무에서 create-react-app 사용하나요?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;최근에 우연히 프론트엔드 개발자를 준비하시는 지인분께서 하신 질문인데, 생각보다 개운하게
답변드리지 못했는데요. 질문을 &lt;em&gt;‘제품을 개발하기 위한 환경 구축을 밑바닥부터 스크래치 하는 지?’&lt;/em&gt;
로 생각해보면 사실 경험이 적었다는 걸 스스로 느꼈던 것 같아요.&lt;/p&gt;
&lt;p&gt;주로 다루어왔던 next.js 프로젝트의 경우 어느정도 구조 컨벤션이 정해져 있는터라,
감사하게 &lt;code class=&quot;language-text&quot;&gt;create-next-app&lt;/code&gt; 을 기꺼이 사용해왔던 것 같고, &lt;code class=&quot;language-text&quot;&gt;create-react-app&lt;/code&gt; 을 통해
프로젝트를 생성하면, 꽤나 큰 보일러플레이트 덩치와 설정을 커스텀하기 불편하다는 걸 직접 느낀
경험이 없는 걸 보면 아직 멀었다 싶기도 하면서, 어떤 불편함인지 궁금하기도 했습니다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;create-react-app 없이도 프로젝트를 설계하실 수 있으면 좋지 않을까요?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;이왕 이렇게 대답한 김에 저도 희미해진 개발 환경 구축에 대한 기억들을 한곳에
모아두고자 리엑트 개발 환경을 밑바닥부터 스크래치해보고 글로 정리해두려 합니다.
겸사겸사 개인 보일러플레이트도 만들어두고 싶으신 분들께 도움이 되셨으면 좋겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;자바스크립트-패키지-관리-환경&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%8C%A8%ED%82%A4%EC%A7%80-%EA%B4%80%EB%A6%AC-%ED%99%98%EA%B2%BD&quot; aria-label=&quot;자바스크립트 패키지 관리 환경 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;자바스크립트 패키지 관리 환경&lt;/h2&gt;
&lt;p&gt;프로젝트에서 노드 런타임에서 동작하는 패키지들을 관리하기 위해 yarn을 사용하려 합니다.
yarn으로 관리되는 프로젝트를 초기화하기 위해 다음과 같은 명령어를 사용해봅시다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ yarn init -y&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;패키지 json의 등장&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// package.json
{
  &amp;quot;name&amp;quot;: &amp;quot;react-boilerplate&amp;quot;,
  &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;,
  &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;,
  &amp;quot;repository&amp;quot;: &amp;quot;git@github.com:youthfulhps-tutorial/react-boilerplate.git&amp;quot;,
  &amp;quot;author&amp;quot;: &amp;quot;youthfulhps &amp;lt;ybh942002@gmail.com&amp;gt;&amp;quot;,
  &amp;quot;license&amp;quot;: &amp;quot;MIT&amp;quot;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;리엑트-의존성-설치&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%EC%97%91%ED%8A%B8-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%84%A4%EC%B9%98&quot; aria-label=&quot;리엑트 의존성 설치 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리엑트 의존성 설치&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ yarn add react react-dom&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;package.json에서 dependencies 추가됨
짚고 넘어가자면, 빌드시에 패키지가 필요한가? 라는 질문이 필요하다.
타입스크립트의 타입 선언문은 런타임에서 모두 제거가 되고, 마찬가지로 빌드 단계에서
모두 제거된다. 즉, 타입 선언 패키지의 경우 devDependencies에 포함되어야 한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// package.json
{
  ...
  &amp;quot;dependencies&amp;quot;: {
    &amp;quot;react&amp;quot;: &amp;quot;^18.2.0&amp;quot;,
    &amp;quot;react-dom&amp;quot;: &amp;quot;^18.2.0&amp;quot;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;타입스크립트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8&quot; aria-label=&quot;타입스크립트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;타입스크립트&lt;/h2&gt;
&lt;p&gt;설정한번 들쳐보면 좋을 듯??&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// tsconfig.json
{
  &amp;quot;compilerOptions&amp;quot;: {
    &amp;quot;target&amp;quot;: &amp;quot;esnext&amp;quot;,
    &amp;quot;module&amp;quot;: &amp;quot;esnext&amp;quot;,
    &amp;quot;jsx&amp;quot;: &amp;quot;react-jsx&amp;quot;,
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,
    &amp;quot;sourceMap&amp;quot;: true,
    &amp;quot;isolatedModules&amp;quot;: true,
    &amp;quot;strict&amp;quot;: true,
    &amp;quot;noImplicitAny&amp;quot;: true,
    &amp;quot;esModuleInterop&amp;quot;: true,
    &amp;quot;noEmit&amp;quot;: true,
    &amp;quot;baseUrl&amp;quot;: &amp;quot;./&amp;quot;,
    &amp;quot;paths&amp;quot;: {
      &amp;quot;@/*&amp;quot;: [&amp;quot;src/*&amp;quot;]
    },
    &amp;quot;typeRoots&amp;quot;: [&amp;quot;node_modules/@types&amp;quot;],
    &amp;quot;allowSyntheticDefaultImports&amp;quot;: true
  },
  &amp;quot;include&amp;quot;: [&amp;quot;src&amp;quot;],
  &amp;quot;exclude&amp;quot;: [&amp;quot;node_modules&amp;quot;, &amp;quot;dist&amp;quot;]
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;타입-선언-패키지-의존성-추가&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8-%ED%8C%A8%ED%82%A4%EC%A7%80-%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%B6%94%EA%B0%80&quot; aria-label=&quot;타입 선언 패키지 의존성 추가 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;타입 선언 패키지 의존성 추가&lt;/h2&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ yarn add --dev typescript @types/react @types/react-dom&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;긴장되는-웹팩-설정&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B8%B4%EC%9E%A5%EB%90%98%EB%8A%94-%EC%9B%B9%ED%8C%A9-%EC%84%A4%EC%A0%95&quot; aria-label=&quot;긴장되는 웹팩 설정 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;긴장되는 웹팩 설정&lt;/h2&gt;
&lt;p&gt;웹팩 번들러를 사용하기 위한 의존성 추가&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ yarn add --dev webpack webpack-cli webpack-dev-server&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;웹 구성에 사용되는 모든 자원을 웹팩에서는 모듈이라 부르며, 빌드 단계에서
각각의 모듈에 맞게 개별 파일들을 불러와 파싱할 수 있도록 관련 로더들을 추가한다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ yarn add --dev ts-loader css-loader style-loader file-loader html-webpack-plugin&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;프로젝트에서 활용되는 환경변수 관리를 위해&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~% yarn add dotenv&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;webpack.config.js 파일 작성&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;require(&amp;#39;dotenv&amp;#39;).config();

const path = require(&amp;#39;path&amp;#39;);
const HtmlWebpackPlugin = require(&amp;#39;html-webpack-plugin&amp;#39;);

const isProd = process.env.NODE_ENV === &amp;#39;production&amp;#39;;
const PORT = process.env.PORT || 3000;

module.exports = {
  mode: isProd ? &amp;#39;production&amp;#39; : &amp;#39;development&amp;#39;,
  devtool: isProd ? &amp;#39;hidden-source-map&amp;#39; : &amp;#39;source-map&amp;#39;,
  entry: &amp;#39;./src/index.tsx&amp;#39;,
  output: {
    filename: &amp;#39;[name].js&amp;#39;,
    path: path.join(__dirname, &amp;#39;/dist&amp;#39;),
  },
  resolve: {
    modules: [&amp;#39;node_modules&amp;#39;],
    extensions: [&amp;#39;.js&amp;#39;, &amp;#39;.jsx&amp;#39;, &amp;#39;.ts&amp;#39;, &amp;#39;.tsx&amp;#39;],
  },
  module: {
    rules: [
      {
        test: /\.(ts|tsx)$/,
        loader: &amp;#39;ts-loader&amp;#39;,
        options: {
          transpileOnly: !isProd,
        },
      },
      {
        test: /\.css?$/,
        use: [&amp;#39;style-loader&amp;#39;, &amp;#39;css-loader&amp;#39;],
      },
      {
        test: /\.(webp|jpg|png|jpeg)$/,
        loader: &amp;#39;file-loader&amp;#39;,
        options: {
          name: &amp;#39;[name].[ext]?[hash]&amp;#39;,
        },
      },
    ],
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname, &amp;#39;public&amp;#39;, &amp;#39;index.html&amp;#39;),
      hash: true,
    }),
  ],
  devServer: {
    contentBase: path.resolve(__dirname, &amp;#39;public&amp;#39;),
    host: &amp;#39;localhost&amp;#39;,
    port: PORT,
    open: true,
    hot: true,
    compress: true,
    historyApiFallback: true,
    overlay: true,
    stats: &amp;#39;errors-only&amp;#39;,
  },
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;</content:encoded></item><item><title><![CDATA[리엑트 메모이제이션 셀프 코칭]]></title><description><![CDATA[…]]></description><link>https://youthfulhps.dev/react/memoization/</link><guid isPermaLink="false">https://youthfulhps.dev/react/memoization/</guid><pubDate>Wed, 21 Sep 2022 11:10:23 GMT</pubDate><content:encoded>&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 978px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACxklEQVQoz12RW0iTYRiA/9x56jZ3UNvmfndorenm3FzGlgckSjsoakVWooJoSTchkXQgKqIyosBICoUONxGkFJVFZURQhKbdmEGSQhJ0E9RtF0/fnDd28cDLx/c+70ly+aNYXEEi66LU1zVTsqGWgrVlmBweMs15aAxmFLosFFq9QIsyhUaLQq0hYwn1MiJWqZE8gfVYCkNUhyJ0NDRTVF6LUxQxO9egz7Fjyi0gXpYkVBxFm20SQj2qlHxJmhanSceSxe5Fl5PPWqdMeXEEuzdM6s0gRAqdkVDJeiLhGIUFPsxWhxAtC9Xa/0iLJaNI1ButaLLNSBkZKEXbqQSVRofeYMLnCxIsdNNdt5m6REL8UaEUicoV3aVQo0iNbFntJccmi/EcuBwyzQE3DqsNVaYJpxzEmuemsSzK9Y49bE9WkZ3rxWRzimTtSqlqeYfmfA8mqwuDRaa9vYfe+h0EZR82d4icXA+SlEl15RYG+06Q2FCDUxzQYfej0hnEFGmpclmYQsqyusU1XWTozRSHYiT9AdxOL75QBbFwnPNHj/Hy+WvGX3/g6dgbJt9P091+QBSSkNR6gQ5JdCupRKwU+C0G/BYjniwtRYVBSmUPriwdJWUbGTp1nNtHDvFi5DFvxt8xO7vA3PxPJqa+0tbWhV2/itWZSvJ1Ao1EnloUqdz0jJq6VzTUXKapaivbt/VRnriCt2gf4VAlVy8PsPj9F3NzP5j9ssjM5++CeQYGx4hXPKIqcpiKwF6CsQeEI8NIu0ubKC3ahcNXS+v+bvovXaP/6ihbN7Zyof8mv//8ZWZmgY+Ts0xPf2Xy0zc6Ow/hNso0JntpTbawN9ZCfeIi2+JHkbpKAzREw8g2O8cPHubJ3XsMnzvDjRN9vH82ztTbCZ7ef8jI0G1ejY5xtruHpFhPi8dHbzxKf+0mBvbs5M7JPm6dOc0/P+Z1358vUm4AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;A person who searches for values in complex records&quot;
        title=&quot;A person who searches for values in complex records&quot;
        src=&quot;/static/a74f6a6ddb4b017b1700cbe4d3036caf/914c7/thumbnail.png&quot;
        srcset=&quot;/static/a74f6a6ddb4b017b1700cbe4d3036caf/5a46d/thumbnail.png 300w,
/static/a74f6a6ddb4b017b1700cbe4d3036caf/0a47e/thumbnail.png 600w,
/static/a74f6a6ddb4b017b1700cbe4d3036caf/914c7/thumbnail.png 978w&quot;
        sizes=&quot;(max-width: 978px) 100vw, 978px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;보통 어플리케이션에서 최적화를 위해 메모이제이션 기법을 통해 이전에 계산한 값을 메모리에
저장해두고, 동일하게 다시 사용할 수 있는 곳에서 재사용하여 반복적으로 발생하는 계산의
리소스를 줄이는 기법을 사용하곤 합니다.&lt;/p&gt;
&lt;p&gt;리엑트에서도 메모이제이션을 쉽게 구현할 수 있도록 도와주는 API들이 존재하는데요.
리엑트 공식문서에서 우리가 잘 알고 있는 &lt;a href=&quot;https://ko.reactjs.org/docs/hooks-reference.html#usememo&quot;&gt;useMemo&lt;/a&gt;
에 대해 다음과 같이 설명하고 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;“생성(create)” 함수와 그것의 의존성 값의 배열을 전달하세요. useMemo는 의존성이
변경되었을 때에만 메모이제이션된 값만 다시 계산 할 것입니다. 이 최적화는 모든 렌더링 시의
고비용 계산을 방지하게 해 줍니다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;사실, useMemo를 포함하여 useCallback과 React.memo에 대한 의론적인 배움을 얻고
사용해왔지만 최근 다시금 공식 문서를 읽었을 때, 문서에서 말하는 고비용의 기준은 무엇인지,
사용할 수는 있지만 보장되어 있지 않다는 문구의 의미는 무엇인지 등등, 역시 명확한 기준을 제공하지
않는 리엑트의 모습을 보면서 내가 적절하게 잘 이해하고 적재적소에 사용하며, 실질적인 성능 최적화를
이루고 있는 건가에 대한 의구심이 들었습니다.&lt;/p&gt;
&lt;p&gt;이 글은 갑자기 낯설게 느껴지는 리엑트 메모이제이션에 대한 찝찝함을 이겨내고자 셀프 코칭해보며
조금 더 깊게 알아보고, 가능하면 최적화에 대한 스스로의 기준도 정해보려 합니다. 비슷한 고민을
하시는 분들에게 도움이 될 수 있으면 좋겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;usememo-메모이제이션된-값을-반환한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#usememo-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EB%90%9C-%EA%B0%92%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;usememo 메모이제이션된 값을 반환한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;useMemo, 메모이제이션된 값을 반환한다&lt;/h2&gt;
&lt;p&gt;우선 우리가 잘 알고 있는 리엑트의 메모이제이션을 위한 API를 살펴봅시다. 그 첫 번째로 useMemo는
값을 메모이제이션합니다. 같은 말로, 메모이제이션된 값을 반환합니다.&lt;/p&gt;
&lt;p&gt;리엑트에서 사용되는 훅들은 &lt;a href=&quot;https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js#L2599&quot;&gt;HookDispatcher&lt;/a&gt;
라는 이름으로 Disaptcher 인터페이스를 갖는 객체로 래핑되어 내부에서 공유되는데,
여기서 useMemo를 찾아볼 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const HooksDispatcher...: Dispatcher = {
  ...
  useMemo: updateMemo,
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;em&gt;onMount, onRerender, onUpdate에 따라 사용되는 HooksDispatcher 객체가 각각 구현되어 있어
변수명에 (…)을 표기하였습니다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;여기서 useMemo는 updateMemo 라는 함수로 그 구현체가 정의되고 있는데요. 우리가 이해하고 있는
useMemo의 역할을 코드로 확인해봅시다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function updateMemo&amp;lt;T&amp;gt;(
  nextCreate: () =&amp;gt; T,
  deps: Array&amp;lt;mixed&amp;gt; | void | null
): T {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;

  if (prevState !== null) {
    if (nextDeps !== null) {
      const prevDeps: Array&amp;lt;mixed&amp;gt; | null = prevState[1];
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }

  const nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];

  return nextValue;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;먼저 updateMemo()의 파라미터 nextCreate, deps는 우리가 사용하는 useMemo에서
메모이제이션할 값을 연산하기 위한 콜백 함수, 그리고 특정값이 변할 때만 새롭게 메모이제이션
될 수 있도록 전달하는 deps와 대응됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function updateMemo&amp;lt;T&amp;gt;(
  nextCreate: () =&amp;gt; T,
  deps: Array&amp;lt;mixed&amp;gt; | void | null,
): T {
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;함수 내부에서는 로직 전개를 위해 활용될 세 가지의 변수를 가지고 있는데, 여기서 hook
에는 어떤 값이 할당될까요?&lt;/p&gt;
&lt;p&gt;위에서 봤던 리엑트의 Dispatcher 객체와 마찬가지로, 훅은 &lt;a href=&quot;https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js#L159&quot;&gt;Hook&lt;/a&gt;
이라는 인터페이스를 가진 객체로 되는데, updateWorkInProgressHook()은
훅으로 관리하고자 하는 값에 대해 직전 랜더링 환경에서 대응되는 훅 객체를 반환하고,
대응되는 훅 객체가 없다면 새로운 훅 객체를 생성하여 반환합니다.&lt;/p&gt;
&lt;p&gt;nextDeps는 파라미터로 전달받은 deps를, prevState는 직전 랜더링 환경에서 메모이제이션되어
있던 값을 참조합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export type Hook = {
  memoizedState: any;
  baseState: any;
  baseQueue: Update&amp;lt;any, any&amp;gt; | null;
  queue: any;
  next: Hook | null;
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  ...
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;
  ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;결국, useMemo는 직전 훅 객체에 메모이제이션된 값과 전달된 deps가 null이
아니라면, deps로 전달받은 값들이 변경되지 않았음을 검증하는 단계를 거쳐
메모제이션된 값을 반환합니다.
&lt;em&gt;&lt;a href=&quot;https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js#L343&quot;&gt;areHookInputsEqual()&lt;/a&gt;은 여기서!&lt;/em&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  ...
  if (prevState !== null) {
    if (nextDeps !== null) {
      // 여기서 prevState는 [value, deps]의 형태
      const prevDeps: Array&amp;lt;mixed&amp;gt; | null = prevState[1];
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }
  ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;분기 검증에 실패했다면, 값을 얻기 위한 콜백 함수인 nextCreate()를 통해 값을 구하고,
현재 새로운 훅 객체의 memoizedState에 deps와 함께 할당합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  ...
  const nextValue = nextCreate();
  hook.memoizedState = [nextValue, nextDeps];

  return nextValue;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;useMemo의 구현체 코드를 보니 콜백함수와 deps를 전달하면, deps가 참조하고 있는 값이 변경되지 않는 한
메모이제이션된 값을 다시 사용하는 기능을 잘 이해하고 있음을 확인할 수 있었습니다. :)&lt;/p&gt;
&lt;h2 id=&quot;usecallback-메모이제이션된-콜백을-반환한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#usecallback-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EB%90%9C-%EC%BD%9C%EB%B0%B1%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;usecallback 메모이제이션된 콜백을 반환한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;useCallback, 메모이제이션된 콜백을 반환한다&lt;/h2&gt;
&lt;p&gt;useCallback은 인자값으로 전달받은 콜백 함수를 메모이제이션합니다.
예상할 수 있듯, useCallback의 구현체는 useMemo 구현체와 매우 유사하기 때문에 특별히 다른 부분만 짚고 넘어가겠습니다.&lt;/p&gt;
&lt;p&gt;useCallback는 updateCallback 이라는 함수로 그 구현체가 정의되어 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const HooksDispatcher...: Dispatcher = {
  ...
  useCallback: updateCallback,
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;updateCallback은 updateMemo와 달리, 파라미터로 전달받은 callback 자체를
메모이제이션하는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function updateCallback&amp;lt;T&amp;gt;(callback: T, deps: Array&amp;lt;mixed&amp;gt; | void | null): T {
  const hook = updateWorkInProgressHook();
  const nextDeps = deps === undefined ? null : deps;
  const prevState = hook.memoizedState;
  if (prevState !== null) {
    if (nextDeps !== null) {
      const prevDeps: Array&amp;lt;mixed&amp;gt; | null = prevState[1];
      if (areHookInputsEqual(nextDeps, prevDeps)) {
        return prevState[0];
      }
    }
  }

  // callback 자체를 메모이제이션한다.
  hook.memoizedState = [callback, nextDeps];
  return callback;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;우리가 잘 이해하고 있는 것 처럼, useMemo는 콜백 함수의 연산 반환값을, useCallback은
콜백 자체를 메모이제이션하는 기능 차이를 확인할 수 있었습니다.&lt;/p&gt;
&lt;h2 id=&quot;reactmemo-랜더링된-결과를-재사용한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reactmemo-%EB%9E%9C%EB%8D%94%EB%A7%81%EB%90%9C-%EA%B2%B0%EA%B3%BC%EB%A5%BC-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;reactmemo 랜더링된 결과를 재사용한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;React.memo, 랜더링된 결과를 재사용한다&lt;/h2&gt;
&lt;p&gt;React.memo는 고차 컴포넌트로서 감싼 컴포넌트 랜더링 결과를 메모이징하고, 동일한 props로
동일한 결과를 랜더링하는 경우에 대하여 다시 랜더링하지 않고, 다시 마지막으로 랜더링된 결과를
재사용합니다.&lt;/p&gt;
&lt;p&gt;공식문서에 첨언된 내용에는, React.memo가 props 변화에만 영향을 준다고 설명합니다. 즉,
컴포넌트 리랜더링이 발생하는 케이스들 중에서 부모 컴포넌트로부터 전달받은 props의 변화로 인해
발생하는 리랜더링 최적화를 담당합니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react/blob/main/packages/react/src/ReactMemo.js&quot;&gt;React.memo&lt;/a&gt;의 구현체를 살펴보면, 엄청난 일이 벌어질 것 같은 예상과는 달리 명확한 단일의 역할만을 담당하고
있는 고차 컴포넌트의 면모를 잘 보여줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Symbol.for(&amp;#39;react.memo&amp;#39;);
import {REACT_MEMO_TYPE} from &amp;#39;shared/ReactSymbols&amp;#39;;
...

export function memo&amp;lt;Props&amp;gt;(
  type: React$ElementType,
  compare?: (oldProps: Props, newProps: Props) =&amp;gt; boolean,
) {
  ...
  const elementType = {
    $$typeof: REACT_MEMO_TYPE,
    type,
    compare: compare === undefined ? null : compare,
  };
  ...
  return elementType;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;개인적으로 생각하는 주목할 점은, React.memo로 감싼 컴포넌트가 react.memo 심볼을
요소 유형 태그로 할당받게 된다는 점입니다.&lt;/p&gt;
&lt;p&gt;컴포넌트 재조정을 위한 작업을 생성하는 리엑트 리콘실러에서 beginWork() 라는 함수에서는
위에서 언급한 요소의 유형 태그를 통해 어떤 방식으로 업데이트를 진행할 지 결정합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function beginWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  ...
  switch (workInProgress.tag) {
    ...
    case MemoComponent: {
      ...
      resolvedProps = resolveDefaultProps(type.type, resolvedProps);
      return updateMemoComponent(
        current,
        workInProgress,
        type,
        resolvedProps,
        renderLanes,
      );
    }
    ...
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서, React.memo에서 할당된 ‘react.memo’ 심볼 유형 태그를 가진 컴포넌트는
MemoComponent로 구분되어 업데이트 작업이 진행되는데, 우리가 흔히 사용하는 함수형
컴포넌트와 다르게 업데이트 과정이 진행될 것이라고 짐작할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;beginWork()를 간추려 첨부했지만, 엄청난 일은 여기서 일어나고 있었구나 싶을 정도로
요소 유형별 각기 다른 업데이트 방식으로 분류됩니다. 모두 살펴보기엔 일이 커지니 (사실, 무섭습니다.)
메모 컴포넌트가 어떻게 업데이트되는 지 살펴봅시다.&lt;/em&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function updateMemoComponent(
  current: Fiber | null,
  workInProgress: Fiber,
  Component: any,
  nextProps: any,
  renderLanes: Lanes,
): null | Fiber {
  ...
  const currentChild = ((current.child: any): Fiber);
  const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(
    current,
    renderLanes,
  );
  if (!hasScheduledUpdateOrContext) {
    const prevProps = currentChild.memoizedProps;
    // Default to shallow comparison
    let compare = Component.compare;
    compare = compare !== null ? compare : shallowEqual;
    if (compare(prevProps, nextProps) &amp;amp;&amp;amp; current.ref === workInProgress.ref) {
      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);
    }
  }

  workInProgress.flags |= PerformedWork;
  const newChild = createWorkInProgress(currentChild, nextProps);
  newChild.ref = workInProgress.ref;
  newChild.return = workInProgress;
  workInProgress.child = newChild;
  return newChild;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;React.memo가 전달받는 컴포넌트와 props 비교 기준이 되는 compare은 이곳에서 사용되는데요.
만약 compare을 전달하지 않는다면, shallowEqual 즉, 얕은 비교를 통해 이전 props와
새로운 props를 비교하고, 이 둘이 같지 않다고 판단되면 새롭게 자식트리가 조정됩니다.&lt;/p&gt;
&lt;p&gt;반면, 동일하다고 판단되면 bailoutOnAlreadyFinishedWork()에 의해서 이전에 사용된 자식트리가
클론되어 재사용됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function bailoutOnAlreadyFinishedWork(
  current: Fiber | null,
  workInProgress: Fiber,
  renderLanes: Lanes,
): Fiber | null {
  ...
  // This fiber doesn&amp;#39;t have work, but its subtree does. Clone the child
  // fibers and continue.
  cloneChildFibers(current, workInProgress);
  return workInProgress.child;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;복잡하고 험난했지만, 이전 props와 새로운 props가 동일하다면 마지막 랜더링된 결과를
재사용하기 위해 React.memo로 감싸주면 되겠구나 이해할 수 있었습니다.&lt;/p&gt;
&lt;h2 id=&quot;usecallback-참조-동일성에-최적화된-컴포넌트에-유효하다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#usecallback-%EC%B0%B8%EC%A1%B0-%EB%8F%99%EC%9D%BC%EC%84%B1%EC%97%90-%EC%B5%9C%EC%A0%81%ED%99%94%EB%90%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90-%EC%9C%A0%ED%9A%A8%ED%95%98%EB%8B%A4&quot; aria-label=&quot;usecallback 참조 동일성에 최적화된 컴포넌트에 유효하다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;useCallback, 참조 동일성에 최적화된 컴포넌트에 유효하다&lt;/h2&gt;
&lt;p&gt;리엑트는 props의 변경 여부를 얕은 비교를 통해 판단합니다. 자바스크립트에서 원시 타입 값은
참조값이 다르더라도 값이 같다면 일치 연산자(strict equality operator)에 의해 참이
판단되지만, 객체, 배열, 함수와 같은 객체는 같은 참조값이 아니라면, 즉 서로 다른 메모리에
할당되어 있다면 거짓으로 판단됩니다.&lt;/p&gt;
&lt;p&gt;가령 부모 컴포넌트의 상태가 변경되면, 내부에 선언되어 있는 함수들은 모두 새로운 메모리에
작성됩니다. 결국 자식 컴포넌트 입장에서 이전 onClick의 참조값과 새로운 onClick의 참조값이
변경되었으니, 자식 컴포넌트도 리랜더링이 발생합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const ChildA = ({ onClick }) =&amp;gt; {
  return &amp;lt;button onClick={onClick}&amp;gt;ChildA&amp;lt;/button&amp;gt;;
};

const ChildB = ({ onClick }) =&amp;gt; {
  return &amp;lt;button onClick={onClick}&amp;gt;ChildB&amp;lt;/button&amp;gt;;
};

function Parent() {
  const [isGood, setIsGood] = useState(false);
  const handleChildAClick = () =&amp;gt; {
    setIsGood(!isGood);
  };

  const handleChildBClick = () =&amp;gt; {
    console.log(&amp;#39;ChildB clicked!&amp;#39;);
  };

  return (
    &amp;lt;&amp;gt;
      &amp;lt;ChildA onClick={handleChildAClick} /&amp;gt;
      &amp;lt;ChildB onClick={handleChildBClick} /&amp;gt;
    &amp;lt;/&amp;gt;
  );
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서, ChildA에 전달되는 클릭 핸들러는 isGood 상태에 의존적인 핸들러로 useCallback을
사용해도 의존된 값이 항상 변경되니 무용지물입니다.
하지만, ChildB는 부모 컴포넌트의 상태에 독립적인 핸들러를 전달받음에도 ChildA의 버튼이
클릭되면 새롭게 생성되는 ChildB 클릭 핸들러로 인해 리랜더링이 발생하는 것은 억울합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 643px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 24.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABE0lEQVQY052O30rCYADF90ZdRE8R9AI9S2/QTV11UUgQZhiYjyBo0FykQW3TZFaIuk+Xc81tftt+fbouuu7A4fy5OBzNjyFa5yyCmGWc46rsS3AjEH7ESuVQ5ST4pDO0WSQg45RUdRvkeb5VKSWmaaIFTpNg2CKfGvDVRYou4aS79cyfwOsU3jNYjVqwdBiNxliWjSsEm7lMjUqZYts22nH1hNO7M0qNMpXHOpV2jYpRo6z0+lcLX+dKv6U5eGDmuljmC+9DhyxLi6dZxlu/j6aPJxhTF30qaM88dDEvOCvY/sN7VzD4Dpl7C55fe/SdD4IwIlU3Y/XQsnto/ANHjTX7NzEH1YS9S8luSbJznnB4YfEDsl9sDG6rQH4AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Rerendering chart of childB component&quot;
        title=&quot;Rerendering chart of childB component&quot;
        src=&quot;/static/d6bf574a3af106c463ddcadd467ea2ec/b5bda/childB-rerendering-chart.png&quot;
        srcset=&quot;/static/d6bf574a3af106c463ddcadd467ea2ec/5a46d/childB-rerendering-chart.png 300w,
/static/d6bf574a3af106c463ddcadd467ea2ec/0a47e/childB-rerendering-chart.png 600w,
/static/d6bf574a3af106c463ddcadd467ea2ec/b5bda/childB-rerendering-chart.png 643w&quot;
        sizes=&quot;(max-width: 643px) 100vw, 643px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;그럼, ChildB에게 전달되는 핸들러를 useCallback으로 감싸주면 리랜더링을 방지할 수 있을 것 같지만,
기대와는 다르게 마찬가지로 리랜더링이 발생합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const handleChildBClick = useCallback(() =&amp;gt; {
  console.log(&amp;#39;ChildB clicked!&amp;#39;);
}, []);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 24%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABCUlEQVQY052Oy0rDUBRF81X2Kxz5KzoWf0CRNjrUDn0MBTEgorOK6UxMtDbF2EfS9N3c3tw8lrfBzhy5YZ294RwO2xAKkrRgsZTECUQSlimMdR7PVqh0vdeIKa5zTyggVxlK321UFEXpSaIweu4D/dYT824DObSJek36vq1zExG8sArtEhk8M/EfiUcOwzDgzXHxfZ9EKdb/cj2yLMfYNffYPzvg8OaYqnVCzaphWibVO83GNTXrlKPbKpeNKybTMe+uQ8drI4TY9Cyn0Qp82mEXL+rTGQ3wfun8wWfUY7CYMJ3NeXU+8L6+WcSifJXluqFuafAPmXbK9oVk51pSOZds1VMqdaVJ+QHZp2rQp/rpiwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Rerendering chart of childB component with useCallback&quot;
        title=&quot;Rerendering chart of childB component with useCallback&quot;
        src=&quot;/static/70bd67b3e24d84747e8eb1a2103ebf5c/a6d36/childB-rerendering-chart-with-useCallback.png&quot;
        srcset=&quot;/static/70bd67b3e24d84747e8eb1a2103ebf5c/5a46d/childB-rerendering-chart-with-useCallback.png 300w,
/static/70bd67b3e24d84747e8eb1a2103ebf5c/0a47e/childB-rerendering-chart-with-useCallback.png 600w,
/static/70bd67b3e24d84747e8eb1a2103ebf5c/a6d36/childB-rerendering-chart-with-useCallback.png 650w&quot;
        sizes=&quot;(max-width: 650px) 100vw, 650px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;useCallback은 참조 동일성에 최적화된 컴포넌트에 유효합니다. 즉, 부모 컴포넌트의 상태에 독립적인 콜백을
useCallback으로 감싸고, 전달받는 자식 컴포넌트 또한 React.memo로 감싸서 props를 얕은 비교하는
과정을 통해 직전 자식 트리를 재사용하는 과정이 포함할 수 있도록 해야 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const ChildB = memo(({ onClick }) =&amp;gt; {
  return &amp;lt;button onClick={onClick}&amp;gt;ChildB&amp;lt;/button&amp;gt;;
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 664px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 23.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA7klEQVQY032Qz0rDQBCH81SCj6DP4CN58ahoRE9SUPDoXa8egqYJNQbEHGJDa9J2083++dxsclARB76Z2Z0fw48JjAEhYVFvEa7/2MKngmUHzUb52dphZU30dEcpQEuNdpo+rLWePrpOEST3h1TRCTo7w7yGVHFInYbY/Nz/6Sz0mOyUdXyEertmPq+YTlOKoqDfZVzyOHfB5OGGZplD64bi3dUR8ZvCa5Alq1VDmsTM0gTZCkavPgf8eA71L75rmo3geZYTJS+UiwbpTtUq6wl6m/4G4y3+Q5th/fGjYu+q5eBWsj9R7Fwodi8HvgDsKnfUBZx89wAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Rerendering chart of childB component with useCallback and memo&quot;
        title=&quot;Rerendering chart of childB component with useCallback and memo&quot;
        src=&quot;/static/d7911b2f9b50d1bec5cd11a36004542f/31493/childB-rerendering-chart-with-useCallback-and-memo.png&quot;
        srcset=&quot;/static/d7911b2f9b50d1bec5cd11a36004542f/5a46d/childB-rerendering-chart-with-useCallback-and-memo.png 300w,
/static/d7911b2f9b50d1bec5cd11a36004542f/0a47e/childB-rerendering-chart-with-useCallback-and-memo.png 600w,
/static/d7911b2f9b50d1bec5cd11a36004542f/31493/childB-rerendering-chart-with-useCallback-and-memo.png 664w&quot;
        sizes=&quot;(max-width: 664px) 100vw, 664px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;메모이제이션-어떻게-잘-사용할-수-있을까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%98-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C&quot; aria-label=&quot;메모이제이션 어떻게 잘 사용할 수 있을까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;메모이제이션, 어떻게 잘 사용할 수 있을까&lt;/h2&gt;
&lt;p&gt;리엑트 메모이제이션에 대해 조금 더 깊게 이해해보기 위해 구현체도 살펴보고, 예제도 간단하게
구현해보았습니다.&lt;/p&gt;
&lt;p&gt;개념이 명확해지고 어느정도 자신감을 얻었지만 가능하면 최적화에 대한 스스로의 기준도 정해보겠다던
목표에는 아직 닿지 못한 것 같아 최적화에 대해 먼저 고민하고 정리해주신 레퍼런스들을 읽고
추합해보면서 개인적인 첨언도 정리해볼까 합니다.&lt;/p&gt;
&lt;h3 id=&quot;최적화를-위한-코드도-비용이다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%B5%9C%EC%A0%81%ED%99%94%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%BD%94%EB%93%9C%EB%8F%84-%EB%B9%84%EC%9A%A9%EC%9D%B4%EB%8B%A4&quot; aria-label=&quot;최적화를 위한 코드도 비용이다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;최적화를 위한 코드도 비용이다&lt;/h3&gt;
&lt;p&gt;자주 간과하기 쉬운 주제인 것 같습니다. 가령, 위 단락의 예시에서 ChildA에게 전달하는 핸들러에도
useCallback으로 감싸주었다고 생각해봅시다. 그렇다면, 잦은 변경이 발생하는 isGood 상태값에
의존적인 콜백은 결국 모든 랜더링 과정에서 새롭게 작성될 겁니다.&lt;/p&gt;
&lt;p&gt;결론적으로는 useCallback을 사용하나, 사용하지 않으나 같은 과정이 유발되는데, 여기서 useCallback의
사용으로 인해 늘어난 코드만큼 비용 또한 늘어났다는 것을 기억해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.rinae.dev/posts/review-when-to-usememo-and-usecallback#%EB%8D%94-%EB%A7%8E%EC%9D%80-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EB%8D%94-%EB%A7%8E%EC%9D%80-%EC%BD%94%EB%93%9C%EB%8A%94-%EA%B2%B0%EA%B5%AD-%EB%8D%94-%EB%A7%8E%EC%9D%80-%EB%B9%84%EC%9A%A9%EC%9D%84-%EC%B4%88%EB%9E%98%ED%95%9C%EB%8B%A4&quot;&gt;‘When to useMemo and useCallback’ 를 읽고&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;최적화-코드를-이슈-원인으로-열어두자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%B5%9C%EC%A0%81%ED%99%94-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%B4%EC%8A%88-%EC%9B%90%EC%9D%B8%EC%9C%BC%EB%A1%9C-%EC%97%B4%EC%96%B4%EB%91%90%EC%9E%90&quot; aria-label=&quot;최적화 코드를 이슈 원인으로 열어두자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;최적화 코드를 이슈 원인으로 열어두자&lt;/h3&gt;
&lt;p&gt;특정 이슈를 만났을 때, ‘로직의 문제’ 로만 국한되어 접근을 한 경우가 자주 있었습니다.
아직 부족한 실력탓에 여러 번 삽질 끝에서야 메모이제이션된 값이 적절하게 업데이트되지 않았음을
깨닫습니다.&lt;/p&gt;
&lt;p&gt;내가 과거에 작성한 최적화 코드라면, 아마 어설프고 우연한 사용으로 디버깅에 고생할 현재는 생각하지 않고 열심히
뿌듯해 했을텐데요. 우연히 적용한 최적화가 아니라, 최적화를 하겠다고 스스로 약속을 하고
습관이 될 때까지 항상 상기하는 것이 중요하지 않을까 싶은 대목입니다.&lt;/p&gt;
&lt;h3 id=&quot;의존된-참조값이-많음을-의심하자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%98%EC%A1%B4%EB%90%9C-%EC%B0%B8%EC%A1%B0%EA%B0%92%EC%9D%B4-%EB%A7%8E%EC%9D%8C%EC%9D%84-%EC%9D%98%EC%8B%AC%ED%95%98%EC%9E%90&quot; aria-label=&quot;의존된 참조값이 많음을 의심하자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;의존된 참조값이 많음을 의심하자&lt;/h3&gt;
&lt;p&gt;하단 레퍼런스에서는, 범위 내의 소수들을 모두 구하고 랜더링하는 작업을 진행합니다. 이런 경우 우리가 흔히
생각하는 ‘고비용 계산’의 정말 좋은 예시라고 생각합니다. 더불어 인터렉션에 의해 체이닝된 메서드들의 계산을
요구한다면 메모이제이션된 값을 사용할 수 있을 지 충분한 고려가 필요합니다.&lt;/p&gt;
&lt;p&gt;하지만 ‘고비용 계산’의 기준이 쉽게 와닿지 않는다면, 메모이제이션한 값 혹은 콜백이 의존한 외부 값들의
정량적인 양으로 최적화에 대한 의심을 해볼 수 있을 겁니다.
의존한 값이 많으면, 의존한 값이 변경됨에 따른 이펙트들에 의해 영향을 받을 가능성이 높고, 위의 예시처럼
의존된 값의 잦은 변경으로 인해 최적화 하나 마나가 될 수 있는 케이스를 유발할 수 있게 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@yujso66/%EB%B2%88%EC%97%AD-usememo-%EA%B7%B8%EB%A6%AC%EA%B3%A0-usecallback-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-844620cd41a1&quot;&gt;[번역] useMemo 그리고 useCallback 이해하기&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;상단-컴포넌트일수록-효과적이다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%83%81%EB%8B%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%BC%EC%88%98%EB%A1%9D-%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B4%EB%8B%A4&quot; aria-label=&quot;상단 컴포넌트일수록 효과적이다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;상단 컴포넌트일수록 효과적이다&lt;/h3&gt;
&lt;p&gt;자식 컴포넌트의 리랜더링에 대한 큰 책임은 부모 컴포넌트가 가집니다. 때문에, 책임이 큰 상단 컴포넌트일수록
최적화에 예민하게 접근해야 합니다.&lt;/p&gt;
&lt;p&gt;개인적으로 여러 컴포넌트에 상태 의존성 주입이 필요한 경우 Context API를 사용하곤 하는데, 일반적으로
컨텍스트가 가진 상태에 의존적인 많은 하위 트리를 지닙니다. 즉, 컨텍스트의 상태 변화는 많은 리랜더링을
발생시킨다는 것을 명심하고 useMemo, useCallback을 적극적으로 사용해야 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;...
const contextState = useMemo(
  () =&amp;gt; ({
    isGood,
    setIsGood,
  }),
  [isGood]
);

return &amp;lt;CountContext.Provider value={contextState} /&amp;gt;;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;a href=&quot;https://yceffort.kr/2022/04/best-practice-useCallback-useMemo#usememo%EC%99%80-usecallback%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0&quot;&gt;리액트의 useCallback useMemo, 정확하게 사용하고 있을까&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;lint와-꼭-함께-사용하자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#lint%EC%99%80-%EA%BC%AD-%ED%95%A8%EA%BB%98-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90&quot; aria-label=&quot;lint와 꼭 함께 사용하자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;lint와 꼭 함께 사용하자&lt;/h3&gt;
&lt;p&gt;리엑트 메모이제이션 API를 사용할 때, deps에 의존성을 가진 참조값을 추가하지 않는 경우도 종종 발생합니다.
이러한 점검을 린팅 도구에게 맡겨 휴먼 에러를 최소화할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.reactjs.org/docs/hooks-reference.html#usecallback&quot;&gt;hooks-reference#useCallback&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.npmjs.com/package/eslint-plugin-react-hooks&quot;&gt;eslint-plugin-react-hooks&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h2&gt;
&lt;p&gt;리엑트 메모이제이션을 위한 API들이 어떻게 구현되어 있는 지, 그리고 적절한 사용 기준을 정리해보았는데요.
아무렴 궁극적인 목표는 습관성(?) 최적화입니다. 기능 개발을 하면서 당연하게 사용되는 메모이제이션 API,
그리고 소수점 초단위의 성능 향상을 고려할 줄 아는 개발을 꿈꿉니다.&lt;/p&gt;
&lt;p&gt;잘못된 부분이 있다면, 이슈를 통해 자유로운 지적 부탁드리며, 긴 글 읽어주셔서 감사합니다!&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.reactjs.org/docs/hooks-reference.html#usecallback&quot;&gt;https://ko.reactjs.org/docs/hooks-reference.html#usecallback&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.reactjs.org/docs/hooks-reference.html#usememo&quot;&gt;https://ko.reactjs.org/docs/hooks-reference.html#usememo&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://ko.reactjs.org/docs/react-api.html#reactmemo&quot;&gt;https://ko.reactjs.org/docs/react-api.html#reactmemo&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[react-testing]]></title><description><![CDATA[현재 파이브스팟 모바일 웹을 가꾸어 나가고 있습니다. 빠르게 출시하기 위해
동작하는 프러덕션을 배포하고, 피드백을 취합해서 다음 페이스를 위한 기능적인 살과
뼈대를 붙여나가고 있는 작업이 한창입니다. Deliver usable products to…]]></description><link>https://youthfulhps.dev/react/react-testing/</link><guid isPermaLink="false">https://youthfulhps.dev/react/react-testing/</guid><pubDate>Mon, 25 Jul 2022 11:07:43 GMT</pubDate><content:encoded>&lt;p&gt;현재 파이브스팟 모바일 웹을 가꾸어 나가고 있습니다. 빠르게 출시하기 위해
동작하는 프러덕션을 배포하고, 피드백을 취합해서 다음 페이스를 위한 기능적인 살과
뼈대를 붙여나가고 있는 작업이 한창입니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://deming.org/wp-content/uploads/2020/06/minimal-viable-product-henrik-kniberg.png&quot; alt=&quot;Deliver usable products to allow learning to take place&quot;&gt;
&lt;em&gt;&lt;a href=&quot;https://deming.org/minimal-viable-product&quot;&gt;이미지 출처&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;프러덕션을 가꾸어 나가면서 문뜩 테스트 코드의 필요성을 느끼기 시작했는데요.
단순히 ‘테스트 코드에 대한 경험이 부족해서..좀 짜봐야 하지 않을 까?’ 라는 동기로
구색 갖추기에 급급한 기준 없는 테스트를 하고자 했다면, 오히려 테스트
코드 작성이 작업 진행에 방해가 될 거라는 건 당연했습니다.&lt;/p&gt;
&lt;p&gt;그렇기 때문에, 스스로 납득할 수 있고 팀원분들의 공감을 얻을 수 있는 적합한 이유가
등장할 때까지 고민하고 기다렸었는데요. 최근 테스트 코드에 대한 갈증을 느끼면서
그 이유가 허접하지 않기를 바라며 적합한 이유인지 직시하고자 정리해두려 합니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;테스트 코드는 필요하다라는 것을 입증하는 좋은 레퍼런스들은 정말 많습니다.
다만, 저가 처해있는 환경에서 테스트 코드는 왜 필요하고, 어떤 역할을 할 수
있을 지에 대한 고민을 담았습니다.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;왜-테스트-코드가-필요하다고-느꼈을-까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%99%9C-%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%98%EB%8B%A4%EA%B3%A0-%EB%8A%90%EA%BC%88%EC%9D%84-%EA%B9%8C&quot; aria-label=&quot;왜 테스트 코드가 필요하다고 느꼈을 까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;왜 테스트 코드가 필요하다고 느꼈을 까&lt;/h2&gt;
&lt;p&gt;최근 리팩토링, 그리고 V2 API로 마이그레이션하면서 동시에,
새로운 기능을 개발하는 상당히 빠른 변화를 만들어나가고 있습니다.
그 과정에서 가장 큰 걱정거리는 레거시 기능의 히스토리를 찾고, 기능을 유지한채로
내부 코드 품질을 높이는 데 집중해야 한다는 점이었습니다.&lt;/p&gt;
&lt;p&gt;사실, 몇몇 히스토리가 분산되어 있어 구두로 공유되거나 코드와 주석을 찾아봐야
알 수 있는 히스토리도 분명 있었기 때문에, 다음 페이스를 위해서라도 기획 관련
히스토리가 그럴싸한 명목하에 작성이 강요되는 구실이 필요했습니다.
그렇지 않으면, 작성과 동시에 레거시가 되는 새로 작성된 코드도 분명
히스토리가 남지 않아 동일한 이슈로 골치 아플겁니다.&lt;/p&gt;
&lt;h3 id=&quot;테스트-코드에-기획-히스토리를-남기자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%85%8C%EC%8A%A4%ED%8A%B8-%EC%BD%94%EB%93%9C%EC%97%90-%EA%B8%B0%ED%9A%8D-%ED%9E%88%EC%8A%A4%ED%86%A0%EB%A6%AC%EB%A5%BC-%EB%82%A8%EA%B8%B0%EC%9E%90&quot; aria-label=&quot;테스트 코드에 기획 히스토리를 남기자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;테스트 코드에 기획 히스토리를 남기자&lt;/h3&gt;
&lt;p&gt;사실 피그마와 같은 기획 도구들에 얼마든지 쌓아나가면 됩니다. 다만
병렬적으로 코드 레벨에서도 기획 히스토리를 테스트 코드를 통해
기록을 남겨 부수효과를 얻을 수 있겠다 싶었습니다.&lt;/p&gt;
&lt;p&gt;가령 깃헙 프로필 UI 기획 명세서가 다음과 같이 작성되어 있다면,
주요 기획내용을 그대로 테스트 describe에 담아낼 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;text&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;프로필 섹션은 유저 정보를 확인할 수 있다.
1. 유저의 이름과 아이디를 확인할 수 있다.
2. 유저의 팔로워와 팔로잉 수를 확인할 수 있다.
3. 유저의 소속 회사, 지역, 이메일, 대표 링크를 확인할 수 있다.
...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;describe(&amp;quot;프로필 섹션에서 유저 정보를 확인할 수 있다.&amp;quot;, () =&amp;gt; {
  it(&amp;quot;유저의 이름과 아이디를 확인할 수 있다.&amp;quot;, () =&amp;gt; { ... });

  it(&amp;quot;유저의 팔로워와 팔로잉 수를 확인할 수 있다.&amp;quot;, () =&amp;gt; { ... });

  it(&amp;quot;유저의 소속 회사, 지역, 이메일, 대표 링크를 확인할 수 있다.&amp;quot;, () =&amp;gt; { ... });
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;만약, 기획이 변경된다면 테스트 코드의 설명 또한 변경이 되겠고,
결국 기획 히스토리 또한 수정 사항에 남게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;describe(&amp;quot;프로필 섹션에서 유저 정보를 확인할 수 있다.&amp;quot;, () =&amp;gt; {
  it(&amp;quot;유저의 이름과 아이디를 확인할 수 있다.&amp;quot;, () =&amp;gt; { ... });

  //it(&amp;quot;유저의 팔로워와 팔로잉 수를 확인할 수 있다.&amp;quot;, () =&amp;gt; { ... });
  it(&amp;quot;유저의 팔로워와 팔로잉 수는 일정 수가 넘으면 &amp;#39;여러 명&amp;#39;으로 표기된다.&amp;quot;, () =&amp;gt; { ... })

  it(&amp;quot;유저의 소속 회사, 지역, 이메일, 대표 링크를 확인할 수 있다.&amp;quot;, () =&amp;gt; { ... });
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;물론, 관점에 따라 test 보다는 spec에 가까운 테스트 코드이지만,
어떤 테스트를 해야할 지 감을 못잡겠다면, 명확한 기획 목적을 테스트 주제로
삼는 것도 좋은 방법입니다.&lt;/p&gt;
&lt;h3 id=&quot;작업자에게-책임을-부여하고-리뷰어의-짐을-덜자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9E%91%EC%97%85%EC%9E%90%EC%97%90%EA%B2%8C-%EC%B1%85%EC%9E%84%EC%9D%84-%EB%B6%80%EC%97%AC%ED%95%98%EA%B3%A0-%EB%A6%AC%EB%B7%B0%EC%96%B4%EC%9D%98-%EC%A7%90%EC%9D%84-%EB%8D%9C%EC%9E%90&quot; aria-label=&quot;작업자에게 책임을 부여하고 리뷰어의 짐을 덜자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;작업자에게 책임을 부여하고 리뷰어의 짐을 덜자&lt;/h3&gt;
&lt;p&gt;코드 리뷰는 특정 기능 개발을 하는 데 있어 코드 품질을 관리하고,
작업자가 생각하지 못한 설계의 개선점을 언급해주는 용도로서 사용되어야
한다고 생각하는데, 코드 리뷰의 역할이 그 이상 넘어가게 되면 슬슬
리뷰어에게 부담으로 다가오게 됩니다.&lt;/p&gt;
&lt;p&gt;가령 특정 기능이 동작하는 지에 대한 QA와 예외적인 상황에 대해 고민하는
시간이 늘어나게 되면 코드 리뷰의 병목을 야기하게 되는데,
이러한 책임을 리뷰어가 담당하게 되면, 리뷰를 받는 작업자는 어쩌면
이후 발생할 수 있는 이슈에 대해 책임을 분할했다는 괘씸한 생각을 할 수도
있습니다.&lt;/p&gt;
&lt;p&gt;작업자는 작업에 대한 책임을 온전히 짊어져야 하고, 테스트 코드로서
얼마만큼의 책임을 지고 있는 지에 대해 표현해야 합니다.
여기서 부족한 테스트 케이스에 대해 짚어주는 것 정도가 리뷰어의 역할입니다.&lt;/p&gt;
&lt;h3 id=&quot;안정적인-리팩토링의-잣대&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%95%88%EC%A0%95%EC%A0%81%EC%9D%B8-%EB%A6%AC%ED%8C%A9%ED%86%A0%EB%A7%81%EC%9D%98-%EC%9E%A3%EB%8C%80&quot; aria-label=&quot;안정적인 리팩토링의 잣대 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;안정적인 리팩토링의 잣대&lt;/h3&gt;
&lt;p&gt;리팩토링하거나, API를 갈아 끼워야 할 때 레거시와 동일한 기능을 유지하기 위해
심혈을 기울입니다. 레거시와 같은 화면을 보여주는 지, 값의 전처리는
잘 이루어지는 지 등에 대한 QA에 많은 시간을 보내곤 하는데요.
그러다보면 레거시가 미워질 때 있고, 히스토리가 명확하지 않아 얄궂게 느껴지기도 합니다.&lt;/p&gt;
&lt;p&gt;테스트 코드는 이러한 상황에서 빛을 바랍니다. 여기서 리팩토링을 통해 코드의 퀄리티가
개선되었다는 관점과는 별개로, 테스트 코드는 테스트 타겟의 반환값이 명시한 값과
일치하는 지만을 판단합니다. 때문에 테스트에 성공한다면 타겟 영역의 동작들은
레거시와 동일하다고 판단할 수 있는 지표가 되어 줍니다.&lt;/p&gt;
&lt;h3 id=&quot;코드-분리의-잣대&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%BD%94%EB%93%9C-%EB%B6%84%EB%A6%AC%EC%9D%98-%EC%9E%A3%EB%8C%80&quot; aria-label=&quot;코드 분리의 잣대 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;코드 분리의 잣대&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;테스트 함수마다 한 개념만 테스트하라&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;함수는 하나의 일만 담당하고 그 일을 잘하도록 구현해야 한다는 클린 코드의 규칙은
익히 들어왔습니다. 하지만 실상 함수를 작성하다보면, 하나의 일만 담으려 하지만
사이드 이펙트를 온전하게 제거하기란 쉽지 않은데요.&lt;/p&gt;
&lt;p&gt;이럴 때 테스트 코드의 describe로 함수의 역할을 구분짓고 함수를 구현하는
TDD 방식으로 작성하면 기준을 명확히 세우는 데 큰 도움이 됩니다.
반대로 함수를 작성하고 테스트 코드를 작성하면 어떻게 테스트해야 할 지 막막해집니다.&lt;/p&gt;
&lt;h2 id=&quot;무슨-테스트를-해야-할-까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%AC%B4%EC%8A%A8-%ED%85%8C%EC%8A%A4%ED%8A%B8%EB%A5%BC-%ED%95%B4%EC%95%BC-%ED%95%A0-%EA%B9%8C&quot; aria-label=&quot;무슨 테스트를 해야 할 까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;무슨 테스트를 해야 할 까?&lt;/h2&gt;</content:encoded></item><item><title><![CDATA[타입스크립트, 글로 배웠습니다만]]></title><description><![CDATA[개인적으로 타입스크립트는 실무에서 사용하면서 익히기 시작해서
약…]]></description><link>https://youthfulhps.dev/typescript/typescript-essentials-you-should-know/</link><guid isPermaLink="false">https://youthfulhps.dev/typescript/typescript-essentials-you-should-know/</guid><pubDate>Tue, 14 Jun 2022 10:06:39 GMT</pubDate><content:encoded>&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 864px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 58.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACg0lEQVQoz1WTTVMTQRCG91958Q9w5EKVFywEKaCIYIDEhGQzu7NJzJckAfJFUuhBJVpWBaNWsEA0sDEJSSASyo/cPOnNf/DaM7ugHLq6d3bm6bd7ehQWUcGiAWgxsjiTxsn8tFaOe3GWUdGRFpC+velHe8OH1voqmmkPGkk3zDUXanweFf80FJ7QYUjjCJIPSk8W09DM6xhuB3GW13Ca0/CloOOcTPhTWuuKRJSgnnDhfWgBtaADSihuEMAyEYfiXMbhuI6idw47AQfadPB8S4eZXsXhmhefkquk0k+JdJlIxPVHbuxHlgSQ/1NFsfjmBE5GGWZGR+AcH0O3FCZlDJW4ipGbNzA1NormdgL9nCqV9kmxmaJkCTeUS8g1dQQ7IBWnOYaTDENrU8VZgZRQfBBz4SDhRadgoJ9ncl3sO075cERnLIWXUILpUR3VNR++lXQMihwtWZqGixKXhyVA9jRgfeettSbtE1DFKpfUkddJZTam4oI2mOs+lLVFWYqZ9uFdZEUe7tvQK5gNbG2opN59CeQIE5QJdWmGffrBZifgmb6NkGMS2twEVqbGkXHNokmJrkC2iR62qS2iGnnLIVulKH0/5cfG/bt46negFl7Cc/UeKV3AlnsG7ju38Mpw4rxoUNnsmsJezuqndSk2MEKX8VncXqOO34MOfvWO0cgaGO5u48/XDsxaFc291/j+YhO9DPWWlP1fuhghxZpBAQyCE7BeeIhedQc/9l5i8LaMQTmHYfUJfh5W8ObZY+wVkxiUQtalXIEYulmaCCpbMeweclKapecnBvdjdBlHNP0fIk6YSQ/K6jwyzkks00zu8kUMaMi7NkQ8yRN6LeIpNlIP8BcOx5XK+8sb/AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;A man who thinks about whether to use any type&quot;
        title=&quot;A man who thinks about whether to use any type&quot;
        src=&quot;/static/cae53aa5a9bba8e6c1df878cf26b4f5d/9cab2/thumbnail.png&quot;
        srcset=&quot;/static/cae53aa5a9bba8e6c1df878cf26b4f5d/5a46d/thumbnail.png 300w,
/static/cae53aa5a9bba8e6c1df878cf26b4f5d/0a47e/thumbnail.png 600w,
/static/cae53aa5a9bba8e6c1df878cf26b4f5d/9cab2/thumbnail.png 864w&quot;
        sizes=&quot;(max-width: 864px) 100vw, 864px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;개인적으로 타입스크립트는 실무에서 사용하면서 익히기 시작해서
약 2년 가까이 매일 사용하는 언어가 되었습니다.
타입스크립트로 시작한 프로젝트도 있었던 반면, 자바스크립트에서
타입스크립트로 마이그레이션해야 하는 프로젝트들도 있었는데요.&lt;/p&gt;
&lt;p&gt;타입스크립트는 단순히 ‘자바스크립트에 타입을 부여한 언어’ 라고 생각할 수 있지만,
최근 몇 개월동안 어설프게 시작한 타입스크립트를 다시 공부하면서
‘자바스크립트에 타입을 명시한다고 해서 타입스크립트를
사용할 줄 안다’ 라고 치환될 수 없음을 느꼈고,
주로 &lt;a href=&quot;https://effectivetypescript.com/&quot;&gt;이펙티브 타입스크립트&lt;/a&gt;
를 &lt;a href=&quot;https://github.com/youthfulhps/TIL/tree/main/typescript&quot;&gt;TIL/typescript&lt;/a&gt;
에 정리하고, &lt;a href=&quot;https://github.com/youthfulhps/type-challenges&quot;&gt;타입 챌린지&lt;/a&gt;
도 도전해보며 타입스크립트, 그리고 자바스크립트와의 관계를
깊게 이해하기 위해 노력하고 있습니다.&lt;/p&gt;
&lt;p&gt;이 글의 목적은 이펙티브 타입스크립트와 그 외 타입스크립트에
대한 좋은 글들을 모아 &lt;strong&gt;실무에서 적용할 수 있는 마인드 셋을
갖추기 위함&lt;/strong&gt;이며, 지속적으로 업데이트할 예정입니다.&lt;/p&gt;
&lt;h2 id=&quot;1-타입스크립트는-자바스크립트의-상위-집합이다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#1-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EC%83%81%EC%9C%84-%EC%A7%91%ED%95%A9%EC%9D%B4%EB%8B%A4&quot; aria-label=&quot;1 타입스크립트는 자바스크립트의 상위 집합이다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;1. 타입스크립트는 자바스크립트의 상위 집합이다&lt;/h2&gt;
&lt;p&gt;타입스크립트와 자바스크립트의 관계를 설명할 때 자주 등장하는
이야기입니다. 집합 개념으로 표현한 것은 이 둘의 관계를
직관적으로 이해하는 데 큰 도움이 됩니다.&lt;/p&gt;
&lt;p&gt;간단하게 증명해보자면, 타입을 명시하는 문법을 가진
타입스크립트는 타입을 명시하는 문법을 가지고 있기 때문에
자바스크립트 런타임에서는 오류로 출력하지만, 반대로
js 파일을 ts 파일로 변경해도 문제가 없습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function sayHello(who: string) {
  console.log(&amp;#39;Hello&amp;#39;, who);
}

//SyntaxError: Unexpected token : ,in node&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;타입스크립트의 영역이 자바스크립트의 상위 집합인 특성은
자바스크립트 코드를 타입스크립트로 점진적으로 마이그레이션하는 데
큰 도움이 됩니다.&lt;/p&gt;
&lt;h2 id=&quot;2-코드-생성과-타입-체크는-독립적이다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#2-%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%83%80%EC%9E%85-%EC%B2%B4%ED%81%AC%EB%8A%94-%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9D%B4%EB%8B%A4&quot; aria-label=&quot;2 코드 생성과 타입 체크는 독립적이다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;2. 코드 생성과 타입 체크는 독립적이다&lt;/h2&gt;
&lt;p&gt;타입스크립트 컴파일러는 최신 자바스크립트 / 타입스크립트를
브라우저에서 동작할 수 있도록 구 버전의 자바스크립트로
트랜스파일하고, 코드의 타입 오류를 체크하는 두 가지 역할을 합니다.&lt;/p&gt;
&lt;p&gt;여기서, &lt;strong&gt;타입스크립트 컴파일러의 두 가지 역할은 서로 완벽히 독립적입니다.&lt;/strong&gt;
타입스크립트가 자바스크립트로 변환될 때 타입에는 영향을 주지 않으며,
반대로 타입은 자바스크립트 런타임에 영향을 미치지 않습니다.&lt;/p&gt;
&lt;p&gt;아래의 코드는 타입 체커에게 다음과 같은 지적을 받지만,
자바스크립트 코드로서 문법적 오류가 없다면, 문제없이 컴파일됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// main.ts
let greetings = &amp;#39;hello&amp;#39;;
greetings = 1234;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ tsc main.ts
main.ts:2:1 -error ... &amp;#39;1234&amp;#39; 형식은 &amp;#39;string&amp;#39; 형식에 할당할 수 없습니다.&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;타입 체크에는 문제가 있지만, 컴파일이 수행되는 타입스크립트의
독립적 기능 수행은 타입 체크의 오류 여부와 상관없이 컴파일된
결과를 만들어낼 수 있다는 점에서 어플리케이션 운영 단계에서
도움이 됩니다.&lt;/p&gt;
&lt;h2 id=&quot;3-런타임에서-타입-구문은-제거-가능-하다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#3-%EB%9F%B0%ED%83%80%EC%9E%84%EC%97%90%EC%84%9C-%ED%83%80%EC%9E%85-%EA%B5%AC%EB%AC%B8%EC%9D%80-%EC%A0%9C%EA%B1%B0-%EA%B0%80%EB%8A%A5-%ED%95%98%EB%8B%A4&quot; aria-label=&quot;3 런타임에서 타입 구문은 제거 가능 하다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;3. 런타임에서 타입 구문은 ‘제거 가능’ 하다&lt;/h2&gt;
&lt;p&gt;타입 구문은 자바스크립트로 컴파일되는 과정에서 모두 제거됩니다.
즉, &lt;strong&gt;런타임에는 타입 체크가 불가능하며 타입은 런타임에 아무런
영향을 끼치지 않습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;아래의 코드에서 &lt;code class=&quot;language-text&quot;&gt;instanceof&lt;/code&gt; 체크는 런타임에 일어나지만,
&lt;code class=&quot;language-text&quot;&gt;Rectangle&lt;/code&gt;은 타입이기 때문에 런타임 시점에 아무런 역할을
할 수 없습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Square {
  width: number;
}

interface Rectangle extends Square {
  height: number;
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    return shape.width * shape * height;
  } else {
    return shape.width * shape.width;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;런타임에 타입 정보를 유지하고자 한다면 속성의 존재 여부를
알아보거나, 런타임에 접근 가능한 접근 정보를 명시하는
‘태그’ 기법을 활용하여야 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function calculateArea(...) {
  if (&amp;#39;height&amp;#39; in shape) { ... }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Square {
  kind: &amp;quot;square&amp;quot;;  //tag
  width: number;
}

interface Rectangle extends Square {
  kind: &amp;quot;rectangle&amp;quot;;  //tag
  height: number;
}

type Shape = Square | Rectangle;

function calculateArea(...) {
  if (shape.kind === &amp;#39;rectangle&amp;#39;) { ... }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만 특이하게도, 타입스크립트 클래스는 자바스크립트 런타임에서
실제로 동작하는 함수이지만, 타입으로도 사용할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;class Square {
  constructor(public width: number) {}
}

class Rectangle extends Square {
  constructor(public width: number, public height: number) {
    super(width);
  }
}

type Shape = Square | Rectangle;

function calculateArea(shape: Shape) {
  if (shape instanceof Rectangle) {
    return shape.width * shape * height;
  } else {
    return shape.width * shape.width;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;4-덕-타이핑-기반-자바스크립트를-모델링한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#4-%EB%8D%95-%ED%83%80%EC%9D%B4%ED%95%91-%EA%B8%B0%EB%B0%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EB%AA%A8%EB%8D%B8%EB%A7%81%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;4 덕 타이핑 기반 자바스크립트를 모델링한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;4. 덕 타이핑 기반 자바스크립트를 모델링한다&lt;/h2&gt;
&lt;p&gt;타입스크립트는 &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%8D%95_%ED%83%80%EC%9D%B4%ED%95%91&quot;&gt;덕 타이핑&lt;/a&gt; 기반 자바스크립트를
모델링하기 위해 구조적 타이핑을 사용합니다. 여기서
덕 타이핑은 동적 타이핑의 한 종류로, 객체의 변수 및 메서드의 집합이
객체의 타입을 결정하는 것을 말합니다.&lt;/p&gt;
&lt;p&gt;Rectangle과 NamedRectangle 인터페이스는 서로 무관하지만,
calculateArea의 매개변수로 NamedRectangle 타입의 객체를
사용해도 정상적으로 동작하는 것이 타입스크립트가 구조적 타이핑을
모델링하고 있음을 보여줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Square {
  width: number;
}

interface Rectangle extends Square {
  height: number;
}

interface NamedRectangle {
  name: string;
  width: number;
  height: number;
}

function calculateArea(rectangle: Rectangle) {
  return rectangle.width * rectangle.height;
}

const rectangle: NamedRectangle = {
  name: &amp;#39;namedRectangle&amp;#39;,
  width: 3,
  height: 4,
};

calculateArea(rectangle); //OK&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이러한 관점에서 함수를 작성할 때 호출에 사용되는 매개변수의 속성들이
선언된 타입에 국한되어 있지 않고 ‘열려 (open)’ 있음을 인지해야
합니다.&lt;/p&gt;
&lt;h2 id=&quot;5-type-interface의-차이를-이해하고-일관성을-유지해야-한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#5-type-interface%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B3%A0-%EC%9D%BC%EA%B4%80%EC%84%B1%EC%9D%84-%EC%9C%A0%EC%A7%80%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;5 type interface의 차이를 이해하고 일관성을 유지해야 한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;5. type, interface의 차이를 이해하고 일관성을 유지해야 한다&lt;/h2&gt;
&lt;p&gt;타입스크립트는 type, interface를 통해 명명된 타입을
정의할 수 있습니다. 일반적으로 두 방법 모두 사용가능하지만,
그 차이점을 이해하고 사용의 일관성을 유지하도록 노력해야 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type TState = {
  name: string;
  age: number;
};

type IState = {
  name: string;
  age: number;
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;type과 interface 모두 추가적인 속성을 할당하면 동일한
오류가 발생합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const foo: TState = {
  name: &amp;#39;foo&amp;#39;,
  age: 29,
  organization: &amp;#39;fastfive&amp;#39;,
  // ~~~~ Type ... is not assignable to type &amp;#39;TState&amp;#39;
  //      Object literal may only specify known properties, and
  //     &amp;#39;organization&amp;#39; does not exist in type &amp;#39;TState&amp;#39;
};

type TDict = { [key: string]: string };
interface IDict {
  [key: string]: string;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;두 방법 모두 인덱스 시그니처, 함수 타입, 제너릭이 가능합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;//index signature
type TDict = { [key: string]: string };
interface IDict {
  [key: string]: string;
}

//function type
type TFn = (x: number) =&amp;gt; string;
interface IFn {
  (x: number): string;
}

//generic
type TPair&amp;lt;T&amp;gt; = {
  first: T;
  second: T;
};
interface IPair&amp;lt;T&amp;gt; {
  first: T;
  second: T;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;두 방법 모두 클래스를 구현할 때 사용할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;class StateT implements TState {
  name: string = &amp;#39;&amp;#39;;
  capital: string = &amp;#39;&amp;#39;;
}
class StateI implements IState {
  name: string = &amp;#39;&amp;#39;;
  capital: string = &amp;#39;&amp;#39;;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;일반적으로 타입과 인터페이스는 서로 확장할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface IStateWithPop extends TState {
  population: number;
}
type TStateWithPop = IState &amp;amp; { population: number };&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;대표적인 공통점이 있는 반면 차이점도 존재하는데,
유니온 타입은 있지만 유니온 인터페이스라는 개념은 없습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type AorB = &amp;#39;a&amp;#39; | &amp;#39;b&amp;#39;;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;‘일반적으로’ 타입과 인터페이스는 서로 확장 가능하다는 것은
인터페이스가 유니온 타입을 확장할 수 없음을 담고 있습니다.
또한, 인터페이스는 복잡한 타입 (유니온 타입, 원시값,
템플릿 리터럴, 튜플 등) 을 확장하지 못해
흔히 type은 interface 보다 쓰임새가 많습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type AorB = &amp;#39;A&amp;#39; | &amp;#39;B&amp;#39;;
type Input = {
  /* ... */
};
type Output = {
  /* ... */
};

interface VariableMap {
  [name: string]: Input | Output;
}

type NamedVariable = (Input | Output) &amp;amp; { name: string };&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;type은 튜플과 배열 타입도 간결하게 표현할 수 있습니다.
물론 interface로도 표현이 가능하지만, 튜플에서
사용할 수 있는 concat과 같은 메서드를 사용할 수 없기 때문에
튜플은 type을 통해 구현하는 것이 낫습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type Pair = [number, number];
type StringList = string[];
type NamedNums = [string, ...number[]];&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface ITuple {
  0: string;
  1: number;
}

const foo: ITuple = [&amp;#39;0&amp;#39;, 1];

foo.concat();
// Property &amp;#39;concat&amp;#39; does not exist on type &amp;#39;ITuple&amp;#39;.(2339)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;반면 인터페이스는 속성을 확장하는 ‘선언 병합’
을 통해 보강이 가능합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface IState {
  name: string;
  age: number;
}
interface IState {
  organization: string;
}
const foo: IState = {
  name: &amp;#39;foo&amp;#39;,
  age: 29,
  organization: &amp;#39;fastfive&amp;#39;,
}; // OK&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;선언 병합은 주로 타입 선언 파일에서 사용됩니다.
예를 들어, &lt;em&gt;lib.es5.d.ts&lt;/em&gt; 에 선언되어 있는 Array 인터페이스가
&lt;em&gt;lib.es2015.d.ts&lt;/em&gt; 에 선언된 인터페이스를 병합하여
보강될 수 있도록 하기 위함입니다. 결과적으로
각 선언이 병합되어 전체 메서드를 가지는 하나의
Array 타입을 얻게 됩니다.&lt;/p&gt;
&lt;p&gt;결론적으로, 복잡한 타입이라면 타입 별칭을 사용합니다. 그러나
두 가지 방법으로 모두 표현할 수 있다면 일관성과 보강의 관점에서
고려해봐야 합니다. 또한 합류하게 된 프로젝트의 코드 베이스의
일관성을 지키기 위해 선택되어도 좋습니다.&lt;/p&gt;
&lt;h2 id=&quot;6-any-타입은-타입-시스템을-무력화-시킨다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#6-any-%ED%83%80%EC%9E%85%EC%9D%80-%ED%83%80%EC%9E%85-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EB%AC%B4%EB%A0%A5%ED%99%94-%EC%8B%9C%ED%82%A8%EB%8B%A4&quot; aria-label=&quot;6 any 타입은 타입 시스템을 무력화 시킨다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;6. any 타입은 타입 시스템을 무력화 시킨다&lt;/h2&gt;
&lt;p&gt;any 타입은 점진적이며 선택적인 타입스크립트의 특성을 위한
핵심 타입이지만, 타입 안정성이 없으며 설계를 감추고
언어 서비스 또한 제공받지 못하게 만드는 강력한 힘을 가지고 있고,
자바스크립트에서 표현할 수 있는 모든 값을 아우르는 매우
큰 범위의 타입입니다.&lt;/p&gt;
&lt;p&gt;반대로 말하면, &lt;strong&gt;any는 더 구체적인 타입으로 대체할 수 있는
가능성 또한 높습니다.&lt;/strong&gt; 가령, 함수의 매개변수가 객체이긴 하지만
값을 알 수 없다면 인덱스 시그니처를 사용하거나, 열거가
가능한 객체임을 표현할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;yaml&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;any -&amp;gt; {[key: string]: any};
any -&amp;gt; any[];&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;부득이하게 any를 사용해야 한다면, any 타입의 영향력이
퍼져나가지 않도록 주의해야 합니다. 아래의 코드처럼
&lt;code class=&quot;language-text&quot;&gt;expressionReturningFoo&lt;/code&gt;의 반환값을 &lt;code class=&quot;language-text&quot;&gt;processBar&lt;/code&gt; 의 매개변수로
전달하기 위해 any를 사용한다면, any로 명시하는 것 보다는
차라리 f2 처럼 사용처에서 단언하여 사용하는 것이 낫습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Foo {
  foo: string;
}
interface Bar {
  bar: string;
}
declare function expressionReturningFoo(): Foo;

function processBar(b: Bar) {
  /* ... */
}

//// Don&amp;#39;t do this
function f1() {
  const x: any = expressionReturningFoo();
  processBar(x);
}

// Prefer this
function f2() {
  const x = expressionReturningFoo();
  processBar(x as any);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;f1에서 x 타입은 &lt;code class=&quot;language-text&quot;&gt;processBar&lt;/code&gt; 호출 이후에도 여전히 any 타입인
반면, f2는 사용처 영역에서만 any 타입으로 단언되어 호출 이후
x 타입은 &lt;code class=&quot;language-text&quot;&gt;Foo&lt;/code&gt; 가 됩니다.&lt;/p&gt;
&lt;p&gt;만약 f1이 x를 반환하는 구조의 함수라면, any 타입의 영향력은
함수 내부 뿐만 아니라 외부까지 퍼져나가게 되기 때문에
any 타입의 적용 범위를 좁게 제한해야 합니다.&lt;/p&gt;
&lt;h2 id=&quot;7-타입스크립트-기본형-타입과-객체-래퍼-타입은-다르다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#7-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B8%B0%EB%B3%B8%ED%98%95-%ED%83%80%EC%9E%85%EA%B3%BC-%EA%B0%9D%EC%B2%B4-%EB%9E%98%ED%8D%BC-%ED%83%80%EC%9E%85%EC%9D%80-%EB%8B%A4%EB%A5%B4%EB%8B%A4&quot; aria-label=&quot;7 타입스크립트 기본형 타입과 객체 래퍼 타입은 다르다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;7. 타입스크립트 기본형 타입과 객체 래퍼 타입은 다르다&lt;/h2&gt;
&lt;p&gt;자바스크립트는 여섯 가지의 원시 타입(number, string, boolean, undefined, null, Symbol)이 있습니다. 기본형들은
불변이고 메서드를 가지고 있지 않다는 점에서 객체와 구분됩니다.&lt;/p&gt;
&lt;p&gt;하지만 기본형인 string은 메서드가 호출이 되어 마치 메서드를
가지고 있는 것 처럼 보이지만, string의 메서드가 아닙니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;#39;string&amp;#39;.charAt(3); //&amp;quot;i&amp;quot;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환하여
기본형에서 charAt에 접근할 때, 자바스크립트는 &lt;strong&gt;기본형을
String 객체로 래핑하고 메서드를 호출하고 래핑한 객체를
버립니다.&lt;/strong&gt; 이러한 동작으로 아래의 코드처럼 혼란을 가져오기도 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const foo = &amp;#39;foo&amp;#39;;
foo.bar = &amp;#39;hi&amp;#39;;
console.log(foo.bar); //undefined&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;타입스크립트는 이러한 자바스크립트 동작을 위해
기본형 타입과 객체 래퍼 타입을 구분지어 모델링합니다.
즉, 기본형 타입과 객체 래퍼 타입은 다릅니다.&lt;/p&gt;
&lt;p&gt;하지만 string을 String으로 잘못 타이핑하기 쉽고, 실수를
하더라도 아래의 코드처럼 잘 동작하는 것처럼 보일 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function getStringLength(foo: String) {
  return foo.length;
}

getStringLen(&amp;#39;hello&amp;#39;); // OK
getStringLen(new String(&amp;#39;hello&amp;#39;)); // OK&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그러나, string은 String에 할당할 수 있지만, String은
string에 할당할 수 없습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function isSubString(subString: String) {
  return &amp;#39;hello&amp;#39;.includes(subString);
  //Argument of type &amp;#39;String&amp;#39; is not assignable to parameter of type &amp;#39;string&amp;#39;.
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;타입스크립트가 제공하는 타입 선언은 전부 기본형 타입으로
되어 있기 때문에 기본형 타입과 객체 래퍼 타입을
혼동해서는 안되며, 기본형 타입을 사용해야 합니다.&lt;/p&gt;
&lt;h2 id=&quot;8-잉여-속성-체크와-할당-가능-검사는-별도-과정이다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#8-%EC%9E%89%EC%97%AC-%EC%86%8D%EC%84%B1-%EC%B2%B4%ED%81%AC%EC%99%80-%ED%95%A0%EB%8B%B9-%EA%B0%80%EB%8A%A5-%EA%B2%80%EC%82%AC%EB%8A%94-%EB%B3%84%EB%8F%84-%EA%B3%BC%EC%A0%95%EC%9D%B4%EB%8B%A4&quot; aria-label=&quot;8 잉여 속성 체크와 할당 가능 검사는 별도 과정이다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;8. ‘잉여 속성 체크’와 ‘할당 가능 검사’는 별도 과정이다&lt;/h2&gt;
&lt;p&gt;타입이 명시되어 있는 변수에 객체 리터럴을 할당한다면
타입스크립트는 해당 타입의 속성이 있는 지, 그리고
‘그 외의 속성은 없는지’ 확인하는 과정을 거칩니다.
타입이 명시되어 있는 변수에 명명된 속성의 매개변수 외의
속성을 할당하려 한다면 오류가 발생합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Room {
  numDoors: number;
  ceilingHeightFt: number;
}
const r: Room = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: &amp;#39;present&amp;#39;,
  // ~~~~ Object literal may only specify known properties,
  //      and &amp;#39;elephant&amp;#39; does not exist in type &amp;#39;Room&amp;#39;
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만, 구조적 타이핑 관점으로 생각해보면
r은 구조적으로 Room 타입에 해당하는 속성을 모두
가지고 있기 때문에 오류가 발생하지 않아야 합니다.&lt;/p&gt;
&lt;p&gt;다른 예시로, 임시 변수를 도입하여 Room 타입에 할당한다면
오류가 발생하지 않습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Room {
  numDoors: number;
  ceilingHeightFt: number;
}
const obj = {
  numDoors: 1,
  ceilingHeightFt: 10,
  elephant: &amp;#39;present&amp;#39;,
};
const r: Room = obj; // OK&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;타입스크립트는 &lt;strong&gt;타입 시스템의 구조적 본질을 해치지 않으면서,
알 수 없는 객체 리터럴의 속성을 허용하지 않도록 하여
구조적 타입 시스템에서 발생할 수 있는 중요한 오류를 잡을 수
있도록 조건적으로 ‘잉여 속성 체크’를 진행합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;두 예제에 대입하여 생각해보면, 첫번 째 명명된 타입에 객체의 속성을 할당하는 경우
구조적 시스템 관점에서 오류를 잡기 위해 ‘잉여 속성 체크’ 가 수행되었지만,
두 번째 예시의 경우 조건에 따라 ‘잉여 속성 체크’가 수행되지 않았습니다.&lt;/p&gt;
&lt;p&gt;‘잉여 속성 체크’는 구조적 타이핑 시스템에서 허용되는
속성 이름의 오타 같은 실수를 잡아내고, 선택적 필드를
포함하는 타입에 특히 유용하지만, 적용 범위도 매우 제한적이고
오직 객체 리터럴에서만 수행합니다.&lt;/p&gt;
&lt;p&gt;즉, ‘할당 가능 검사’와 조건적으로 동작하는 ‘잉여 속성 체크’는
별도의 과정이라는 것을 인지하고 있어야 합니다.&lt;/p&gt;
&lt;h2 id=&quot;9-타입-선언도-dry-원칙을-준수해야-한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#9-%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8%EB%8F%84-dry-%EC%9B%90%EC%B9%99%EC%9D%84-%EC%A4%80%EC%88%98%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;9 타입 선언도 dry 원칙을 준수해야 한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;9. 타입 선언도 DRY 원칙을 준수해야 한다&lt;/h2&gt;
&lt;p&gt;코드에서 반복되고 공유된 패턴을 제거하여 DRY(don’t repeat yourself)
원칙을 준수하려고 노력합니다. 반면 타입 중복은 코드에 비해
흔한 일입니다. &lt;strong&gt;타입 간에 매핑하는 방법을 익혀
타입 정의에서도 DRY 원칙을 준수해야 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;간단하게 타입의 이름을 붙이는 것으로 반복을 줄일 수 있습니다.
이는 상수를 정의하고 사용하는 것과 동일합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function getDistance(a: { x: number; y: number }, b: { x: number; y: number }) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}

=&amp;gt;

interface Point2D {
  x: number;
  y: number;
}

function getDistance(a: Point2D, b: Point2D) {
  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;타입 시그니처가 동일하다면, 시그니처 또한 명명된 타입으로 정의하여
공유할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type HTTPFunction = (url: string, opts: Options) =&amp;gt; Promise&amp;lt;Response&amp;gt;;

const get: HTTPFunction = (url, options) =&amp;gt; { ... }
const post: HTTPFunction = (url, options) =&amp;gt; { ... }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이미 존재하는 인터페이스를 확장해서 반복을 제거할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Person {
  firstName: string;
  lastName: string;
}

interface PersonWithBirthDate extends Person {
  birth?: Date;
}

type PersonWithBirthDate = Person &amp;amp; { birth?: Date };&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;제너릭 타입을 사용하여 중복을 제거할 수 있습니다.
타입스크립트는 자주 사용되는 타입 변환을 모델링하여
&lt;a href=&quot;https://www.typescriptlang.org/ko/docs/handbook/utility-types.html&quot;&gt;유틸리티 타입&lt;/a&gt;
을 제공합니다.&lt;/p&gt;
&lt;p&gt;가령 다수의 중복된 속성을 가진 두 타입이 있다면,
State의 속성을 인덱싱하여 topNavState를 정의할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface State {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
  pageContents: string;
}
interface TopNavState {
  userId: string;
  pageTitle: string;
  recentFiles: string[];
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type TopNavState = {
  userId: State[&amp;#39;userId&amp;#39;];
  pageTitle: State[&amp;#39;pageTitle&amp;#39;];
  recentFiles: State[&amp;#39;recentFiles&amp;#39;];
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하거나, 여전히 남아있는 중복은 매핑된 타입으로
중복을 제거할 수 있습니다. 이러한 패턴은 중복 제거에
자주 등장하는 패턴이며 이를 모델링하여 타입스크립트는
유틸리티 제너릭 타입 &lt;a href=&quot;https://www.typescriptlang.org/ko/docs/handbook/utility-types.html#picktype-keys&quot;&gt;Pick&lt;/a&gt;
을 제공합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type TopNavState = {
  [k in &amp;#39;userId&amp;#39; | &amp;#39;pageTitle&amp;#39; | &amp;#39;recentFiles&amp;#39;]: State[k];
};

type TopNavState = Pick&amp;lt;State, &amp;#39;userId&amp;#39; | &amp;#39;pageTitle&amp;#39; | &amp;#39;recentFiles&amp;#39;&amp;gt;;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;추가적으로 문자열 리터럴 타입을 기반으로 하는 템플릿 리터럴 타입은
문자열 리터럴을 통해 새로운 타입을 확장할 수 있는 도구입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type Ade = &amp;#39;ade&amp;#39;;
type LemonAde = `lemon${Ade}`;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;더 복잡하게는 여러 개의 유니온 타입을 확장하여 새로운
문자열 리터럴 타입을 정의할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type DrinkType = &amp;#39;ade&amp;#39; | &amp;#39;juice&amp;#39;;
type Flavor = &amp;#39;lemon&amp;#39; | &amp;#39;graphfruit&amp;#39; | &amp;#39;Strawberry&amp;#39;

type DrinkMenu = `${Flavor}${DrinkType}`;
//type DrinkMenu = &amp;quot;lemonade&amp;quot; | &amp;quot;lemonjuice&amp;quot; | &amp;quot;graphfruitade&amp;quot; | &amp;quot;graphfruitjuice&amp;quot; | &amp;quot;Strawberryade&amp;quot; | &amp;quot;Strawberryjuice&amp;quot;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;반복적인 작업을 줄이기 위해 노력하는 만큼, 타입의 공간에서
또한 반복을 주의해야 합니다.&lt;/p&gt;
&lt;h2 id=&quot;10-객체의-숫자-키를-허용하고-문자열-키와-다르게-인식한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#10-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%88%AB%EC%9E%90-%ED%82%A4%EB%A5%BC-%ED%97%88%EC%9A%A9%ED%95%98%EA%B3%A0-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%82%A4%EC%99%80-%EB%8B%A4%EB%A5%B4%EA%B2%8C-%EC%9D%B8%EC%8B%9D%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;10 객체의 숫자 키를 허용하고 문자열 키와 다르게 인식한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;10. 객체의 숫자 키를 허용하고 문자열 키와 다르게 인식한다&lt;/h2&gt;
&lt;p&gt;자바스크립트의 객체는 키와 값의 모음입니다. 키는 일반적으로 문자열이고
값은 어떤 것이든 될 수 있습니다. 여기서, 일반적으로 문자열이라는
것은 더 복잡한 객체를 키로 사용해도 문제가 되지 않음을 이야기합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const x = {};
x[[1, 2, 3]] = 2;
console.log(x); // {&amp;#39;1,2,3&amp;#39;: 2};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;자바스크립트는 ‘해시 기능’ 객체라는 표현이 없기 때문에 만약, &lt;strong&gt;문자열이
아닌 더 복잡한 객체를 키로 사용하려 한다면, 내부적으로 toString 메서드가
호출되어 객체를 문자열로 반환하여 키로 사용합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;물론 객체의 키를 숫자로 사용한다면, 문자열로 변환되며
숫자로 인덱싱하는 배열 또한 객체로서 배열의 모든 숫자 인덱스들은
문자열로 변환되어 사용됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const x = {
  1: 2,
  3: 4,
};
console.log(x); // {&amp;#39;1&amp;#39;: 2, &amp;#39;3&amp;#39;: 4};

console.log(typeof []); // &amp;#39;object&amp;#39;
const x = [1, 2, 3];
console.log(x[0]); // 1
console.log(x[&amp;#39;1&amp;#39;]); // 2
console.log(Object.keys(x)); // [&amp;#39;0&amp;#39;, &amp;#39;1&amp;#39;, &amp;#39;2&amp;#39;]
console.log(typeof Object.keys(x)[0]); // &amp;#39;string&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;타입스크립트는 &lt;strong&gt;혼란스러운 자바스크립트의 동작을 그대로 모델링하지 않고,
숫자 키를 허용하며 문자열 키와는 다른 것으로 인식합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// lib.es5.d.ts

interface Array&amp;lt;T&amp;gt; {
  ...
  [n: number]: T;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const xs = [1, 2, 3];
const x0 = xs[0]; // OK
const x1 = xs[&amp;#39;1&amp;#39;];
// ~~~~ Element implicitly has an &amp;#39;any&amp;#39; type
//      because index expression is not of type &amp;#39;number&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;숫자 키와 문자열 키를 다른 것으로 보는 타입스크립트의 동작은
타입 체크 단계에서만 유효한 런타임에는 모두 제거되는 가상의 동작입니다.
그럼에도 타입 체크 단계에서 혼란스러운 자바스크립트의 동작을 오류로
잡을 수 있어 충분히 유용합니다.&lt;/p&gt;
&lt;h2 id=&quot;11-인덱스-시그니처는-동적-데이터에만-사용되어야-한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#11-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98%EB%8A%94-%EB%8F%99%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%90%EB%A7%8C-%EC%82%AC%EC%9A%A9%EB%90%98%EC%96%B4%EC%95%BC-%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;11 인덱스 시그니처는 동적 데이터에만 사용되어야 한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;11. 인덱스 시그니처는 동적 데이터에만 사용되어야 한다&lt;/h2&gt;
&lt;p&gt;CSV 파일을 파싱하여 행과 열을 값으로 매칭하는 객체로
나타내고 싶은 경우, 객체의 프로퍼티 스펙을 명확히
알 수 없는 경우에 대해 미리 동적 데이터에 대한 타입을
지정해야 한다면, 키와 값 쌍의 타입 시그니처인
인덱스 시그니처를 사용할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type TestScore = { [property: string]: number };
const testScore: TestScore = {
  math: 90,
  english: 85,
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만, &lt;strong&gt;인덱스 시그니처는 동적 데이터에 대한 타입을 지정할 때만
사용되어야 하며 객체의 가능한 필드가 제한되어 있는 경우라면 인덱스
시그니처로 모델링하지 말아야 합니다.&lt;/strong&gt;
객체 키의 string 타입은 매우 넓은 값을 포함하는 타입이기 때문에
잘못된 키를 포함한 모든 문자열 키를 허용하는 위험이 있으며, 객체의
키값에 대한 자동완성 기능을 제공받지 못하게 됩니다.&lt;/p&gt;
&lt;p&gt;만약 데이터의 키가 한정적이지만 존재 여부를 몰라 인덱스 시그니처를
사용했다면, 선택적 필드를 사용하거나 유니온 타입으로 모델링할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Row1 {
  a: number;
  b?: number;
  c?: number;
  d?: number;
}

type Row2 =
  | { a: number }
  | { a: number; b: number }
  | { a: number; b: number; c: number }
  | { a: number; b: number; c: number; d: number };&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이러한 방법이 번거롭다면, 키 타입에 유연성을 부여하는 &lt;a href=&quot;https://www.typescriptlang.org/ko/docs/handbook/utility-types.html#recordkeystype&quot;&gt;Record&lt;/a&gt;
제너릭 타입을 사용할 수도 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type Vec3D = Record&amp;lt;&amp;#39;x&amp;#39; | &amp;#39;y&amp;#39; | &amp;#39;z&amp;#39;, number&amp;gt;;
// Type Vec3D = {
//   x: number;
//   y: number;
//   z: number;
// }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;키마다 별도의 타입을 사용해야 한다면, 매핑된 타입을 사용할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type ABC = { [k in &amp;#39;x&amp;#39; | &amp;#39;y&amp;#39; | &amp;#39;z&amp;#39;]: k extends &amp;#39;y&amp;#39; ? string : number };
// Type ABC = {
//   a: number;
//   y: string;
//   c: number;
// }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;12-타입-단언보다는-타입-선언을-하는-것이-낫다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#12-%ED%83%80%EC%9E%85-%EB%8B%A8%EC%96%B8%EB%B3%B4%EB%8B%A4%EB%8A%94-%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8%EC%9D%84-%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EB%82%AB%EB%8B%A4&quot; aria-label=&quot;12 타입 단언보다는 타입 선언을 하는 것이 낫다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;12. 타입 단언보다는 타입 선언을 하는 것이 낫다&lt;/h2&gt;
&lt;p&gt;변수가 값을 할당하고 타입을 부여하려면 변수에 타입을 선언하여
그 값이 선언된 타입임을 명시하거나,
타입을 단언하여 타입스크립트가 추론한 타입이 있더라도
단언한 타입으로 간주하는 두 방법을 사용합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Person {
  name: string;
}

const alice: Person = { name: &amp;#39;Alice&amp;#39; };
const bob = { name: &amp;#39;Bob&amp;#39; } as Person;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;타입 선언은 할당되는 값이 해당 타입을 만족하는 지
검사하지만, 타입 단언은 타입을 강제로 단언하여
타입 체커에게 타입 오류가 있지만, 강제하여 무시하도록 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const alice: Person = {
  name: &amp;#39;Alice&amp;#39;,
  occupation: &amp;#39;Typescript developer&amp;#39;,
  // ~~~~~ Object literal may only specify known properties
  //       and &amp;#39;occupation&amp;#39; does not exist in type &amp;#39;Person&amp;#39;
};

const bob = {
  name: &amp;#39;Bob&amp;#39;,
  occupation: &amp;#39;Javascript developer&amp;#39;,
} as Person; //No error&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;타입 단언을 사용하면 문제가 해결되는 것처럼 보이지만
런타임에 문제가 발생할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Person {
  name: string;
}

const people = [&amp;#39;alice&amp;#39;, &amp;#39;bob&amp;#39;, &amp;#39;jan&amp;#39;].map(name =&amp;gt; ({} as Person));
//No error&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;일반적으로 단언문을 사용하지 않는 것이 변수를 선언하는 것이
가장 직관적이며 타입 단언은 타입 체커가 추론한 타입보다
개발자가 판단하는 타입이 더 정확할 때 유효합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;document.querySelector(&amp;#39;#myButton&amp;#39;).addEventListener(&amp;#39;click&amp;#39;, e =&amp;gt; {
  e.currentTarget; //타입은 EventTarget;
  const button = e.currentTarget as HTMLButtonElement;
  button; //타입은 HTMLButtonElement;
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;13-타입-추론은-잘못된-추론을-할-만큼-구체적으로-수행되지-않는다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#13-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0%EC%9D%80-%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%B6%94%EB%A1%A0%EC%9D%84-%ED%95%A0-%EB%A7%8C%ED%81%BC-%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%88%98%ED%96%89%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4&quot; aria-label=&quot;13 타입 추론은 잘못된 추론을 할 만큼 구체적으로 수행되지 않는다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;13. 타입 추론은 잘못된 추론을 할 만큼 구체적으로 수행되지 않는다&lt;/h2&gt;
&lt;p&gt;타입 체커는 타입이 명시되어 있지 않은 코드에 대해
할당된 값과 문맥을 통해 가능한 값들의 집합을 유추하여
타입을 추론하는 기능을 제공하기 때문에 장황하게 타입 구문
을 넣을 필요가 없습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let x: number = 12;
let x = 12;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하지만, 타입 추론은 넓은 타입 추론으로 인해 발생할 수 있는
오류를 잡고자 노력하지만, &lt;strong&gt;명확성과 유연성을 유지하기 위해
잘못된 추론을 할 만큼 구체적으로 수행하지는 않습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;타입 추론 과정에서 가능한 값들을 포함하는 집합을 찾기 위한
타입스크립트의 동작을 ‘타입 넓히기’라고 하며, 작성자의 의도가
명확하지 않은 코드에 대해 명확성과 유연성을 유지하기 위해
많은 타입의 후보군을 추론하게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const mixed = [&amp;#39;x&amp;#39;, 1];&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;yaml&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;(&amp;#39;x&amp;#39;, 1)[]
[&amp;#39;x&amp;#39;, 1]
[string, number]
readonly [string, number]
(string|number)[]
readonly (string|number)[]
[any, any]
any[]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;타입 넓히기 과정을 제어하고 더 좁은 타입으로
추론할 수 있도록 작성자의 의도를 전달해야 합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;함수의 파라미터에 할당하고자 하는 값을 변수로 분리해내면
타입스크립트는 할당 시점에 타입을 추론하기 때문에 변수
language는 string으로 추론되어 아래와 같은 에러가 발생합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type Language = &amp;#39;JavaScript&amp;#39; | &amp;#39;TypeScript&amp;#39; | &amp;#39;Python&amp;#39;;
function setLanguage(language: Language) {
  /* ... */
}

let language = &amp;#39;Javascript&amp;#39;;
setLanguage(language);
// ~~~~ Argument of type &amp;#39;string&amp;#39; is not assignable
//      to parameter of type &amp;#39;Language&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;명시된 타입 구문을 적절히 제공하여 타입 추론의 강도를 제어할
수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let language: Language = &amp;#39;Javascript&amp;#39;;
setLanguage(language); //OK&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;넓혀진 타입을 제한하기 위해 함수 파라미터에 문자열 리터럴
값을 직접 제공하여 문자열 리터럴 타입으로 추론되도록 유도할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;setLanguage(&amp;#39;Javascript&amp;#39;); //OK&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;let을 const로 사용하여 선언하면, 재할당이 없을 것이라는
의도를 전달하여 더 좁은 타입으로 추론될 수 있도록
유도할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let x = &amp;#39;x&amp;#39;; // type is string
const y = &amp;#39;y&amp;#39;; // type is &amp;#39;y&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const language = &amp;#39;Javascript&amp;#39;;
setLanguage(language); //OK&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;추가적인 예시로, 객체의 경우 타입스크립트의 넓히기 알고리즘에 의해
각 요소가 let으로 할당된 것처럼 다루기 때문에 여전히
구체적으로 타입을 추론할 수 없는 문제가 존재합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type Language = &amp;#39;JavaScript&amp;#39; | &amp;#39;TypeScript&amp;#39; | &amp;#39;Python&amp;#39;;
interface GovernedLanguage {
  language: Language;
  organization: string;
}

function complain(language: GovernedLanguage) {
  /* ... */
}

complain({ language: &amp;#39;TypeScript&amp;#39;, organization: &amp;#39;Microsoft&amp;#39; }); // OK

const ts = {
  language: &amp;#39;TypeScript&amp;#39;,
  organization: &amp;#39;Microsoft&amp;#39;,
};
complain(ts);
//       ~~ Argument of type &amp;#39;{ language: string; organization: string; }&amp;#39;
//            is not assignable to parameter of type &amp;#39;GovernedLanguage&amp;#39;
//          Types of property &amp;#39;language&amp;#39; are incompatible
//            Type &amp;#39;string&amp;#39; is not assignable to type &amp;#39;Language&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이럴 때는 ‘상수 문맥(as const)‘을 제공할 수 있습니다. &lt;strong&gt;const는
단지 값이 가리키는 참조가 변하지 않는 얕은 상수인 반면,
as const는 그 값이 내부까지 상수라는 사실을 타입스크립트에게
알려주는 타입 공간의 기법입니다.&lt;/strong&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const ts = {
  language: &amp;#39;TypeScript&amp;#39;,
  organization: &amp;#39;Microsoft&amp;#39;,
} as const;

complain(ts); // OK&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;14-string-타입보다는-더-구체적인-타입-사용을-고민해야-한다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#14-string-%ED%83%80%EC%9E%85%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%8D%94-%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%ED%83%80%EC%9E%85-%EC%82%AC%EC%9A%A9%EC%9D%84-%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4&quot; aria-label=&quot;14 string 타입보다는 더 구체적인 타입 사용을 고민해야 한다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;14. string 타입보다는 더 구체적인 타입 사용을 고민해야 한다&lt;/h2&gt;
&lt;p&gt;string은 매우 넓은 범위의 타입입니다. string은 any와
마찬가지로 더 좁은 타입으로 대체할 수 있을 가능성이 높습니다.&lt;/p&gt;
&lt;p&gt;Album 인터페이스를 정의할 때, string을 남발한 덕분에
주석에 타입 정보를 적어두었습니다.
타입으로 가능한 값을 좁히지 못하여 주석을 사용했다면,
인터페이스에 문제가 있다는 것을 증명합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;interface Album {
  artist: string;
  title: string;
  releaseDate: string; // YYYY-MM-DD
  recordingType: string; // E.g., &amp;quot;live&amp;quot; or &amp;quot;studio&amp;quot;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;또한 주석에 명시되어 있는 규칙을 따르지 않아도 타입은
문제없이 타입 체크를 통과합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const kindOfBlue: Album = {
  artist: &amp;#39;Miles Davis&amp;#39;,
  title: &amp;#39;Kind of Blue&amp;#39;,
  releaseDate: &amp;#39;August 17th, 1959&amp;#39;, // Oops!
  recordingType: &amp;#39;Studio&amp;#39;, // Oops!
}; // OK&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;releaseDate는 Date 객체를 사용하여 날짜 형식으로만
제한하고, recordingType은 ‘live’ | ‘studio’
두 가지 값으로 제한된 유니온 타입으로 정의하여 사용하는
것이 좋습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;type RecordingType = &amp;#39;studio&amp;#39; | &amp;#39;live&amp;#39;;

interface Album {
  artist: string;
  title: string;
  releaseDate: Date;
  recordingType: RecordingType;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;타입을 좁혀두면, 타입스크립트가 오류를 더 세밀하게
체크할 수 있고, 타입을 명시적으로 정의하여 다른 곳으로
값이 전달되어도 타입 정보를 유지시킬 수 있으며
keyof 연산자로 더욱 세밀하게 객체의 속성 체크가
가능해집니다.&lt;/p&gt;
&lt;p&gt;다른 예시로 객체 배열에서 한 필드의 값만 추출하는 함수를 작성할 때,
키 값으로 전달할 매개 변수의 타입이 string이기 때문에
타입 체크에 문제는 없지만, 반환값에 any가 사용되어
any의 영향력이 퍼져나가게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function pluck&amp;lt;T&amp;gt;(record: T[], key: string): any[] {
  return record.map(r =&amp;gt; r[key]);
  // ~~~~~~ Element implicitly has an &amp;#39;any&amp;#39; type
  //        because type &amp;#39;{}&amp;#39; has no index signature
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;타입 시그니처와 가능한 키 값을 keyof를 통해 제한하여
사용하거나, 더 좁히기 위해 &lt;code class=&quot;language-text&quot;&gt;keyof T&lt;/code&gt;의 부분 집합으로
두 번째 제너릭 매개변수로 전달하여 완벽하게 좁혀진 타입으로
string을 대체할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function pluck&amp;lt;T&amp;gt;(record: T[], key: keyof T) {
  return record.map(r =&amp;gt; r[key]);
}

function pluck&amp;lt;T, K extends keyof T&amp;gt;(record: T[], key: K): T[K][] {
  return record.map(r =&amp;gt; r[key]);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;15-unknown은-타입시스템에-부합하는-타입이다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#15-unknown%EC%9D%80-%ED%83%80%EC%9E%85%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%97%90-%EB%B6%80%ED%95%A9%ED%95%98%EB%8A%94-%ED%83%80%EC%9E%85%EC%9D%B4%EB%8B%A4&quot; aria-label=&quot;15 unknown은 타입시스템에 부합하는 타입이다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;15. unknown은 타입시스템에 부합하는 타입이다&lt;/h2&gt;
&lt;p&gt;unknown은 할당 가능성 관점에서 any와 비교할 수 있습니다.
any의 강력함은 어떠한 타입이든 any에 할당 가능하며,
any는 어떠한 타입으로도 할당 가능한 것에서 비롯됩니다.&lt;/p&gt;
&lt;p&gt;함수 반환값 타입을 any로 사용한다면, 함수를 호출한 곳에서
반환값은 암시적 any 타입이 되어 사용되는 곳마다 문제를
발생시킵니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function parseYAML(yaml: string): any {
  // ...
}

interface Book {
  name: string;
  author: string;
}
const book: Book = parseYAML(`
  name: Wuthering Heights
  author: Emily Brontë
`);

alert(book.title); // No error, alerts &amp;quot;undefined&amp;quot; at runtime
book(&amp;#39;read&amp;#39;); // No error, throws &amp;quot;TypeError: book is not a
// function&amp;quot; at runtime&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;대신, unknown 타입을 반환하게 만들면 타입 체크 단계에서
오류를 발생시키며 적절한 타입으로 반환을 강제하여 사용할 수
있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function safeParseYAML(yaml: string): unknown {
  return parseYAML(yaml);
}

const book = safeParseYAML(`
  name: Villette
  author: Charlotte Brontë
`) as Book;
alert(book.title);
// ~~~~~ Property &amp;#39;title&amp;#39; does not exist on type &amp;#39;Book&amp;#39;
book(&amp;#39;read&amp;#39;);
// ~~~~~~~~~ this expression is not callable&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;또한, any를 대신하여 모르는 값이 할당된 변수의 타입을 unknown으로
명시하였다면 instanceof를 체크하여 unknown에서 원하는 타입으로
변환할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function processValue(val: unknown) {
  if (val instanceof Date) {
    val; // Type is Date
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;정의된 타입 가드를 사용하여 unknown에서 원하는 타입으로 변환할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;ts&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function isBook(val: unknown): val is Book {
  return (
    typeof val === &amp;#39;object&amp;#39; &amp;amp;&amp;amp; val !== null &amp;amp;&amp;amp; &amp;#39;name&amp;#39; in val &amp;amp;&amp;amp; &amp;#39;author&amp;#39; in val
  );
}
function processValue(val: unknown) {
  if (isBook(val)) {
    val; // Type is Book
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;타입을 집합의 관점에서 생각해본다면, any는 모든 집합의
부분 집합이면서, 동시에 상위 집합인 것이고, 이는
타입시스템과 상충되는 측면을 가지고 있습니다.
타입체커는 집합 기반으로 할당 가능성을 판단하기 때문에
any를 사용하면 타입 체커가 무력화됩니다.&lt;/p&gt;
&lt;p&gt;대신, unknown타입은 any를 대신하여 사용할 수 있는
타입 시스템에 부합하는 타입입니다. &lt;strong&gt;어떤 타입이든 unknown에
할당 가능하지만, unknown은 오직 unknown과 any에만
할당 가능&lt;/strong&gt;하기 때문에 타입 시스템의 기능을 제공받으며
모르는 값에 대해 안전하게 타입 처리를 해줄 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;17-enum은-트리쉐이킹되지-않는다&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#17-enum%EC%9D%80-%ED%8A%B8%EB%A6%AC%EC%89%90%EC%9D%B4%ED%82%B9%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4&quot; aria-label=&quot;17 enum은 트리쉐이킹되지 않는다 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;17. enum은 트리쉐이킹되지 않는다&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/&quot;&gt;TypeScript enum을 사용하지 않는 게 좋은 이유를 Tree-shaking 관점에서 소개합니다.&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;p&gt;Dan VanderKam. 『&lt;a href=&quot;https://effectivetypescript.com/&quot;&gt;effective typescript&lt;/a&gt;』&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/danvk/effective-typescript&quot;&gt;danvk/effective-typescript&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://toss.tech/article/template-literal-types&quot;&gt;Template Literal Types로 타입 안전하게 코딩하기&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/&quot;&gt;TypeScript enum을 사용하지 않는 게 좋은 이유를 Tree-shaking 관점에서 소개합니다.&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[리엑트 동시성 매커니즘들은 어떻게 구현되어 있을까 - 01]]></title><description><![CDATA[리엑트v18에서 동시성 기능을 정식으로 출시하였습니다. 대표적으로,
Automatic batching for fewer renders, SSR support for
Suspense, Fixes for Suspense behavior quirks…]]></description><link>https://youthfulhps.dev/react/react-concurrent-mode-01/</link><guid isPermaLink="false">https://youthfulhps.dev/react/react-concurrent-mode-01/</guid><pubDate>Sat, 11 Jun 2022 16:07:02 GMT</pubDate><content:encoded>&lt;p&gt;리엑트v18에서 동시성 기능을 정식으로 출시하였습니다. 대표적으로,
&lt;em&gt;Automatic batching for fewer renders&lt;/em&gt;, &lt;em&gt;SSR support for
Suspense&lt;/em&gt;, &lt;em&gt;Fixes for Suspense behavior quirks&lt;/em&gt;와 같은 내부적인
성능 향상과, &lt;em&gt;startTransition&lt;/em&gt;, &lt;em&gt;useDeferredValue&lt;/em&gt;, &lt;em&gt;SuspenseList&lt;/em&gt;
과 같은 기능들이 추가되었습니다.&lt;/p&gt;
&lt;p&gt;동시성 기능을 담아내기 위해 리엑트팀은 협력적 멀티테스킹, 우선순위 기반 랜더링,
스케쥴링, 중단과 같은 메커니즘을 담아냈습니다. 기저에 있는 아키텍처를 수정해야
했던 만큼 5년이라는 시간동안 많은 시행착오를 겪었을 텐데요.&lt;/p&gt;
&lt;p&gt;이 시리즈는 &lt;em&gt;‘도대체, 동시성이 무엇이길래 리엑트팀에서 5년이라는
시간을 쏟았으며, 동시성을 위한 메커니즘들의 구현체들이 어떻게 구현되어 있을까?
’&lt;/em&gt; 라는 호기심에 찾아본 구현체들과 레퍼런스들을 차근차근 정리해보고자 합니다.&lt;/p&gt;
&lt;p&gt;그 첫 번째로, &lt;a href=&quot;https://deview.kr/2021/sessions/518&quot;&gt;Inside React (동시성을 구현하는 기술)&lt;/a&gt;에서 언급한 내용들을 정리하고, 우선순위와 양보 매커니즘이
어떻게 구현되어 있는 지 살펴보려 합니다.&lt;/p&gt;
&lt;h2 id=&quot;concurrent-vs-parallelism&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#concurrent-vs-parallelism&quot; aria-label=&quot;concurrent vs parallelism permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Concurrent vs Parallelism&lt;/h2&gt;
&lt;p&gt;동시성을 설명할 때, 서로 관련있는 병렬성과 함께 설명하곤 합니다.
하지만, 이 둘은 뚜렷한 차이를 가지고 있으며
Go 언어의 창시자의 &lt;a href=&quot;https://go.dev/blog/waza-talk&quot;&gt;Concurrency is not parallelism&lt;/a&gt;
발표 서문에는 다음과 같이 동시성과 병렬성을 비교합니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;’&lt;strong&gt;동시성은 독립적으로 실행되는 프로세스들의 조합이다.&lt;/strong&gt;’
‘병렬성은 연관된 복수의 연산들을 동시에 실행하는 것이다.’
’&lt;strong&gt;동시성은 여러 일을 한꺼번에 다루는 문제에 관한 것이다.&lt;/strong&gt;’
‘병렬성은 여러 일을 한꺼번에 실행하는 방법에 관한 것이다.’&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;아주 멜랑꼴리한데 발표에서 언급한 문구를 빌려 정리하자면,
&lt;strong&gt;동시성은 프로세서가 하나만 있는 경우, 병렬 처리를 가능케 하지만 병렬처리는 아닙니다.&lt;/strong&gt;
즉, 하나의 스레드로 작업을 순차적으로 처리하지만,
마치 여러 개의 스레드가 사용되고 있는 것처럼 보이게 하는 것이고,
동시성은 싱글 코어에서도 동작하지만, 병렬성은 두 개 이상의 코어가 필요합니다.&lt;/p&gt;
&lt;p&gt;병렬성은 예를 들어 GPU를 통해 이미지를 랜더링할 때 R, G, B를 연산하는
텍스크를 각각의 코어가 작업하는 것과 같이 최소 한 가지 논리적 통제를
멀티 코어에서 병렬적으로 진행합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 864px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDklEQVQoz4WT246EIAyGff+n27kxJl55tc66oiConPynJetmouI0aYDSfm1TKLZtAwuvOd0ld/fuUxwNVxJjzPoc7UUy/BmXZUFd13h8PdA0DUIICeacg7U2+WitUVUVyrJE3/f5Cj0FGSmhpgliFJC0N4vFRGcGsu7VruuKYRj+k5yAgZ0ocyRloDQyAbWNmKlqDnwH7mfv/Q1wnhGMISBBjSLgiNkRkOxHIFfIeg+kinzXoRM9WvENIQR+tcMoFcHOQEPJsy1zJq0UPLXXti20mfB8/sD6SJWqFLgHM5AHw5oF8pR1aneC0bQSnCvglYN42nt7LDwovmP4CfjpDd69uct3+OmXXP2Ku5/yAo1jYOU3Q/GkAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Parallel task processing&quot;
        title=&quot;Parallel task processing&quot;
        src=&quot;/static/e2d146e61c5b9a19bb4476de300b308a/9cab2/parallelism-process.png&quot;
        srcset=&quot;/static/e2d146e61c5b9a19bb4476de300b308a/5a46d/parallelism-process.png 300w,
/static/e2d146e61c5b9a19bb4476de300b308a/0a47e/parallelism-process.png 600w,
/static/e2d146e61c5b9a19bb4476de300b308a/9cab2/parallelism-process.png 864w&quot;
        sizes=&quot;(max-width: 864px) 100vw, 864px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;반면 동시성은 최소 두 개의 논리적 통제 흐름을 가지고 있으며,
잘개 쪼개진 두 개 이상의 작업을 지속적으로 컨텍스트 스위칭하여
마치 동시에 이루어지는 것처럼 보이도록 합니다.
강의를 듣다가 내용 정리를 위해 일시정지하고 메모하는 것과 같은 작업 처리 방식입니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 864px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABPklEQVQoz4WT226DMAyGef/n603RuotWEy3jsJxIQgj/bG8w2rHVkhUl2J9/O6SY5xlsvP7li+3Fbs/ZiseDPcs5i+/FPsKL7cb7gNPphMPhgMvlgmmaBDSOI2KMEmOtRVmWOB5LdF33C74qnCjJKQVDCf1HD60VhhBlvwVyaU9x71WFwXv5FkKQ4mvLE6mIziFTMgOUUwTUsDGTai8wTlzMtg3O5xcoimnbFk3TCHQFcluREieCGkvuNAUr+DGLii2QpxOcpYI9qcrSHeevM/xSOCNQtUSVm77DrbvKfFo7ioo7IPmgepzfXuks7c8wpQRnDBLJvtU3WFJQ1zXGlEmJEeAyQ75rc62gqXhM6e6m11tmc9SuJqispGoYBmgaPoN44Cn9qDHfsXu/UvHsH3xs6dlZ8eyV7L2K/17KJ+0UX3E77Ee7AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Concurrent task processing&quot;
        title=&quot;Concurrent task processing&quot;
        src=&quot;/static/1c01ef1b6acac66076081b5b3e947f91/9cab2/concurrent-process.png&quot;
        srcset=&quot;/static/1c01ef1b6acac66076081b5b3e947f91/5a46d/concurrent-process.png 300w,
/static/1c01ef1b6acac66076081b5b3e947f91/0a47e/concurrent-process.png 600w,
/static/1c01ef1b6acac66076081b5b3e947f91/9cab2/concurrent-process.png 864w&quot;
        sizes=&quot;(max-width: 864px) 100vw, 864px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;리엑트팀은-왜-동시성-기능을-구현하고자-했을까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%EC%97%91%ED%8A%B8%ED%8C%80%EC%9D%80-%EC%99%9C-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%98%EA%B3%A0%EC%9E%90-%ED%96%88%EC%9D%84%EA%B9%8C&quot; aria-label=&quot;리엑트팀은 왜 동시성 기능을 구현하고자 했을까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리엑트팀은 왜 동시성 기능을 구현하고자 했을까&lt;/h2&gt;
&lt;p&gt;리엑트는 사용자 인터페이스를 구축하는 라이브러리로서 핵심 역할인 인터렉션에
대한 업데이트 과정과 사용자 경험에 대한 HCI 연구 결과를 반영하고 궁극적으로
기술적으로 결합하는 목표를 가지고 있습니다. 사람과 컴퓨터간의 인터렉션에
대한 연구 결과들을 추상화해서 리엑트 코어의 개선 목표로 삼고 이를
구현합니다.&lt;/p&gt;
&lt;p&gt;가령, 화면 간 전환에서 로딩 중 상태를 너무 많이 표시하면 UX 품질이
낮아지는 문제라던지, 빠르게 처리되기를 기대하는 상호작용들과 느려도 문제없는
상호작용을 구분짓고 이를 적용해서 효과적으로 사용자 인터페이스에 구현할 수 있는
방법들을 제공하기 위함입니다.&lt;/p&gt;
&lt;p&gt;조금 더 와닿을 수 있게 우리의 구현체들이 동작하는 브라우저 환경에서
생각해봅시다. 브라우저는 HTML을 파싱하고, 자바스크립트를 실행하며
랜더트리를 구축하고 그려내는 작업까지 단일 스레드로서 한번에 하나의
작업만을 수행합니다.&lt;/p&gt;
&lt;p&gt;때문에 메인 스레드가 자바스크립트 엔진에게 실행권을 위임하여
자바스크립트 파싱을 시작했다면 그 작업을 멈출 수 없으며,
작업이 완료될 때까지 이후의 작업을 전개할 수 없습니다.
리엑트 랜더링 연산 과정도 동일한 절차를 거치게 되며,
이 때 매우 무거운 랜더링 연산 과정이 시작되면 이후의 작업들이 다소
긴 시간 동안 대기 상태가 되는 블로킹 랜더링이 발생합니다.&lt;/p&gt;
&lt;p&gt;재조정을 위한 리엑트의 비교 알고리즘은 매우 최적화되어 있어
블로킹되는 이슈가 자주 발생하지 않아 공감하기 어려울 수 있지만,
&lt;a href=&quot;https://ajaxlab.github.io/deview2021/blocking&quot;&gt;deview2021/blocking&lt;/a&gt;
데모처럼 입력값에 대한 픽셀 박스를 랜더링하는 연산이 무거워짐에 따라
keypress 이벤트에 대한 처리가 지연되고 있음을 경고 플래그를 통해 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACTElEQVQoz1WS23KbSBRF+f9fmoepzFQsc2ua5tJgkGSQZMeWsaILICTFKyeZB0+6atepPnVYvXvTDr/Xx6c+Pv7r9APD3y7nKOfsGSZTMsUF4xcPrlc+v/tzOT8EcP3Bn5K5y3RjXD4xti+MqxeG+Ya+/capXnM+X5lkaJLh/+sXy3k/XdHlmrho0PaRuGyJpKp8iapXRL9UrchXW7oJtmd4PV55PXxqK4zN7kInfWecPng/9Lztj2x3Pbv9QCe1k97++8j7buRtd6L7LvvxQj9cOA03TqeJYTxzPN0YDrIfrgyXG875fKTe5CxEZZMxLxZslnPaxSPZfIG1lqJJabOM2l+wrmMaW5DZmqrOycuKuqgwjym95O507wd0HFBmCfe5S5TG5KnBVQWRiglmLjry8TOfJA7JIoU/M6TGJzIeQRBjZE7fx/T7HuftuCe3OUWuSNMU1yTUekaqE4zVqDBk7ibYoJCc70n9hCBKSJTBxgIzmlhgkefRTyNOf3zDpBqbKAqps9yQFx5rk2MzceBrSqXJvsYkdyEq0b8PKHVJVoX49h6jNbrwOQ57nN1hhxLQv6VHbP+RTDwygSV+SWUzwmSGTnzcICDNxZmdiduEWJXYIsIkC9RDLJF5TIejPJv9HiUAJZYDHRD5dyJNII6zuzsBu3wJ/8I3LkqFeDNFEn0ltZHkJ449ObDyJaJQXsBBrnw6UMsffWoanpcp63VD0T5hmw2r+ZJNW1K/VMwXDzRVzUPxjVW7Zfv8KnVFu1ny3HV0r2tu1ws/Add8Hro2DvjMAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Example of blocking rendering&quot;
        title=&quot;Example of blocking rendering&quot;
        src=&quot;/static/219e96397b3d85a667ab72d28b32c3da/c1b63/blocking-rendering-example.png&quot;
        srcset=&quot;/static/219e96397b3d85a667ab72d28b32c3da/5a46d/blocking-rendering-example.png 300w,
/static/219e96397b3d85a667ab72d28b32c3da/0a47e/blocking-rendering-example.png 600w,
/static/219e96397b3d85a667ab72d28b32c3da/c1b63/blocking-rendering-example.png 1200w,
/static/219e96397b3d85a667ab72d28b32c3da/d8817/blocking-rendering-example.png 1238w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 43.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABzUlEQVQoz23QS4sTQRiF4fxOF4JLde9/EAZxp6ILN64CLkRBRAQhDmOc3Bwm104l6e50Ll3VnaruzJhbv1YnIyPRxUdxPoqHU1Xw/IDJdI7r+ojBCCGG9hziemN6jthP3+60SdFSkZiEdOiSCIGx+4XTR41cIsdB9vsUlosAIwU68khjHx32iIMGy3SB8r7ZS+9YTKqocZnp2UvC3idk8YRp8Snh60fMn9xh9uwewYv7jF89oJDEEhPNSOJ85ui5TxS4LBOD9k6JB18w00vMpEHcKWL8EovmG8aNz4SV56j3D9Fv7xJ8eMzk44kF7VMSbZ+hNWmSEkuNmmmurjcoC0t/xEJGxHNFIGwOxkxFl2FzhN9uMqifIqpfcc4rOJW6BdMMk2TkZ7rcEUUZSu5YXmfMpjtmE5tVhgwzRuKQXZHRa25x2nBxDrUytEou7dLoACY5uLTg1Y44sqg6gPPZdj+R3Sm5xRus99kfbui3Vwy6a5q1X1z82NCphnRr4VHDG1CpPw1zcLcHpW3tDTb77A1tu9baghsuq2t+llcWXtOqr/8PRseg+hfst4/B1QE0JkNri5ocvWkob8H8H/cNw539u1tQdP4Cvx/AvOVv0WaXBF6Q6ToAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Delay in processing tasks for keypress&quot;
        title=&quot;Delay in processing tasks for keypress&quot;
        src=&quot;/static/815e3dae1953dd73e6539b5104895244/c1b63/blocking-rendering-performance.png&quot;
        srcset=&quot;/static/815e3dae1953dd73e6539b5104895244/5a46d/blocking-rendering-performance.png 300w,
/static/815e3dae1953dd73e6539b5104895244/0a47e/blocking-rendering-performance.png 600w,
/static/815e3dae1953dd73e6539b5104895244/c1b63/blocking-rendering-performance.png 1200w,
/static/815e3dae1953dd73e6539b5104895244/2eb79/blocking-rendering-performance.png 1256w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;경고 플래그 중 하나의 예시로 keypress 이벤트를 처리하는 데 143.41ms이 소요 되었는데
&lt;a href=&quot;https://web.dev/rail/?utm_source=devtools#goals-and-guidelines&quot;&gt;RAIL&lt;/a&gt;
모델을 기반으로 생각한다면, 사용자는 입력 이벤트에 대해 100ms 이상 소요되는 것을
동작과 응답 사이의 연결이 지연되고 있음을 인식하게 되며, 이는 사용자 경험의 감점으로
이어질 수 있습니다.&lt;/p&gt;
&lt;p&gt;리엑트는 이러한 사용자 경험에 영향을 끼치는 랜더링 업데이트 과정에서
동시성을 통해 개선된 인터렉션을 쉽게 구현할 수 있도록 하는 구현체를 제공하고자
했습니다.&lt;/p&gt;
&lt;h2 id=&quot;동시성-메커니즘-우선순위&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84&quot; aria-label=&quot;동시성 메커니즘 우선순위 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;동시성 메커니즘; 우선순위&lt;/h2&gt;
&lt;p&gt;리엑트에서 동시성을 구현하는 첫번 째 메커니즘은 바로 우선순위입니다. 인터렉션에 의해
발생한 이벤트와 업데이트 작업들이 어떻게 우선순위는 어떻게 결정되고 할당되는 지
궁금했는데요. 그 과정에 대해 차근차근 살펴봅시다.&lt;/p&gt;
&lt;p&gt;우선순위 메커니즘은 사용자 인터렉션 발생을 캐치한 리스너에서부터
작업 생성 과정과 스케쥴링 단계까지 업데이트를 위한
작업의 우선순위를 할당하기 위한 전반적인 과정에서 쉽게 찾아볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;그 이후 진행 중인 작업이 우선 순위가 높은 대기 상태의 작업에 의해 중단되거나,
같은 우선 순위를 가진 작업에 대해서 일괄 처리될 수 있도록 하는 작업 교통정리
를 하는 작업 실행 단계에서도 확인할 수 있는데요.&lt;/p&gt;
&lt;p&gt;한편, 리엑트v17.0 이전에서는 작업의 &lt;a href=&quot;https://github.com/facebook/react/blob/v16.12.0/packages/react-reconciler/src/ReactFiberExpirationTime.js&quot;&gt;만료 시간을 기준으로 우선순위를 부여&lt;/a&gt;하는 메커니즘으로 구현되어 있었습니다.
반면, 리엑트v17.0 이후에서는 Lane 모델을 착안하여 비트 연산을
기반으로 우선 순위를 부여하는 방식으로 변경되었는데요.
먼저, 전반적인 우선순위 메커니즘 기저의 구현체인 Lane을 살펴봅시다.&lt;/p&gt;
&lt;h3 id=&quot;lane-모델-그리고-lane-우선순위&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#lane-%EB%AA%A8%EB%8D%B8-%EA%B7%B8%EB%A6%AC%EA%B3%A0-lane-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84&quot; aria-label=&quot;lane 모델 그리고 lane 우선순위 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Lane 모델, 그리고 Lane 우선순위&lt;/h3&gt;
&lt;p&gt;Lane 모델은 도로의 차선을 모티브로 하여 리엑트에서 우선순위를
표현하기 위해 구현된 31비트 데이터로 표현된 비트맵입니다.
작업의 스케쥴링 및 조정 작업 과정의 우선순위를 가진 고유의 작업 스레드를
표현합니다.&lt;/p&gt;
&lt;p&gt;실제 레인의 구현에서 확인할 수 있듯, 기본적으로 더 작은 숫자로 표현된
레인이 높은 우선순위를 갖습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-reconciler/src/ReactFiberLane.new.js

export type Lanes = number;
export type Lane = number;
export type LaneMap&amp;lt;T&amp;gt; = Array&amp;lt;T&amp;gt;;

export const TotalLanes = 31;

export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;
export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;
export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000010;
export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000000100;
export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000001000;
export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000010000;
const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000000100000;
const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111111000000;
const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000001000000;
...
const RetryLanes: Lanes = /*                            */ 0b0000111110000000000000000000000;
const RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;
...

export const SomeRetryLane: Lane = RetryLane1;
export const SelectiveHydrationLane: Lane = /*          */ 0b0001000000000000000000000000000;
const NonIdleLanes: Lanes = /*                          */ 0b0001111111111111111111111111111;
export const IdleHydrationLane: Lane = /*               */ 0b0010000000000000000000000000000;
export const IdleLane: Lane = /*                        */ 0b0100000000000000000000000000000;
export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;Lane 모델은 우선순위를 두 가지 중요한 컨셉으로 분리합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Task Prioritization, A 작업이 B 작업보다 급한가?&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Task Batching, A 작업이 이 그룹 텍스크에 속하는 가?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;작업 우선순위 개념을 통해 작업의 우선순위를 기준으로 작업의
우선 실행권을 부여하고, 작업 배칭 개념을 착안하여
가령 CPU, I/O, CPU 순의 작업 예약에 대해,
I/O 작업을 다른 그룹으로 분리하여 일괄 처리함으로서 CPU 작업의 병목을
방지할 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;CPU 작업이 I/O 작업보다 우선순위가 낮아 지속적인 양보가 발생하게 되면 CPU 작업처리에
진전이 없을 여지를 방지하기 위해 I/O 작업들을 묶어 진행할 수 있도록 하는 것은
리엑트v18에서 제공하는 &lt;a href=&quot;https://github.com/reactwg/react-18/discussions/21&quot;&gt;Automatic Batching&lt;/a&gt;
의 기저에 있는 동작 방식인듯 합니다. 깊이 있게 살펴볼 부분들이 차고 넘치네요.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Task Prioritization이 표현되는 각각의 레인이 가지고 있는
비트 값이 우선순위를 나타내고 있으며, 레인의 이름을 통해
어떠한 업데이트가 소유할 수 있는 레인인지 파악해볼 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;SyncLane&lt;/strong&gt;, 이산적인(discrete) 사용자 상호 작용에 대한 업데이트&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;InputContinuousLane&lt;/strong&gt;, 연속적인(continuous) 사용자 상호 작용에 대한 업데이트&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;DefaultLane&lt;/strong&gt;, setTimeout, 네트워크 요청 등에 의해 생성된 업데이트&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;TransitionLane&lt;/strong&gt;, Suspense, useTransition, useDefferredValue에 의해 생성된 업데이트&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;레인 모델이 어떻게 구현되어 있는 지 간단하게 살펴보았다면,
어떻게 적용되어 사용되는 지 확인해볼 차례입니다.
리엑트에서 Lane 모델을 기반으로 Lane 우선순위 개념을 이벤트 우선순위와
스케쥴러 우선순위에 녹여냈는 지 살펴봅시다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;레인에 대한 추가적인 내용은 초기 레인 모델을 구현한 &lt;a href=&quot;https://github.com/facebook/react/pull/18796&quot;&gt;react/pull/18796&lt;/a&gt;
PR을 참고하시면 좋습니다.&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;이벤트-우선순위&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84&quot; aria-label=&quot;이벤트 우선순위 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이벤트 우선순위&lt;/h3&gt;
&lt;p&gt;리엑트는 사용자 인터렉션에 의해 발생된 이벤트를 인위적으로 구분짓고,
구분된 이벤트를 묶어 우선순위를 결정짓습니다.
여기서, 크게 두 종류로 구분되어 루트에 바인딩될 때 어느 범주에 속한
이벤트인지에 따라 우선순위가 부여됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;이산적인 이벤트 (e.g. click, keydown, focusin, ..)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;연속적인 이벤트 (e.g. drag, pointermove, scroll, ..)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-reconciler/src/ReactEventPriority.new.js

export const DiscreteEventPriority: EventPriority = SyncLane;
export const ContinuousEventPriority: EventPriority = InputContinuousLane;
export const DefaultEventPriority: EventPriority = DefaultLane;
export const IdleEventPriority: EventPriority = IdleLane;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;잠시 이산적인 이벤트와 연속적인 이벤트를 구분짓는 이유를 생각해보자면,
가령 사용자가 문서를 읽다가, 문서에 참조되어 있는 링크를 클릭하는
이산적인 이벤트를 발생시켰다면 이는 즉각적으로 반응하기를 원할겁니다.&lt;/p&gt;
&lt;p&gt;반면 문서를 읽을 때 시선의 흐름에 따라 사용자가 포인터를 움직였다면,
이로 인해 발생한 연속적인 이벤트에 대해서는 사용자 입장에서 성능에 영향을
줄 것이라 생각하기 힘들고, 또한 빠르게 반응해주기를 원하는 이벤트라고
간주하기 어려울 수 있기 때문입니다.
관련해서 &lt;a href=&quot;https://wicg.github.io/is-input-pending/#continuous-events&quot;&gt;연속적인 이벤트(Continuous events)&lt;/a&gt;를 참고할 수 있습니다.&lt;/p&gt;
&lt;p&gt;다시 돌아와, 앞서 살펴보았던 31비트로 구성된 Lane 값들이 이벤트 우선순위
할당되는 값으로 사용되고 있으며, 각각의 이벤트에 대해 우선순위를 반환하는 함수가
구현되어 있는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-dom/src/events/ReactDOMEventListener.js

export function getEventPriority(domEventName: DOMEventName): * {
  switch (domEventName) {
    case &amp;#39;cancel&amp;#39;:
    case &amp;#39;click&amp;#39;:
    case &amp;#39;close&amp;#39;:
    case &amp;#39;contextmenu&amp;#39;:
    ...
      return DiscreteEventPriority;
    case &amp;#39;drag&amp;#39;:
    case &amp;#39;dragenter&amp;#39;:
    case &amp;#39;dragexit&amp;#39;:
    case &amp;#39;dragleave&amp;#39;:
    ...
      return ContinuousEventPriority;
    case &amp;#39;message&amp;#39;: {
      const schedulerPriority = getCurrentSchedulerPriorityLevel();
      switch (schedulerPriority) {
        case ImmediateSchedulerPriority:
          return DiscreteEventPriority;
        case UserBlockingSchedulerPriority:
          return ContinuousEventPriority;
        ...
      }
    }
    default:
      return DefaultEventPriority;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;em&gt;여기서 ‘message’ 이벤트는 따로 처리해주는 것을 확인할 수 있는데, 협력적 스케쥴링 모델을
사용하고, 정확한 스케쥴링 타임을 위해 리엑트 스케쥴러에서는 MessageChannel API를 기반으로
구현되어 있습니다. 따라서 ‘message’ 이벤트가 스케쥴러 콜백일 수 있기 때문에
‘message’ 이벤트에 대해서는 네이티브 스케쥴러에 대한 현재 우선 순위를 확인하여 반환합니다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;getEventPriority()&lt;/code&gt; 를 따라 올라가다 보면, 대응되는 이벤트 우선순위를
각각의 이벤트 리스너에 래핑시키고, 우선순위가 래핑된 이벤트 리스너를 반환하는 곳에서
사용됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-dom/src/events/ReactDOMEventListener.js

export function createEventListenerWrapperWithPriority(
  targetContainer: EventTarget,
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags
): Function {
  const eventPriority = getEventPriority(domEventName);
  let listenerWrapper;
  switch (eventPriority) {
    case DiscreteEventPriority:
      listenerWrapper = dispatchDiscreteEvent;
      break;
    case ContinuousEventPriority:
      listenerWrapper = dispatchContinuousEvent;
      break;
    case DefaultEventPriority:
    default:
      listenerWrapper = dispatchEvent;
      break;
  }
  return listenerWrapper.bind(
    null,
    domEventName,
    eventSystemFlags,
    targetContainer
  );
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;결국 &lt;code class=&quot;language-text&quot;&gt;createRoot()&lt;/code&gt; 에서
리엑트17 이후 버전의 &lt;a href=&quot;https://ko.reactjs.org/blog/2020/08/10/react-v17-rc.html#changes-to-event-delegation&quot;&gt;이벤트 위임 메커니즘&lt;/a&gt;
에 입각하여, 우선 순위가 래핑된 이벤트 리스너들이 모두 루트에 바인딩되게 됩니다.&lt;/p&gt;
&lt;p&gt;이를 통해 사용자 상호 인터렉션에 따라 발생한 이벤트 우선순위는,
우선순위가 래핑된 이벤트 리스너를 통해 주입받을 수 있게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-dom/src/client/ReactDOMRoot.js

export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions,
): RootType {
  ...
  const root = createContainer(
    ...
  );
  markContainerAsRoot(root.current, container);

  const rootContainerElement: Document | Element | DocumentFragment =
    container.nodeType === COMMENT_NODE
      ? (container.parentNode: any)
      : container;
  listenToAllSupportedEvents(rootContainerElement); //**

  return new ReactDOMRoot(root);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;스케쥴링-우선순위&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84&quot; aria-label=&quot;스케쥴링 우선순위 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;스케쥴링 우선순위&lt;/h3&gt;
&lt;p&gt;스케쥴링 우선순위는 스케쥴러 기반의 리엑트 업데이트 작업이 가지는
우선순위입니다. 스케쥴러는 스케쥴링 우선순위를 통해 산발적으로
발생하는 작업들의 교통정리를 진행합니다.&lt;/p&gt;
&lt;p&gt;가령 이벤트가 발생하여 setState를 통해 부가적인 상태 업데이트가
디스패치되면, 리콘실러는 업데이트 작업의 정보를 담은 객체를 생성하여
스케쥴러에게 전달하게 되는데, 업데이트 객체를 생성하는 단계에서
작업의 스케쥴링 우선순위를 구하기 위한 단계가 포함됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-reconciler/src/ReactFiberHooks.new.js

function dispatchSetState&amp;lt;S, A&amp;gt;(
  fiber: Fiber,
  queue: UpdateQueue&amp;lt;S, A&amp;gt;,
  action: A,
) {
  ...

  const lane = requestUpdateLane(fiber);

  const update: Update&amp;lt;S, A&amp;gt; = {
    lane,
    action,
    hasEagerState: false,
    eagerState: null,
    next: (null: any),
  };

  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;업데이트 객체에 전달되는 우선순위를 구하는 &lt;code class=&quot;language-text&quot;&gt;requestUpdateLane()&lt;/code&gt;
는 어떻게 이벤트 우선순위를 얻어오는 지 살펴봅시다.&lt;/p&gt;
&lt;h3 id=&quot;requestupdatelane&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#requestupdatelane&quot; aria-label=&quot;requestupdatelane permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;requestUpdateLane&lt;/h3&gt;
&lt;p&gt;리엑트는 동시성 기능을 담은 모드와 기존 레거시 모드를 함께 제공하고
있기 때문에, 먼저 동시성 기능이 제공되는 모드인지 확인하는 과정을
거칩니다. 만약 아니라면, 우선순위가 가장 높은 &lt;code class=&quot;language-text&quot;&gt;SyncLane&lt;/code&gt;을 반환합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function requestUpdateLane(fiber: Fiber): Lane {
  const mode = fiber.mode;
  if ((mode &amp;amp; ConcurrentMode) === NoMode) {
    return (SyncLane: Lane);
  }
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;한편 동시성 기능을 제공하는 모드라면, 먼저 현재 실행 중인 작업이 있는 지
확인합니다. 만약 있다면, 현재 실행 중인 작업의 레인이 직접 반환되고,
새 작업이 기존 작업과 같은 우선순위를 부여받게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let workInProgressRootRenderLanes: Lanes = NoLanes;

export function requestUpdateLane(fiber: Fiber): Lane {
  ...
  else if (
    !deferRenderPhaseUpdateToNextBatch &amp;amp;&amp;amp;
    (executionContext &amp;amp; RenderContext) !== NoContext &amp;amp;&amp;amp;
    workInProgressRootRenderLanes !== NoLanes
  ) {
    return pickArbitraryLane(workInProgressRootRenderLanes);
  }
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-reconciler/src/ReactFiberLane.new.js

export function getHighestPriorityLane(lanes: Lanes): Lane {
  return lanes &amp;amp; -lanes;
}

export function pickArbitraryLane(lanes: Lanes): Lane {
  return getHighestPriorityLane(lanes);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위 조건에 포함되지 않았다면, 이제 현재 이벤트가 전환 우선 순위인지에 대한
여부를 결정하고 맞다면 적절한 전환 우선순위에 할당하게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let currentEventTransitionLane: Lanes = NoLanes;

export function requestUpdateLane(fiber: Fiber): Lane {
  ...
  const isTransition = requestCurrentTransition() !== NoTransition;
  if (isTransition) {
    if (__DEV__ &amp;amp;&amp;amp; ReactCurrentBatchConfig.transition !== null) {
      const transition = ReactCurrentBatchConfig.transition;
      if (!transition._updatedFibers) {
        transition._updatedFibers = new Set();
      }

      transition._updatedFibers.add(fiber);
    }
    if (currentEventTransitionLane === NoLane) {
      currentEventTransitionLane = claimNextTransitionLane();
    }
    return currentEventTransitionLane;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-reconciler/src/ReactFiberLane.new.js

export function claimNextTransitionLane(): Lane {
  const lane = nextTransitionLane;
  nextTransitionLane &amp;lt;&amp;lt;= 1;
  if ((nextTransitionLane &amp;amp; TransitionLanes) === NoLanes) {
    nextTransitionLane = TransitionLane1;
  }
  return lane;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이 때, 생성된 작업에 대해 맨 오른쪽 비트를 소유하는 &lt;code class=&quot;language-text&quot;&gt;TransitionLane&lt;/code&gt;을
할당하고, 그 이후에 생성된 전환 작업은 비트가 왼쪽으로 한 자리 이동한
레인 즉, 우선순위가 보다 낮은 &lt;code class=&quot;language-text&quot;&gt;TransitionLane&lt;/code&gt;이 할당합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;TransitionLane1 = 0b0000000000000000000000001000000;
TransitionLane2 = 0b0000000000000000000000010000000;
...

TransitionLanes = 0b0000000001111111111111111000000;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;전환 우선순위 작업이 아닌 경우에는 어떻게 처리될까요? 이벤트 우선순위 섹션에서
우선순위가 래핑된 이벤트 리스너가 모두 루트에 바인딩되는 걸 확인했었는데요.
여기서 이벤트가 발생하면 &lt;code class=&quot;language-text&quot;&gt;getCurrentUpdatePriority()&lt;/code&gt;가 호출되어
현재 이벤트 우선순위가 반환되어 스케쥴링 우선순위로 사용됩니다.&lt;/p&gt;
&lt;p&gt;만약 현재 이벤트 우선순위가 비어있다면 동일하게 &lt;code class=&quot;language-text&quot;&gt;getCurrentUpdatePriority()&lt;/code&gt;
에서 외부 이벤트의 우선순위를 가져옵니다. 이런 케이스는 가령, &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt;가
&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;에서 호출된 케이스입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function requestUpdateLane(fiber: Fiber): Lane {
  ...
  const updateLane: Lane = (getCurrentUpdatePriority(): any);
  if (updateLane !== NoLane) {
    return updateLane;
  }

  const eventLane: Lane = (getCurrentEventPriority(): any);
  return eventLane;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;결과적으로 얻어진 스케쥴링 우선순위는 업데이트 객체에 할당됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function createUpdate(eventTime: number, lane: Lane): Update&amp;lt;*&amp;gt; {
  const update: Update&amp;lt;*&amp;gt; = {
    eventTime,
    lane,

    tag: UpdateState,
    payload: null,
    callback: null,

    next: null,
  };
  return update;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다음으로 업데이트해야 하는 컨텐츠와 업데이트 콜백 함수를
담아 업데이트 객체를 완성하게 되고, 현재 컴포넌트에 해당하는
Fiber 노드의 업데이트 대기열에 업데이트 객체가 추가됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;update.payload = payload;
if (callback !== undefined &amp;amp;&amp;amp; callback !== null) {
  update.callback = callback;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;enqueueUpdate(fiber, update, lane);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위와 같은 과정들을 통해 리엑트는 Lane 모델을 기반으로 우선순위
메커니즘을 구현하고 실제 이벤트의 발생과 작업 생성 단계에서
어떻게 적절한 우선순위를 할당하는 지 그 과정을 살펴보았습니다.&lt;/p&gt;
&lt;h2 id=&quot;동시성-메커니즘-양보&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98-%EC%96%91%EB%B3%B4&quot; aria-label=&quot;동시성 메커니즘 양보 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;동시성 메커니즘; 양보&lt;/h2&gt;
&lt;p&gt;각각의 작업에 대해 우선순위가 어떻게 할당되는 지 확인했다면,
이제 우선순위를 기준으로 현재 진행 중인 작업이 점유하고 있는
메인 스레드가 대기 중인 높은 작업에 의해 중단되고 메인 스레드의 점유를
양보하는 지 알아봅시다.&lt;/p&gt;
&lt;p&gt;브라우저는 랜더링 엔진에게 메인 스레드 점유를 위임하게 되면,
랜더링 과정 중 발생한 사용자 입력에 대해 즉시 처리할 수 없게 되기 때문에
사용자가 즉각적으로 반응하고 처리되기를 기대하는 이벤트에 대해
랜더링 작업 중에는 처리할 수 없게 되는데요.&lt;/p&gt;
&lt;p&gt;리엑트는 이러한 근본적인 원인을 해결하고자 모든 랜더링을 인터럽트 가능하도록 하여
우선순위가 높은 작업이 텍스크 스택에 들어오면 진행중이던 작업을 중단하고 메인 스레드에게
점유를 양보할 수 있는 메커니즘을 구현하게 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA1UlEQVQoz42S6wqDMAyF+/5PuMl+uckG1mpbe/F6ZgtK0VY9UAJJ+DhJSrDTPM9bDF9Yj9XWSO5AwlpMYZ7Ekk7TNCHLMjyeT+R5vvUMDUNb/lDVNRhjGMfx3GHXdej7Hv0wwLQtaPFBxWqfm5a6tALSSAghoJQ6uCd7d67JWuuBWkiU3xyMNzDaeNexcQ8jhw6llNBawy5OVcNRvF+gbszF7QqMHeTyKE5ufK44uOA46wt1CnSurLF+X/u+lMjZThyQUgpjzSUoCUx9ozuwJDC1gjvQP0YgZVDyZo+xAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;When the user&amp;#39;s input comes in, rendering is interrupted&quot;
        title=&quot;When the user&amp;#39;s input comes in, rendering is interrupted&quot;
        src=&quot;/static/e2ceddd26691f38b0dec421c08a40c58/c1b63/interruption-and-yield.png&quot;
        srcset=&quot;/static/e2ceddd26691f38b0dec421c08a40c58/5a46d/interruption-and-yield.png 300w,
/static/e2ceddd26691f38b0dec421c08a40c58/0a47e/interruption-and-yield.png 600w,
/static/e2ceddd26691f38b0dec421c08a40c58/c1b63/interruption-and-yield.png 1200w,
/static/e2ceddd26691f38b0dec421c08a40c58/d61c2/interruption-and-yield.png 1800w,
/static/e2ceddd26691f38b0dec421c08a40c58/97a96/interruption-and-yield.png 2400w,
/static/e2ceddd26691f38b0dec421c08a40c58/5fe07/interruption-and-yield.png 3422w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;하지만 메인스레드를 양보하기 이전에, 메인 스레드를 점유하여 랜더링 연산을
전개하고 있는 과정에서 사용자의 입력에 대한 처리가 대기 중임을 확인하고
메인 스레드 점유를 양보해야 하는 지에 대해 판단하는 것이 더 우선적으로
가능해야 했습니다.&lt;/p&gt;
&lt;p&gt;이를 위해 페이스북은 메인스레드를 점유당하고 있는 상황에서 우선순위가 높은 작업이
대기 중임을 확인하는 구현체인 &lt;a href=&quot;https://wicg.github.io/is-input-pending/&quot;&gt;isInputPending&lt;/a&gt;
를 브라우저 API에 처음으로 기여하게 됩니다.&lt;/p&gt;
&lt;p&gt;실제로 리엑트의 &lt;a href=&quot;https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js&quot;&gt;스케쥴러&lt;/a&gt; 에는
&lt;code class=&quot;language-text&quot;&gt;isInputPending&lt;/code&gt;을 사용하기 위해 호스트 환경에 의존적인 API를 사용할 수 있는 지에
대해 판단하는 플래그들이 존재합니다.&lt;/p&gt;
&lt;h3 id=&quot;shouldyieldtohost&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#shouldyieldtohost&quot; aria-label=&quot;shouldyieldtohost permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;shouldYieldToHost&lt;/h3&gt;
&lt;p&gt;이제 랜더링 과정에서 우선순위가 높은 작업이 대기 중임을 확인할 수 있는 구현체를
사용해서 내부적으로 어떻게 양보가 이루어질 수 있도록 구현되어 있는 지 확인해봅시다.&lt;/p&gt;
&lt;p&gt;양보가 필요한 상황인지를 판단하기 위한 첫 검증은 현재 작업을
처리하기 위해 얼마만큼의 시간을 소요했는 지를 확인합니다.
경과된 시간이 &lt;code class=&quot;language-text&quot;&gt;frameInterval&lt;/code&gt; 값보다 작다면, 메인 스레드는 단일 프레임만큼
아주 짧은 시간동안만 차단되어 있었기 때문에 양보를 거절합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// SchedulerFeatureFlags.js

export const frameYieldMs = 5;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { frameYieldMs } from &amp;#39;../SchedulerFeatureFlags&amp;#39;;

let frameInterval = frameYieldMs;

function shouldYieldToHost() {
  const timeElapsed = getCurrentTime() - startTime;

  if (timeElapsed &amp;lt; frameInterval) {
    return false;
  }
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이후의 스코프에서는 메인 스레드가 무시할 수 없는 시간 동안 차단되었을 때
대기 중인 페인트 혹은 사용자 입력 작업이 존재한다면,
브라우저가 높은 우선 순위 작업을 수행할 수 있도록 메인 스레드에
대한 점유를 양보합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let needsPaint = false;

function requestPaint() {
  if (
    enableIsInputPending &amp;amp;&amp;amp;
    navigator !== undefined &amp;amp;&amp;amp;
    navigator.scheduling !== undefined &amp;amp;&amp;amp;
    navigator.scheduling.isInputPending !== undefined
  ) {
    needsPaint = true;
  }
}

function shouldYieldToHost() {
  ...
  if (enableIsInputPending) {
    if (needsPaint) {
      return true;
    }
  }
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서 &lt;code class=&quot;language-text&quot;&gt;requestPaints()&lt;/code&gt; 는 isInputPending API를 사용할 수 있는 지,
사용할 수 있다면 현재 사용자 입력에 대한 페인트 작업이 대기 중인지를 판단하여
&lt;code class=&quot;language-text&quot;&gt;needsPaint&lt;/code&gt; 플래그를 반환하게 역할을 하는데요.&lt;/p&gt;
&lt;p&gt;이를 통해 리콘실러는 VDOM의 변경사항을 DOM에 모두 커밋하고
&lt;code class=&quot;language-text&quot;&gt;requestPaints()&lt;/code&gt;를 호출하여 페인트 작업이 필요하다는 것을 스케쥴러에게 전달할 수 있게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// ReactFiberWorkLoop.new.js

import { requestPaint } from &amp;#39;./Scheduler&amp;#39;;

function commitRootImpl(...) {
  ...
  requestPaint();
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다음으로는 경과된 시간이 연속적인 입력 인터벌보다 짧은 지 검증합니다.
&lt;a href=&quot;#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84&quot;&gt;이벤트 우선순위&lt;/a&gt;에서 이산적, 연속적인 이벤트를 구분짓는 같은 맥락으로,
isInputPending은 단순히 모든 사용자 이벤트를 동일하게 처리하지 않고,
&lt;a href=&quot;https://wicg.github.io/is-input-pending/#continuous-events&quot;&gt;연속적인 이벤트&lt;/a&gt; (e.g. click)와 이산적인 이벤트 (e.g. mouseover)를 구분지어
&lt;strong&gt;연속적인 이벤트에 대해 양보가 너무 자주 발생하게 되는 것을 방지합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;즉 이 검증 단계에서는, 연속적인 이벤트에 대한 처리 작업을 즉시 시작하지 않을 간격을 두고,
그 시간 동안에는 판단을 온전히 브라우저에게 맡깁니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// SchedulerFeatureFlags.js

export const continuousYieldMs = 50;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { continuousYieldMs } from &amp;#39;../SchedulerFeatureFlags&amp;#39;

const continuousInputInterval = continuousYieldMs;

const isInputPending =
  typeof navigator !== &amp;#39;undefined&amp;#39; &amp;amp;&amp;amp;
  navigator.scheduling !== undefined &amp;amp;&amp;amp;
  navigator.scheduling.isInputPending !== undefined
    ? navigator.scheduling.isInputPending.bind(navigator.scheduling)
    : null;

function shouldYieldToHost() {
  ...
  if (timeElapsed &amp;lt; continuousInputInterval) {
    if (isInputPending !== null) {
      return isInputPending();
    }
  }
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;마지막으로 최대 간격 이내에 보류 중인 연속적이거나, 이산적인 모든 이벤트에 대해
양보합니다. 이후 모든 분기 처리가 담지 못한 케이스에 대해서는,
보류 중인 입력이 없더라도 네트워크 이벤트와 같은 외부 이벤트에 의한 작업들이
대기 중일 수 있다는 가정하에 무조건적으로 양보하게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// SchedulerFeatureFlags.js

export const maxYieldMs = 300;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { maxYieldMs } from &amp;#39;../SchedulerFeatureFlags&amp;#39;

function shouldYieldToHost() {
    ...
    else if (timeElapsed &amp;lt; maxInterval) {
      // Yield if there&amp;#39;s either a pending discrete or continuous input.
      if (isInputPending !== null) {
        return isInputPending(continuousOptions);
      }
    } else {
      return true;
    }
  }

  return true;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;초기에 분기처리 되었던 호스트 환경에 의존적인 isInputPending API를
사용할 수 없는 경우 또한 무조건적으로 양보합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function shouldYieldToHost() {
  ...
  if (enableIsInputPending) {
    ...
  }

  return true;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;지금까지 알아본 &lt;code class=&quot;language-text&quot;&gt;shouldYieldToHost()&lt;/code&gt;는 스케쥴러의 &lt;code class=&quot;language-text&quot;&gt;workLoop()&lt;/code&gt;에서 사용됩니다. 현재 진행 중인 작업의 만료시간이 현재 시간에 비해 여유가 있는 시점에서
우선 순위가 더 높은 작업이 보류되고 있다면, 메인 스레드에게 제어권을 양보하고, 만료 시간이
지난 작업에 대해서는 양보하지 않고 동기적으로 바쁘게 작업을 이어나갑니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function workLoop(hasTimeRemaining, initialTime) {
  ...
  while (
    currentTask !== null &amp;amp;&amp;amp;
    !(enableSchedulerDebugging &amp;amp;&amp;amp; isSchedulerPaused)
  ) {
    if (
      currentTask.expirationTime &amp;gt; currentTime &amp;amp;&amp;amp;
      (!hasTimeRemaining || shouldYieldToHost())
    ) {
      break;
    }
  ...
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;추가적으로 스케쥴러가 아닌, 동시성 모드에서 컴포넌트를 재조정하는 작업이 담긴
&lt;code class=&quot;language-text&quot;&gt;workLoopConcurrent()&lt;/code&gt; 에서도 사용되는데요. &lt;code class=&quot;language-text&quot;&gt;shouldYieldToHost()&lt;/code&gt; 통해
진행되던 재조정 작업이 중지될 수 있음이 조건에 담겨있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-reconciler/src/ReactFiberWorkLoop.new.js

import { shouldYield } from &amp;#39;./Scheduler&amp;#39;;
function workLoopConcurrent() {
  while (workInProgress !== null &amp;amp;&amp;amp; !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이를 통해 리콘실러는 &lt;code class=&quot;language-text&quot;&gt;workLoopConcurrent()&lt;/code&gt;를 통해 현재 작업중이던 루트 혹은 Lane이
변경되면, 루트에 대기중인 작업들을 모두 비우고, 변경된 레인의 작업이 진행될 수 있도록 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function renderRootConcurrent(root: FiberRoot, lanes: Lanes) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher();

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    ...
        const memoizedUpdaters = root.memoizedUpdaters;
        if (memoizedUpdaters.size &amp;gt; 0) {
          restorePendingUpdaters(root, workInProgressRootRenderLanes);
          memoizedUpdaters.clear();
        }

        movePendingFibersToMemoized(root, lanes);
      }
    }
  }
  ...

  do {
    try {
      workLoopConcurrent();
      ...
    }
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h3&gt;
&lt;p&gt;리엑트의 동시성 기능을 담은 구현체들을 살펴보았습니다. 이번 글에서는
전반적인 동시성 기능에 대한 서론과 우선순위가 어떻게 할당되는 지, 그리고
어떻게 메인스레드 점유가 양보되는 지에 대해 알아보았는데요.&lt;/p&gt;
&lt;p&gt;공부를 하면 할수록 사용자 인터페이스를 구축하는 기능을 제공하는 리엑트가
사용자 경험과 사용성 개선을 위해 고민하고 쉽게 구현할 수 있는 기능들을
제공하기 위해 얼마나 노력하는 지 느낄 수 있어 큰 자극을 얻을 수 있었습니다.&lt;/p&gt;
&lt;p&gt;한글로 정리된 글들이 많지 않아 다양한 레퍼런스들을 찾아보고, 흩어진 자료를
모아 정리하려는 목적으로 글을 정리해보았습니다. 직접 리엑트 구현체 코드들을
들여다보면서 어려움이 많았는데, 어설프게 정리하고 싶지 않아 생각보다 오랜 시간
끙끙댔던 시간이었는데요.
아직 살펴볼 내용들이 차고 넘치기 때문에 끊고 다음 글에서 이어서 정리하는
시간을 가지려 합니다.&lt;/p&gt;
&lt;p&gt;사실, 리엑트에서 제공하는 동시성 기능 API들을 어떻게 사용하는 지 알아보고
적절하게 사용을 즐기는 공부를 하면 마음 편하겠지만, 직접 구현체들의 내막을
들여다보고 나서 그 이해가 동시성 기능 API들을 사용할 때 보다 더 깊은
사용법을 이끌어낼 수 있지 않을까 하는 기대를 합니다.&lt;/p&gt;
&lt;p&gt;잘못된 설명이나, 얕은 지식으로 어설프게 설명되어 있는 부분에 대해서는 언제든
지적해주시면 다시금 수정하고 정리할 수 있도록 하겠습니다. 감사합니다 :)&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://deview.kr/2021/sessions/518&quot;&gt;Inside React (동시성을 구현하는 기술)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.to/okmttdhr/what-is-lane-in-react-4np7&quot;&gt;What is “Lane” in React?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://goidle.github.io/react/in-depth-react-preview/&quot;&gt;React 톺아보기 - 01. Preview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react/pull/18796&quot;&gt;github.com/facebook/react/pull/18796&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react&quot;&gt;github.com/facebook/react&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wicg.github.io/is-input-pending/#continuous-events&quot;&gt;wicg.github.io/is-input-pending&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7008802041602506765&quot;&gt;React 소스 코드 파싱 우선 순위 Lane 모델&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[리엑트 동시성 매커니즘들은 어떻게 구현되어 있을까 - 01]]></title><description><![CDATA[리엑트v18에서 동시성 기능을 정식으로 출시하였습니다. 대표적으로,
Automatic batching for fewer renders, SSR support for
Suspense, Fixes for Suspense behavior quirks…]]></description><link>https://youthfulhps.dev/react/react-concurrent-mode/</link><guid isPermaLink="false">https://youthfulhps.dev/react/react-concurrent-mode/</guid><pubDate>Sat, 11 Jun 2022 16:07:02 GMT</pubDate><content:encoded>&lt;p&gt;리엑트v18에서 동시성 기능을 정식으로 출시하였습니다. 대표적으로,
&lt;em&gt;Automatic batching for fewer renders&lt;/em&gt;, &lt;em&gt;SSR support for
Suspense&lt;/em&gt;, &lt;em&gt;Fixes for Suspense behavior quirks&lt;/em&gt;와 같은 내부적인
성능 향상과, &lt;em&gt;startTransition&lt;/em&gt;, &lt;em&gt;useDeferredValue&lt;/em&gt;, &lt;em&gt;SuspenseList&lt;/em&gt;
과 같은 기능들이 추가되었습니다.&lt;/p&gt;
&lt;p&gt;동시성 기능을 담아내기 위해 리엑트팀은 협력적 멀티테스킹, 우선순위 기반 랜더링,
스케쥴링, 중단과 같은 메커니즘을 담아냈습니다. 기저에 있는 아키텍처를 수정해야
했던 만큼 5년이라는 시간동안 많은 시행착오를 겪었을 텐데요.&lt;/p&gt;
&lt;p&gt;이 시리즈는 &lt;em&gt;‘도대체, 동시성이 무엇이길래 리엑트팀에서 5년이라는
시간을 쏟았으며, 동시성을 위한 메커니즘들의 구현체들이 어떻게 구현되어 있을까?
’&lt;/em&gt; 라는 호기심에 찾아본 구현체들과 레퍼런스들을 차근차근 정리해보고자 합니다.&lt;/p&gt;
&lt;p&gt;그 첫 번째로, &lt;a href=&quot;https://deview.kr/2021/sessions/518&quot;&gt;Inside React (동시성을 구현하는 기술)&lt;/a&gt;에서 언급한 내용들을 정리하고, 우선순위와 양보 매커니즘이
어떻게 구현되어 있는 지 살펴보려 합니다.&lt;/p&gt;
&lt;h2 id=&quot;concurrent-vs-parallelism&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#concurrent-vs-parallelism&quot; aria-label=&quot;concurrent vs parallelism permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Concurrent vs Parallelism&lt;/h2&gt;
&lt;p&gt;동시성을 설명할 때, 서로 관련있는 병렬성과 함께 설명하곤 합니다.
하지만, 이 둘은 뚜렷한 차이를 가지고 있으며
Go 언어의 창시자의 &lt;a href=&quot;https://go.dev/blog/waza-talk&quot;&gt;Concurrency is not parallelism&lt;/a&gt;
발표 서문에는 다음과 같이 동시성과 병렬성을 비교합니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;’&lt;strong&gt;동시성은 독립적으로 실행되는 프로세스들의 조합이다.&lt;/strong&gt;’
‘병렬성은 연관된 복수의 연산들을 동시에 실행하는 것이다.’
’&lt;strong&gt;동시성은 여러 일을 한꺼번에 다루는 문제에 관한 것이다.&lt;/strong&gt;’
‘병렬성은 여러 일을 한꺼번에 실행하는 방법에 관한 것이다.’&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;아주 멜랑꼴리한데 발표에서 언급한 문구를 빌려 정리하자면,
&lt;strong&gt;동시성은 프로세서가 하나만 있는 경우, 병렬 처리를 가능케 하지만 병렬처리는 아닙니다.&lt;/strong&gt;
즉, 하나의 스레드로 작업을 순차적으로 처리하지만,
마치 여러 개의 스레드가 사용되고 있는 것처럼 보이게 하는 것이고,
동시성은 싱글 코어에서도 동작하지만, 병렬성은 두 개 이상의 코어가 필요합니다.&lt;/p&gt;
&lt;p&gt;병렬성은 예를 들어 GPU를 통해 이미지를 랜더링할 때 R, G, B를 연산하는
텍스크를 각각의 코어가 작업하는 것과 같이 최소 한 가지 논리적 통제를
멀티 코어에서 병렬적으로 진행합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 864px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDklEQVQoz4WT246EIAyGff+n27kxJl55tc66oiConPynJetmouI0aYDSfm1TKLZtAwuvOd0ld/fuUxwNVxJjzPoc7UUy/BmXZUFd13h8PdA0DUIICeacg7U2+WitUVUVyrJE3/f5Cj0FGSmhpgliFJC0N4vFRGcGsu7VruuKYRj+k5yAgZ0ocyRloDQyAbWNmKlqDnwH7mfv/Q1wnhGMISBBjSLgiNkRkOxHIFfIeg+kinzXoRM9WvENIQR+tcMoFcHOQEPJsy1zJq0UPLXXti20mfB8/sD6SJWqFLgHM5AHw5oF8pR1aneC0bQSnCvglYN42nt7LDwovmP4CfjpDd69uct3+OmXXP2Ku5/yAo1jYOU3Q/GkAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Parallel task processing&quot;
        title=&quot;Parallel task processing&quot;
        src=&quot;/static/e2d146e61c5b9a19bb4476de300b308a/9cab2/parallelism-process.png&quot;
        srcset=&quot;/static/e2d146e61c5b9a19bb4476de300b308a/5a46d/parallelism-process.png 300w,
/static/e2d146e61c5b9a19bb4476de300b308a/0a47e/parallelism-process.png 600w,
/static/e2d146e61c5b9a19bb4476de300b308a/9cab2/parallelism-process.png 864w&quot;
        sizes=&quot;(max-width: 864px) 100vw, 864px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;반면 동시성은 최소 두 개의 논리적 통제 흐름을 가지고 있으며,
잘개 쪼개진 두 개 이상의 작업을 지속적으로 컨텍스트 스위칭하여
마치 동시에 이루어지는 것처럼 보이도록 합니다.
강의를 듣다가 내용 정리를 위해 일시정지하고 메모하는 것과 같은 작업 처리 방식입니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 864px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABPklEQVQoz4WT226DMAyGef/n603RuotWEy3jsJxIQgj/bG8w2rHVkhUl2J9/O6SY5xlsvP7li+3Fbs/ZiseDPcs5i+/FPsKL7cb7gNPphMPhgMvlgmmaBDSOI2KMEmOtRVmWOB5LdF33C74qnCjJKQVDCf1HD60VhhBlvwVyaU9x71WFwXv5FkKQ4mvLE6mIziFTMgOUUwTUsDGTai8wTlzMtg3O5xcoimnbFk3TCHQFcluREieCGkvuNAUr+DGLii2QpxOcpYI9qcrSHeevM/xSOCNQtUSVm77DrbvKfFo7ioo7IPmgepzfXuks7c8wpQRnDBLJvtU3WFJQ1zXGlEmJEeAyQ75rc62gqXhM6e6m11tmc9SuJqispGoYBmgaPoN44Cn9qDHfsXu/UvHsH3xs6dlZ8eyV7L2K/17KJ+0UX3E77Ee7AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Concurrent task processing&quot;
        title=&quot;Concurrent task processing&quot;
        src=&quot;/static/1c01ef1b6acac66076081b5b3e947f91/9cab2/concurrent-process.png&quot;
        srcset=&quot;/static/1c01ef1b6acac66076081b5b3e947f91/5a46d/concurrent-process.png 300w,
/static/1c01ef1b6acac66076081b5b3e947f91/0a47e/concurrent-process.png 600w,
/static/1c01ef1b6acac66076081b5b3e947f91/9cab2/concurrent-process.png 864w&quot;
        sizes=&quot;(max-width: 864px) 100vw, 864px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;리엑트팀은-왜-동시성-기능을-구현하고자-했을까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A6%AC%EC%97%91%ED%8A%B8%ED%8C%80%EC%9D%80-%EC%99%9C-%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B8%B0%EB%8A%A5%EC%9D%84-%EA%B5%AC%ED%98%84%ED%95%98%EA%B3%A0%EC%9E%90-%ED%96%88%EC%9D%84%EA%B9%8C&quot; aria-label=&quot;리엑트팀은 왜 동시성 기능을 구현하고자 했을까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;리엑트팀은 왜 동시성 기능을 구현하고자 했을까&lt;/h2&gt;
&lt;p&gt;리엑트는 사용자 인터페이스를 구축하는 라이브러리로서 핵심 역할인 인터렉션에
대한 업데이트 과정과 사용자 경험에 대한 HCI 연구 결과를 반영하고 궁극적으로
기술적으로 결합하는 목표를 가지고 있습니다. 사람과 컴퓨터간의 인터렉션에
대한 연구 결과들을 추상화해서 리엑트 코어의 개선 목표로 삼고 이를
구현합니다.&lt;/p&gt;
&lt;p&gt;가령, 화면 간 전환에서 로딩 중 상태를 너무 많이 표시하면 UX 품질이
낮아지는 문제라던지, 빠르게 처리되기를 기대하는 상호작용들과 느려도 문제없는
상호작용을 구분짓고 이를 적용해서 효과적으로 사용자 인터페이스에 구현할 수 있는
방법들을 제공하기 위함입니다.&lt;/p&gt;
&lt;p&gt;조금 더 와닿을 수 있게 우리의 구현체들이 동작하는 브라우저 환경에서
생각해봅시다. 브라우저는 HTML을 파싱하고, 자바스크립트를 실행하며
랜더트리를 구축하고 그려내는 작업까지 단일 스레드로서 한번에 하나의
작업만을 수행합니다.&lt;/p&gt;
&lt;p&gt;때문에 메인 스레드가 자바스크립트 엔진에게 실행권을 위임하여
자바스크립트 파싱을 시작했다면 그 작업을 멈출 수 없으며,
작업이 완료될 때까지 이후의 작업을 전개할 수 없습니다.
리엑트 랜더링 연산 과정도 동일한 절차를 거치게 되며,
이 때 매우 무거운 랜더링 연산 과정이 시작되면 이후의 작업들이 다소
긴 시간 동안 대기 상태가 되는 블로킹 랜더링이 발생합니다.&lt;/p&gt;
&lt;p&gt;재조정을 위한 리엑트의 비교 알고리즘은 매우 최적화되어 있어
블로킹되는 이슈가 자주 발생하지 않아 공감하기 어려울 수 있지만,
&lt;a href=&quot;https://ajaxlab.github.io/deview2021/blocking&quot;&gt;deview2021/blocking&lt;/a&gt;
데모처럼 입력값에 대한 픽셀 박스를 랜더링하는 연산이 무거워짐에 따라
keypress 이벤트에 대한 처리가 지연되고 있음을 경고 플래그를 통해 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACTElEQVQoz1WS23KbSBRF+f9fmoepzFQsc2ua5tJgkGSQZMeWsaILICTFKyeZB0+6atepPnVYvXvTDr/Xx6c+Pv7r9APD3y7nKOfsGSZTMsUF4xcPrlc+v/tzOT8EcP3Bn5K5y3RjXD4xti+MqxeG+Ya+/capXnM+X5lkaJLh/+sXy3k/XdHlmrho0PaRuGyJpKp8iapXRL9UrchXW7oJtmd4PV55PXxqK4zN7kInfWecPng/9Lztj2x3Pbv9QCe1k97++8j7buRtd6L7LvvxQj9cOA03TqeJYTxzPN0YDrIfrgyXG875fKTe5CxEZZMxLxZslnPaxSPZfIG1lqJJabOM2l+wrmMaW5DZmqrOycuKuqgwjym95O507wd0HFBmCfe5S5TG5KnBVQWRiglmLjry8TOfJA7JIoU/M6TGJzIeQRBjZE7fx/T7HuftuCe3OUWuSNMU1yTUekaqE4zVqDBk7ibYoJCc70n9hCBKSJTBxgIzmlhgkefRTyNOf3zDpBqbKAqps9yQFx5rk2MzceBrSqXJvsYkdyEq0b8PKHVJVoX49h6jNbrwOQ57nN1hhxLQv6VHbP+RTDwygSV+SWUzwmSGTnzcICDNxZmdiduEWJXYIsIkC9RDLJF5TIejPJv9HiUAJZYDHRD5dyJNII6zuzsBu3wJ/8I3LkqFeDNFEn0ltZHkJ449ObDyJaJQXsBBrnw6UMsffWoanpcp63VD0T5hmw2r+ZJNW1K/VMwXDzRVzUPxjVW7Zfv8KnVFu1ny3HV0r2tu1ws/Add8Hro2DvjMAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Example of blocking rendering&quot;
        title=&quot;Example of blocking rendering&quot;
        src=&quot;/static/219e96397b3d85a667ab72d28b32c3da/c1b63/blocking-rendering-example.png&quot;
        srcset=&quot;/static/219e96397b3d85a667ab72d28b32c3da/5a46d/blocking-rendering-example.png 300w,
/static/219e96397b3d85a667ab72d28b32c3da/0a47e/blocking-rendering-example.png 600w,
/static/219e96397b3d85a667ab72d28b32c3da/c1b63/blocking-rendering-example.png 1200w,
/static/219e96397b3d85a667ab72d28b32c3da/d8817/blocking-rendering-example.png 1238w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 43.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABzUlEQVQoz23QS4sTQRiF4fxOF4JLde9/EAZxp6ILN64CLkRBRAQhDmOc3Bwm104l6e50Ll3VnaruzJhbv1YnIyPRxUdxPoqHU1Xw/IDJdI7r+ojBCCGG9hziemN6jthP3+60SdFSkZiEdOiSCIGx+4XTR41cIsdB9vsUlosAIwU68khjHx32iIMGy3SB8r7ZS+9YTKqocZnp2UvC3idk8YRp8Snh60fMn9xh9uwewYv7jF89oJDEEhPNSOJ85ui5TxS4LBOD9k6JB18w00vMpEHcKWL8EovmG8aNz4SV56j3D9Fv7xJ8eMzk44kF7VMSbZ+hNWmSEkuNmmmurjcoC0t/xEJGxHNFIGwOxkxFl2FzhN9uMqifIqpfcc4rOJW6BdMMk2TkZ7rcEUUZSu5YXmfMpjtmE5tVhgwzRuKQXZHRa25x2nBxDrUytEou7dLoACY5uLTg1Y44sqg6gPPZdj+R3Sm5xRus99kfbui3Vwy6a5q1X1z82NCphnRr4VHDG1CpPw1zcLcHpW3tDTb77A1tu9baghsuq2t+llcWXtOqr/8PRseg+hfst4/B1QE0JkNri5ocvWkob8H8H/cNw539u1tQdP4Cvx/AvOVv0WaXBF6Q6ToAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Delay in processing tasks for keypress&quot;
        title=&quot;Delay in processing tasks for keypress&quot;
        src=&quot;/static/815e3dae1953dd73e6539b5104895244/c1b63/blocking-rendering-performance.png&quot;
        srcset=&quot;/static/815e3dae1953dd73e6539b5104895244/5a46d/blocking-rendering-performance.png 300w,
/static/815e3dae1953dd73e6539b5104895244/0a47e/blocking-rendering-performance.png 600w,
/static/815e3dae1953dd73e6539b5104895244/c1b63/blocking-rendering-performance.png 1200w,
/static/815e3dae1953dd73e6539b5104895244/2eb79/blocking-rendering-performance.png 1256w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;경고 플래그 중 하나의 예시로 keypress 이벤트를 처리하는 데 143.41ms이 소요 되었는데
&lt;a href=&quot;https://web.dev/rail/?utm_source=devtools#goals-and-guidelines&quot;&gt;RAIL&lt;/a&gt;
모델을 기반으로 생각한다면, 사용자는 입력 이벤트에 대해 100ms 이상 소요되는 것을
동작과 응답 사이의 연결이 지연되고 있음을 인식하게 되며, 이는 사용자 경험의 감점으로
이어질 수 있습니다.&lt;/p&gt;
&lt;p&gt;리엑트는 이러한 사용자 경험에 영향을 끼치는 랜더링 업데이트 과정에서
동시성을 통해 개선된 인터렉션을 쉽게 구현할 수 있도록 하는 구현체를 제공하고자
했습니다.&lt;/p&gt;
&lt;h2 id=&quot;동시성-메커니즘-우선순위&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84&quot; aria-label=&quot;동시성 메커니즘 우선순위 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;동시성 메커니즘; 우선순위&lt;/h2&gt;
&lt;p&gt;리엑트에서 동시성을 구현하는 첫번 째 메커니즘은 바로 우선순위입니다. 인터렉션에 의해
발생한 이벤트와 업데이트 작업들이 어떻게 우선순위는 어떻게 결정되고 할당되는 지
궁금했는데요. 그 과정에 대해 차근차근 살펴봅시다.&lt;/p&gt;
&lt;p&gt;우선순위 메커니즘은 사용자 인터렉션 발생을 캐치한 리스너에서부터
작업 생성 과정과 스케쥴링 단계까지 업데이트를 위한
작업의 우선순위를 할당하기 위한 전반적인 과정에서 쉽게 찾아볼 수 있습니다.&lt;/p&gt;
&lt;p&gt;그 이후 진행 중인 작업이 우선 순위가 높은 대기 상태의 작업에 의해 중단되거나,
같은 우선 순위를 가진 작업에 대해서 일괄 처리될 수 있도록 하는 작업 교통정리
를 하는 작업 실행 단계에서도 확인할 수 있는데요.&lt;/p&gt;
&lt;p&gt;한편, 리엑트v17.0 이전에서는 작업의 &lt;a href=&quot;https://github.com/facebook/react/blob/v16.12.0/packages/react-reconciler/src/ReactFiberExpirationTime.js&quot;&gt;만료 시간을 기준으로 우선순위를 부여&lt;/a&gt;하는 메커니즘으로 구현되어 있었습니다.
반면, 리엑트v17.0 이후에서는 Lane 모델을 착안하여 비트 연산을
기반으로 우선 순위를 부여하는 방식으로 변경되었는데요.
먼저, 전반적인 우선순위 메커니즘 기저의 구현체인 Lane을 살펴봅시다.&lt;/p&gt;
&lt;h3 id=&quot;lane-모델-그리고-lane-우선순위&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#lane-%EB%AA%A8%EB%8D%B8-%EA%B7%B8%EB%A6%AC%EA%B3%A0-lane-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84&quot; aria-label=&quot;lane 모델 그리고 lane 우선순위 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Lane 모델, 그리고 Lane 우선순위&lt;/h3&gt;
&lt;p&gt;Lane 모델은 도로의 차선을 모티브로 하여 리엑트에서 우선순위를
표현하기 위해 구현된 31비트 데이터로 표현된 비트맵입니다.
작업의 스케쥴링 및 조정 작업 과정의 우선순위를 가진 고유의 작업 스레드를
표현합니다.&lt;/p&gt;
&lt;p&gt;실제 레인의 구현에서 확인할 수 있듯, 기본적으로 더 작은 숫자로 표현된
레인이 높은 우선순위를 갖습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-reconciler/src/ReactFiberLane.new.js

export type Lanes = number;
export type Lane = number;
export type LaneMap&amp;lt;T&amp;gt; = Array&amp;lt;T&amp;gt;;

export const TotalLanes = 31;

export const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;
export const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;
export const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;
export const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000010;
export const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000000100;
export const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000001000;
export const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000010000;
const TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000000100000;
const TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111111000000;
const TransitionLane1: Lane = /*                        */ 0b0000000000000000000000001000000;
...
const RetryLanes: Lanes = /*                            */ 0b0000111110000000000000000000000;
const RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;
...

export const SomeRetryLane: Lane = RetryLane1;
export const SelectiveHydrationLane: Lane = /*          */ 0b0001000000000000000000000000000;
const NonIdleLanes: Lanes = /*                          */ 0b0001111111111111111111111111111;
export const IdleHydrationLane: Lane = /*               */ 0b0010000000000000000000000000000;
export const IdleLane: Lane = /*                        */ 0b0100000000000000000000000000000;
export const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;Lane 모델은 우선순위를 두 가지 중요한 컨셉으로 분리합니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Task Prioritization, A 작업이 B 작업보다 급한가?&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;Task Batching, A 작업이 이 그룹 텍스크에 속하는 가?&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;작업 우선순위 개념을 통해 작업의 우선순위를 기준으로 작업의
우선 실행권을 부여하고, 작업 배칭 개념을 착안하여
가령 CPU, I/O, CPU 순의 작업 예약에 대해,
I/O 작업을 다른 그룹으로 분리하여 일괄 처리함으로서 CPU 작업의 병목을
방지할 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;CPU 작업이 I/O 작업보다 우선순위가 낮아 지속적인 양보가 발생하게 되면 CPU 작업처리에
진전이 없을 여지를 방지하기 위해 I/O 작업들을 묶어 진행할 수 있도록 하는 것은
리엑트v18에서 제공하는 &lt;a href=&quot;https://github.com/reactwg/react-18/discussions/21&quot;&gt;Automatic Batching&lt;/a&gt;
의 기저에 있는 동작 방식인듯 합니다. 깊이 있게 살펴볼 부분들이 차고 넘치네요.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Task Prioritization이 표현되는 각각의 레인이 가지고 있는
비트 값이 우선순위를 나타내고 있으며, 레인의 이름을 통해
어떠한 업데이트가 소유할 수 있는 레인인지 파악해볼 수 있습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;SyncLane&lt;/strong&gt;, 이산적인(discrete) 사용자 상호 작용에 대한 업데이트&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;InputContinuousLane&lt;/strong&gt;, 연속적인(continuous) 사용자 상호 작용에 대한 업데이트&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;DefaultLane&lt;/strong&gt;, setTimeout, 네트워크 요청 등에 의해 생성된 업데이트&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;&lt;strong&gt;TransitionLane&lt;/strong&gt;, Suspense, useTransition, useDefferredValue에 의해 생성된 업데이트&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;레인 모델이 어떻게 구현되어 있는 지 간단하게 살펴보았다면,
어떻게 적용되어 사용되는 지 확인해볼 차례입니다.
리엑트에서 Lane 모델을 기반으로 Lane 우선순위 개념을 이벤트 우선순위와
스케쥴러 우선순위에 녹여냈는 지 살펴봅시다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;레인에 대한 추가적인 내용은 초기 레인 모델을 구현한 &lt;a href=&quot;https://github.com/facebook/react/pull/18796&quot;&gt;react/pull/18796&lt;/a&gt;
PR을 참고하시면 좋습니다.&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;이벤트-우선순위&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84&quot; aria-label=&quot;이벤트 우선순위 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이벤트 우선순위&lt;/h3&gt;
&lt;p&gt;리엑트는 사용자 인터렉션에 의해 발생된 이벤트를 인위적으로 구분짓고,
구분된 이벤트를 묶어 우선순위를 결정짓습니다.
여기서, 크게 두 종류로 구분되어 루트에 바인딩될 때 어느 범주에 속한
이벤트인지에 따라 우선순위가 부여됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;이산적인 이벤트 (e.g. click, keydown, focusin, ..)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;연속적인 이벤트 (e.g. drag, pointermove, scroll, ..)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-reconciler/src/ReactEventPriority.new.js

export const DiscreteEventPriority: EventPriority = SyncLane;
export const ContinuousEventPriority: EventPriority = InputContinuousLane;
export const DefaultEventPriority: EventPriority = DefaultLane;
export const IdleEventPriority: EventPriority = IdleLane;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;잠시 이산적인 이벤트와 연속적인 이벤트를 구분짓는 이유를 생각해보자면,
가령 사용자가 문서를 읽다가, 문서에 참조되어 있는 링크를 클릭하는
이산적인 이벤트를 발생시켰다면 이는 즉각적으로 반응하기를 원할겁니다.&lt;/p&gt;
&lt;p&gt;반면 문서를 읽을 때 시선의 흐름에 따라 사용자가 포인터를 움직였다면,
이로 인해 발생한 연속적인 이벤트에 대해서는 사용자 입장에서 성능에 영향을
줄 것이라 생각하기 힘들고, 또한 빠르게 반응해주기를 원하는 이벤트라고
간주하기 어려울 수 있기 때문입니다.
관련해서 &lt;a href=&quot;https://wicg.github.io/is-input-pending/#continuous-events&quot;&gt;연속적인 이벤트(Continuous events)&lt;/a&gt;를 참고할 수 있습니다.&lt;/p&gt;
&lt;p&gt;다시 돌아와, 앞서 살펴보았던 31비트로 구성된 Lane 값들이 이벤트 우선순위
할당되는 값으로 사용되고 있으며, 각각의 이벤트에 대해 우선순위를 반환하는 함수가
구현되어 있는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-dom/src/events/ReactDOMEventListener.js

export function getEventPriority(domEventName: DOMEventName): * {
  switch (domEventName) {
    case &amp;#39;cancel&amp;#39;:
    case &amp;#39;click&amp;#39;:
    case &amp;#39;close&amp;#39;:
    case &amp;#39;contextmenu&amp;#39;:
    ...
      return DiscreteEventPriority;
    case &amp;#39;drag&amp;#39;:
    case &amp;#39;dragenter&amp;#39;:
    case &amp;#39;dragexit&amp;#39;:
    case &amp;#39;dragleave&amp;#39;:
    ...
      return ContinuousEventPriority;
    case &amp;#39;message&amp;#39;: {
      const schedulerPriority = getCurrentSchedulerPriorityLevel();
      switch (schedulerPriority) {
        case ImmediateSchedulerPriority:
          return DiscreteEventPriority;
        case UserBlockingSchedulerPriority:
          return ContinuousEventPriority;
        ...
      }
    }
    default:
      return DefaultEventPriority;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;em&gt;여기서 ‘message’ 이벤트는 따로 처리해주는 것을 확인할 수 있는데, 협력적 스케쥴링 모델을
사용하고, 정확한 스케쥴링 타임을 위해 리엑트 스케쥴러에서는 MessageChannel API를 기반으로
구현되어 있습니다. 따라서 ‘message’ 이벤트가 스케쥴러 콜백일 수 있기 때문에
‘message’ 이벤트에 대해서는 네이티브 스케쥴러에 대한 현재 우선 순위를 확인하여 반환합니다.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;getEventPriority()&lt;/code&gt; 를 따라 올라가다 보면, 대응되는 이벤트 우선순위를
각각의 이벤트 리스너에 래핑시키고, 우선순위가 래핑된 이벤트 리스너를 반환하는 곳에서
사용됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-dom/src/events/ReactDOMEventListener.js

export function createEventListenerWrapperWithPriority(
  targetContainer: EventTarget,
  domEventName: DOMEventName,
  eventSystemFlags: EventSystemFlags
): Function {
  const eventPriority = getEventPriority(domEventName);
  let listenerWrapper;
  switch (eventPriority) {
    case DiscreteEventPriority:
      listenerWrapper = dispatchDiscreteEvent;
      break;
    case ContinuousEventPriority:
      listenerWrapper = dispatchContinuousEvent;
      break;
    case DefaultEventPriority:
    default:
      listenerWrapper = dispatchEvent;
      break;
  }
  return listenerWrapper.bind(
    null,
    domEventName,
    eventSystemFlags,
    targetContainer
  );
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;결국 &lt;code class=&quot;language-text&quot;&gt;createRoot()&lt;/code&gt; 에서
리엑트17 이후 버전의 &lt;a href=&quot;https://ko.reactjs.org/blog/2020/08/10/react-v17-rc.html#changes-to-event-delegation&quot;&gt;이벤트 위임 메커니즘&lt;/a&gt;
에 입각하여, 우선 순위가 래핑된 이벤트 리스너들이 모두 루트에 바인딩되게 됩니다.&lt;/p&gt;
&lt;p&gt;이를 통해 사용자 상호 인터렉션에 따라 발생한 이벤트 우선순위는,
우선순위가 래핑된 이벤트 리스너를 통해 주입받을 수 있게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-dom/src/client/ReactDOMRoot.js

export function createRoot(
  container: Element | Document | DocumentFragment,
  options?: CreateRootOptions,
): RootType {
  ...
  const root = createContainer(
    ...
  );
  markContainerAsRoot(root.current, container);

  const rootContainerElement: Document | Element | DocumentFragment =
    container.nodeType === COMMENT_NODE
      ? (container.parentNode: any)
      : container;
  listenToAllSupportedEvents(rootContainerElement); //**

  return new ReactDOMRoot(root);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;스케쥴링-우선순위&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%8A%A4%EC%BC%80%EC%A5%B4%EB%A7%81-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84&quot; aria-label=&quot;스케쥴링 우선순위 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;스케쥴링 우선순위&lt;/h3&gt;
&lt;p&gt;스케쥴링 우선순위는 스케쥴러 기반의 리엑트 업데이트 작업이 가지는
우선순위입니다. 스케쥴러는 스케쥴링 우선순위를 통해 산발적으로
발생하는 작업들의 교통정리를 진행합니다.&lt;/p&gt;
&lt;p&gt;가령 이벤트가 발생하여 setState를 통해 부가적인 상태 업데이트가
디스패치되면, 리콘실러는 업데이트 작업의 정보를 담은 객체를 생성하여
스케쥴러에게 전달하게 되는데, 업데이트 객체를 생성하는 단계에서
작업의 스케쥴링 우선순위를 구하기 위한 단계가 포함됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-reconciler/src/ReactFiberHooks.new.js

function dispatchSetState&amp;lt;S, A&amp;gt;(
  fiber: Fiber,
  queue: UpdateQueue&amp;lt;S, A&amp;gt;,
  action: A,
) {
  ...

  const lane = requestUpdateLane(fiber);

  const update: Update&amp;lt;S, A&amp;gt; = {
    lane,
    action,
    hasEagerState: false,
    eagerState: null,
    next: (null: any),
  };

  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;업데이트 객체에 전달되는 우선순위를 구하는 &lt;code class=&quot;language-text&quot;&gt;requestUpdateLane()&lt;/code&gt;
는 어떻게 이벤트 우선순위를 얻어오는 지 살펴봅시다.&lt;/p&gt;
&lt;h3 id=&quot;requestupdatelane&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#requestupdatelane&quot; aria-label=&quot;requestupdatelane permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;requestUpdateLane&lt;/h3&gt;
&lt;p&gt;리엑트는 동시성 기능을 담은 모드와 기존 레거시 모드를 함께 제공하고
있기 때문에, 먼저 동시성 기능이 제공되는 모드인지 확인하는 과정을
거칩니다. 만약 아니라면, 우선순위가 가장 높은 &lt;code class=&quot;language-text&quot;&gt;SyncLane&lt;/code&gt;을 반환합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function requestUpdateLane(fiber: Fiber): Lane {
  const mode = fiber.mode;
  if ((mode &amp;amp; ConcurrentMode) === NoMode) {
    return (SyncLane: Lane);
  }
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;한편 동시성 기능을 제공하는 모드라면, 먼저 현재 실행 중인 작업이 있는 지
확인합니다. 만약 있다면, 현재 실행 중인 작업의 레인이 직접 반환되고,
새 작업이 기존 작업과 같은 우선순위를 부여받게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let workInProgressRootRenderLanes: Lanes = NoLanes;

export function requestUpdateLane(fiber: Fiber): Lane {
  ...
  else if (
    !deferRenderPhaseUpdateToNextBatch &amp;amp;&amp;amp;
    (executionContext &amp;amp; RenderContext) !== NoContext &amp;amp;&amp;amp;
    workInProgressRootRenderLanes !== NoLanes
  ) {
    return pickArbitraryLane(workInProgressRootRenderLanes);
  }
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-reconciler/src/ReactFiberLane.new.js

export function getHighestPriorityLane(lanes: Lanes): Lane {
  return lanes &amp;amp; -lanes;
}

export function pickArbitraryLane(lanes: Lanes): Lane {
  return getHighestPriorityLane(lanes);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위 조건에 포함되지 않았다면, 이제 현재 이벤트가 전환 우선 순위인지에 대한
여부를 결정하고 맞다면 적절한 전환 우선순위에 할당하게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let currentEventTransitionLane: Lanes = NoLanes;

export function requestUpdateLane(fiber: Fiber): Lane {
  ...
  const isTransition = requestCurrentTransition() !== NoTransition;
  if (isTransition) {
    if (__DEV__ &amp;amp;&amp;amp; ReactCurrentBatchConfig.transition !== null) {
      const transition = ReactCurrentBatchConfig.transition;
      if (!transition._updatedFibers) {
        transition._updatedFibers = new Set();
      }

      transition._updatedFibers.add(fiber);
    }
    if (currentEventTransitionLane === NoLane) {
      currentEventTransitionLane = claimNextTransitionLane();
    }
    return currentEventTransitionLane;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-reconciler/src/ReactFiberLane.new.js

export function claimNextTransitionLane(): Lane {
  const lane = nextTransitionLane;
  nextTransitionLane &amp;lt;&amp;lt;= 1;
  if ((nextTransitionLane &amp;amp; TransitionLanes) === NoLanes) {
    nextTransitionLane = TransitionLane1;
  }
  return lane;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이 때, 생성된 작업에 대해 맨 오른쪽 비트를 소유하는 &lt;code class=&quot;language-text&quot;&gt;TransitionLane&lt;/code&gt;을
할당하고, 그 이후에 생성된 전환 작업은 비트가 왼쪽으로 한 자리 이동한
레인 즉, 우선순위가 보다 낮은 &lt;code class=&quot;language-text&quot;&gt;TransitionLane&lt;/code&gt;이 할당합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;TransitionLane1 = 0b0000000000000000000000001000000;
TransitionLane2 = 0b0000000000000000000000010000000;
...

TransitionLanes = 0b0000000001111111111111111000000;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;전환 우선순위 작업이 아닌 경우에는 어떻게 처리될까요? 이벤트 우선순위 섹션에서
우선순위가 래핑된 이벤트 리스너가 모두 루트에 바인딩되는 걸 확인했었는데요.
여기서 이벤트가 발생하면 &lt;code class=&quot;language-text&quot;&gt;getCurrentUpdatePriority()&lt;/code&gt;가 호출되어
현재 이벤트 우선순위가 반환되어 스케쥴링 우선순위로 사용됩니다.&lt;/p&gt;
&lt;p&gt;만약 현재 이벤트 우선순위가 비어있다면 동일하게 &lt;code class=&quot;language-text&quot;&gt;getCurrentUpdatePriority()&lt;/code&gt;
에서 외부 이벤트의 우선순위를 가져옵니다. 이런 케이스는 가령, &lt;code class=&quot;language-text&quot;&gt;setState&lt;/code&gt;가
&lt;code class=&quot;language-text&quot;&gt;setTimeout&lt;/code&gt;에서 호출된 케이스입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function requestUpdateLane(fiber: Fiber): Lane {
  ...
  const updateLane: Lane = (getCurrentUpdatePriority(): any);
  if (updateLane !== NoLane) {
    return updateLane;
  }

  const eventLane: Lane = (getCurrentEventPriority(): any);
  return eventLane;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;결과적으로 얻어진 스케쥴링 우선순위는 업데이트 객체에 할당됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function createUpdate(eventTime: number, lane: Lane): Update&amp;lt;*&amp;gt; {
  const update: Update&amp;lt;*&amp;gt; = {
    eventTime,
    lane,

    tag: UpdateState,
    payload: null,
    callback: null,

    next: null,
  };
  return update;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다음으로 업데이트해야 하는 컨텐츠와 업데이트 콜백 함수를
담아 업데이트 객체를 완성하게 되고, 현재 컴포넌트에 해당하는
Fiber 노드의 업데이트 대기열에 업데이트 객체가 추가됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;update.payload = payload;
if (callback !== undefined &amp;amp;&amp;amp; callback !== null) {
  update.callback = callback;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;enqueueUpdate(fiber, update, lane);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위와 같은 과정들을 통해 리엑트는 Lane 모델을 기반으로 우선순위
메커니즘을 구현하고 실제 이벤트의 발생과 작업 생성 단계에서
어떻게 적절한 우선순위를 할당하는 지 그 과정을 살펴보았습니다.&lt;/p&gt;
&lt;h2 id=&quot;동시성-메커니즘-양보&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98-%EC%96%91%EB%B3%B4&quot; aria-label=&quot;동시성 메커니즘 양보 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;동시성 메커니즘; 양보&lt;/h2&gt;
&lt;p&gt;각각의 작업에 대해 우선순위가 어떻게 할당되는 지 확인했다면,
이제 우선순위를 기준으로 현재 진행 중인 작업이 점유하고 있는
메인 스레드가 대기 중인 높은 작업에 의해 중단되고 메인 스레드의 점유를
양보하는 지 알아봅시다.&lt;/p&gt;
&lt;p&gt;브라우저는 랜더링 엔진에게 메인 스레드 점유를 위임하게 되면,
랜더링 과정 중 발생한 사용자 입력에 대해 즉시 처리할 수 없게 되기 때문에
사용자가 즉각적으로 반응하고 처리되기를 기대하는 이벤트에 대해
랜더링 작업 중에는 처리할 수 없게 되는데요.&lt;/p&gt;
&lt;p&gt;리엑트는 이러한 근본적인 원인을 해결하고자 모든 랜더링을 인터럽트 가능하도록 하여
우선순위가 높은 작업이 텍스크 스택에 들어오면 진행중이던 작업을 중단하고 메인 스레드에게
점유를 양보할 수 있는 메커니즘을 구현하게 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA1UlEQVQoz42S6wqDMAyF+/5PuMl+uckG1mpbe/F6ZgtK0VY9UAJJ+DhJSrDTPM9bDF9Yj9XWSO5AwlpMYZ7Ekk7TNCHLMjyeT+R5vvUMDUNb/lDVNRhjGMfx3GHXdej7Hv0wwLQtaPFBxWqfm5a6tALSSAghoJQ6uCd7d67JWuuBWkiU3xyMNzDaeNexcQ8jhw6llNBawy5OVcNRvF+gbszF7QqMHeTyKE5ufK44uOA46wt1CnSurLF+X/u+lMjZThyQUgpjzSUoCUx9ozuwJDC1gjvQP0YgZVDyZo+xAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;When the user&amp;#39;s input comes in, rendering is interrupted&quot;
        title=&quot;When the user&amp;#39;s input comes in, rendering is interrupted&quot;
        src=&quot;/static/e2ceddd26691f38b0dec421c08a40c58/c1b63/interruption-and-yield.png&quot;
        srcset=&quot;/static/e2ceddd26691f38b0dec421c08a40c58/5a46d/interruption-and-yield.png 300w,
/static/e2ceddd26691f38b0dec421c08a40c58/0a47e/interruption-and-yield.png 600w,
/static/e2ceddd26691f38b0dec421c08a40c58/c1b63/interruption-and-yield.png 1200w,
/static/e2ceddd26691f38b0dec421c08a40c58/d61c2/interruption-and-yield.png 1800w,
/static/e2ceddd26691f38b0dec421c08a40c58/97a96/interruption-and-yield.png 2400w,
/static/e2ceddd26691f38b0dec421c08a40c58/5fe07/interruption-and-yield.png 3422w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;하지만 메인스레드를 양보하기 이전에, 메인 스레드를 점유하여 랜더링 연산을
전개하고 있는 과정에서 사용자의 입력에 대한 처리가 대기 중임을 확인하고
메인 스레드 점유를 양보해야 하는 지에 대해 판단하는 것이 더 우선적으로
가능해야 했습니다.&lt;/p&gt;
&lt;p&gt;이를 위해 페이스북은 메인스레드를 점유당하고 있는 상황에서 우선순위가 높은 작업이
대기 중임을 확인하는 구현체인 &lt;a href=&quot;https://wicg.github.io/is-input-pending/&quot;&gt;isInputPending&lt;/a&gt;
를 브라우저 API에 처음으로 기여하게 됩니다.&lt;/p&gt;
&lt;p&gt;실제로 리엑트의 &lt;a href=&quot;https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js&quot;&gt;스케쥴러&lt;/a&gt; 에는
&lt;code class=&quot;language-text&quot;&gt;isInputPending&lt;/code&gt;을 사용하기 위해 호스트 환경에 의존적인 API를 사용할 수 있는 지에
대해 판단하는 플래그들이 존재합니다.&lt;/p&gt;
&lt;h3 id=&quot;shouldyieldtohost&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#shouldyieldtohost&quot; aria-label=&quot;shouldyieldtohost permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;shouldYieldToHost&lt;/h3&gt;
&lt;p&gt;이제 랜더링 과정에서 우선순위가 높은 작업이 대기 중임을 확인할 수 있는 구현체를
사용해서 내부적으로 어떻게 양보가 이루어질 수 있도록 구현되어 있는 지 확인해봅시다.&lt;/p&gt;
&lt;p&gt;양보가 필요한 상황인지를 판단하기 위한 첫 검증은 현재 작업을
처리하기 위해 얼마만큼의 시간을 소요했는 지를 확인합니다.
경과된 시간이 &lt;code class=&quot;language-text&quot;&gt;frameInterval&lt;/code&gt; 값보다 작다면, 메인 스레드는 단일 프레임만큼
아주 짧은 시간동안만 차단되어 있었기 때문에 양보를 거절합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// SchedulerFeatureFlags.js

export const frameYieldMs = 5;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { frameYieldMs } from &amp;#39;../SchedulerFeatureFlags&amp;#39;;

let frameInterval = frameYieldMs;

function shouldYieldToHost() {
  const timeElapsed = getCurrentTime() - startTime;

  if (timeElapsed &amp;lt; frameInterval) {
    return false;
  }
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이후의 스코프에서는 메인 스레드가 무시할 수 없는 시간 동안 차단되었을 때
대기 중인 페인트 혹은 사용자 입력 작업이 존재한다면,
브라우저가 높은 우선 순위 작업을 수행할 수 있도록 메인 스레드에
대한 점유를 양보합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let needsPaint = false;

function requestPaint() {
  if (
    enableIsInputPending &amp;amp;&amp;amp;
    navigator !== undefined &amp;amp;&amp;amp;
    navigator.scheduling !== undefined &amp;amp;&amp;amp;
    navigator.scheduling.isInputPending !== undefined
  ) {
    needsPaint = true;
  }
}

function shouldYieldToHost() {
  ...
  if (enableIsInputPending) {
    if (needsPaint) {
      return true;
    }
  }
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기서 &lt;code class=&quot;language-text&quot;&gt;requestPaints()&lt;/code&gt; 는 isInputPending API를 사용할 수 있는 지,
사용할 수 있다면 현재 사용자 입력에 대한 페인트 작업이 대기 중인지를 판단하여
&lt;code class=&quot;language-text&quot;&gt;needsPaint&lt;/code&gt; 플래그를 반환하게 역할을 하는데요.&lt;/p&gt;
&lt;p&gt;이를 통해 리콘실러는 VDOM의 변경사항을 DOM에 모두 커밋하고
&lt;code class=&quot;language-text&quot;&gt;requestPaints()&lt;/code&gt;를 호출하여 페인트 작업이 필요하다는 것을 스케쥴러에게 전달할 수 있게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// ReactFiberWorkLoop.new.js

import { requestPaint } from &amp;#39;./Scheduler&amp;#39;;

function commitRootImpl(...) {
  ...
  requestPaint();
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;다음으로는 경과된 시간이 연속적인 입력 인터벌보다 짧은 지 검증합니다.
&lt;a href=&quot;#%EC%9D%B4%EB%B2%A4%ED%8A%B8-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84&quot;&gt;이벤트 우선순위&lt;/a&gt;에서 이산적, 연속적인 이벤트를 구분짓는 같은 맥락으로,
isInputPending은 단순히 모든 사용자 이벤트를 동일하게 처리하지 않고,
&lt;a href=&quot;https://wicg.github.io/is-input-pending/#continuous-events&quot;&gt;연속적인 이벤트&lt;/a&gt; (e.g. click)와 이산적인 이벤트 (e.g. mouseover)를 구분지어
&lt;strong&gt;연속적인 이벤트에 대해 양보가 너무 자주 발생하게 되는 것을 방지합니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;즉 이 검증 단계에서는, 연속적인 이벤트에 대한 처리 작업을 즉시 시작하지 않을 간격을 두고,
그 시간 동안에는 판단을 온전히 브라우저에게 맡깁니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// SchedulerFeatureFlags.js

export const continuousYieldMs = 50;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { continuousYieldMs } from &amp;#39;../SchedulerFeatureFlags&amp;#39;

const continuousInputInterval = continuousYieldMs;

const isInputPending =
  typeof navigator !== &amp;#39;undefined&amp;#39; &amp;amp;&amp;amp;
  navigator.scheduling !== undefined &amp;amp;&amp;amp;
  navigator.scheduling.isInputPending !== undefined
    ? navigator.scheduling.isInputPending.bind(navigator.scheduling)
    : null;

function shouldYieldToHost() {
  ...
  if (timeElapsed &amp;lt; continuousInputInterval) {
    if (isInputPending !== null) {
      return isInputPending();
    }
  }
  ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;마지막으로 최대 간격 이내에 보류 중인 연속적이거나, 이산적인 모든 이벤트에 대해
양보합니다. 이후 모든 분기 처리가 담지 못한 케이스에 대해서는,
보류 중인 입력이 없더라도 네트워크 이벤트와 같은 외부 이벤트에 의한 작업들이
대기 중일 수 있다는 가정하에 무조건적으로 양보하게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// SchedulerFeatureFlags.js

export const maxYieldMs = 300;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import { maxYieldMs } from &amp;#39;../SchedulerFeatureFlags&amp;#39;

function shouldYieldToHost() {
    ...
    else if (timeElapsed &amp;lt; maxInterval) {
      // Yield if there&amp;#39;s either a pending discrete or continuous input.
      if (isInputPending !== null) {
        return isInputPending(continuousOptions);
      }
    } else {
      return true;
    }
  }

  return true;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;초기에 분기처리 되었던 호스트 환경에 의존적인 isInputPending API를
사용할 수 없는 경우 또한 무조건적으로 양보합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function shouldYieldToHost() {
  ...
  if (enableIsInputPending) {
    ...
  }

  return true;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;지금까지 알아본 &lt;code class=&quot;language-text&quot;&gt;shouldYieldToHost()&lt;/code&gt;는 스케쥴러의 &lt;code class=&quot;language-text&quot;&gt;workLoop()&lt;/code&gt;에서 사용됩니다. 현재 진행 중인 작업의 만료시간이 현재 시간에 비해 여유가 있는 시점에서
우선 순위가 더 높은 작업이 보류되고 있다면, 메인 스레드에게 제어권을 양보하고, 만료 시간이
지난 작업에 대해서는 양보하지 않고 동기적으로 바쁘게 작업을 이어나갑니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function workLoop(hasTimeRemaining, initialTime) {
  ...
  while (
    currentTask !== null &amp;amp;&amp;amp;
    !(enableSchedulerDebugging &amp;amp;&amp;amp; isSchedulerPaused)
  ) {
    if (
      currentTask.expirationTime &amp;gt; currentTime &amp;amp;&amp;amp;
      (!hasTimeRemaining || shouldYieldToHost())
    ) {
      break;
    }
  ...
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;추가적으로 스케쥴러가 아닌, 동시성 모드에서 컴포넌트를 재조정하는 작업이 담긴
&lt;code class=&quot;language-text&quot;&gt;workLoopConcurrent()&lt;/code&gt; 에서도 사용되는데요. &lt;code class=&quot;language-text&quot;&gt;shouldYieldToHost()&lt;/code&gt; 통해
진행되던 재조정 작업이 중지될 수 있음이 조건에 담겨있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// react-reconciler/src/ReactFiberWorkLoop.new.js

import { shouldYield } from &amp;#39;./Scheduler&amp;#39;;
function workLoopConcurrent() {
  while (workInProgress !== null &amp;amp;&amp;amp; !shouldYield()) {
    performUnitOfWork(workInProgress);
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이를 통해 리콘실러는 &lt;code class=&quot;language-text&quot;&gt;workLoopConcurrent()&lt;/code&gt;를 통해 현재 작업중이던 루트 혹은 Lane이
변경되면, 루트에 대기중인 작업들을 모두 비우고, 변경된 레인의 작업이 진행될 수 있도록 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function renderRootConcurrent(root: FiberRoot, lanes: Lanes) {
  const prevExecutionContext = executionContext;
  executionContext |= RenderContext;
  const prevDispatcher = pushDispatcher();

  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {
    ...
        const memoizedUpdaters = root.memoizedUpdaters;
        if (memoizedUpdaters.size &amp;gt; 0) {
          restorePendingUpdaters(root, workInProgressRootRenderLanes);
          memoizedUpdaters.clear();
        }

        movePendingFibersToMemoized(root, lanes);
      }
    }
  }
  ...

  do {
    try {
      workLoopConcurrent();
      ...
    }
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h3 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h3&gt;
&lt;p&gt;리엑트의 동시성 기능을 담은 구현체들을 살펴보았습니다. 이번 글에서는
전반적인 동시성 기능에 대한 서론과 우선순위가 어떻게 할당되는 지, 그리고
어떻게 메인스레드 점유가 양보되는 지에 대해 알아보았는데요.&lt;/p&gt;
&lt;p&gt;공부를 하면 할수록 사용자 인터페이스를 구축하는 기능을 제공하는 리엑트가
사용자 경험과 사용성 개선을 위해 고민하고 쉽게 구현할 수 있는 기능들을
제공하기 위해 얼마나 노력하는 지 느낄 수 있어 큰 자극을 얻을 수 있었습니다.&lt;/p&gt;
&lt;p&gt;한글로 정리된 글들이 많지 않아 다양한 레퍼런스들을 찾아보고, 흩어진 자료를
모아 정리하려는 목적으로 글을 정리해보았습니다. 직접 리엑트 구현체 코드들을
들여다보면서 어려움이 많았는데, 어설프게 정리하고 싶지 않아 생각보다 오랜 시간
끙끙댔던 시간이었는데요.
아직 살펴볼 내용들이 차고 넘치기 때문에 끊고 다음 글에서 이어서 정리하는
시간을 가지려 합니다.&lt;/p&gt;
&lt;p&gt;사실, 리엑트에서 제공하는 동시성 기능 API들을 어떻게 사용하는 지 알아보고
적절하게 사용을 즐기는 공부를 하면 마음 편하겠지만, 직접 구현체들의 내막을
들여다보고 나서 그 이해가 동시성 기능 API들을 사용할 때 보다 더 깊은
사용법을 이끌어낼 수 있지 않을까 하는 기대를 합니다.&lt;/p&gt;
&lt;p&gt;잘못된 설명이나, 얕은 지식으로 어설프게 설명되어 있는 부분에 대해서는 언제든
지적해주시면 다시금 수정하고 정리할 수 있도록 하겠습니다. 감사합니다 :)&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://deview.kr/2021/sessions/518&quot;&gt;Inside React (동시성을 구현하는 기술)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://dev.to/okmttdhr/what-is-lane-in-react-4np7&quot;&gt;What is “Lane” in React?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://goidle.github.io/react/in-depth-react-preview/&quot;&gt;React 톺아보기 - 01. Preview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react/pull/18796&quot;&gt;github.com/facebook/react/pull/18796&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/facebook/react&quot;&gt;github.com/facebook/react&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://wicg.github.io/is-input-pending/#continuous-events&quot;&gt;wicg.github.io/is-input-pending&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/7008802041602506765&quot;&gt;React 소스 코드 파싱 우선 순위 Lane 모델&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[stale-while-revalidate 전략은 어떻게 활용되고 있을까]]></title><description><![CDATA[클라이언트를 개발하면서 HTTP Cache-Control Extensions for Stale Content의
 확장 디렉티브 전략을 기반으로한
구현체들을 많이 접하게 되는데요. swr…]]></description><link>https://youthfulhps.dev/web/stale-while-ravalidate/</link><guid isPermaLink="false">https://youthfulhps.dev/web/stale-while-ravalidate/</guid><pubDate>Wed, 01 Jun 2022 16:07:27 GMT</pubDate><content:encoded>&lt;p&gt;클라이언트를 개발하면서 &lt;a href=&quot;https://datatracker.ietf.org/doc/html/rfc5861&quot;&gt;HTTP Cache-Control Extensions for Stale Content&lt;/a&gt;의
&lt;code class=&quot;language-text&quot;&gt;stale-while-revalidate (swr)&lt;/code&gt; 확장 디렉티브 전략을 기반으로한
구현체들을 많이 접하게 되는데요. swr 전략은 무엇인지, 어떻게 활용되고 있는 지
알아보려 합니다.&lt;/p&gt;
&lt;h2 id=&quot;stale-while-revalidate&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#stale-while-revalidate&quot; aria-label=&quot;stale while revalidate permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;stale-while-revalidate&lt;/h2&gt;
&lt;p&gt;swr 전략은 캐싱된 컨텐츠를 즉시 로드하는 즉시성과 업데이트된 캐싱 컨텐츠가
미래에 사용되도록 보장하기 위한 디렉티브입니다.&lt;/p&gt;
&lt;p&gt;브라우저는 Cache-Control의 max-age를 기준으로 캐싱된 컨텐츠의 최신 상태 여부를 판단하게 되는데,
swr은 캐싱된 낡은 컨텐츠에 대한 확장된 지시를 표현합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;yaml&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;Cache-Control: max-age=1, stale-while-revalidate=59&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;위와 같은 HTTP 해더는 캐싱된 컨텐츠에 대해 아래와 같이 지시를 따르게 됩니다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP 요청이 1초(max-age) 이내에 반복적으로 발생한다면, 유효성 검증 없이 캐싱된 컨텐츠를 반환합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 864px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA80lEQVQoz62TPYsCMRCG/be29w9OsD2wshMLO7HT6rhGWLBRERV1beS4O+62uizqJpnsx2sS3eBHpWvgycwUeUgmSSnLMpyP6/reUcolSZI4WRGpFaZpCsaYlebCR7DCPJFSFj6uWe+EYRhCCAGlFBSpY8yhI/Gpjh2xw+3QTIk+8uJ7jenfCqPfGQY/I/S/Bnj/7KO3+UDb76K17KDpt1FftPA2b6AyreNlUkN5WMXruAaK6fJSTA8jHkGQBJfiBNe1ANuGGgZOHHux10TY6bi17Gx+00P2z57TQ5MQETzPA+e8+C2byYiCILgRPvQOn/1TDi/IWkorpouYAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Requests within max-age return caching data&quot;
        title=&quot;Requests within max-age return caching data&quot;
        src=&quot;/static/f9e7bb4b3dee1eadcc36789a1ce9936b/9cab2/swr-flow-1.png&quot;
        srcset=&quot;/static/f9e7bb4b3dee1eadcc36789a1ce9936b/5a46d/swr-flow-1.png 300w,
/static/f9e7bb4b3dee1eadcc36789a1ce9936b/0a47e/swr-flow-1.png 600w,
/static/f9e7bb4b3dee1eadcc36789a1ce9936b/9cab2/swr-flow-1.png 864w&quot;
        sizes=&quot;(max-width: 864px) 100vw, 864px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;HTTP 요청이 1 ~ 60초(max-age ~ swr) 사이에 반복적으로 발생할 경우,
우선 캐싱된 낡은 컨텐츠를 반환하고, 이와 동시에 캐싱된 컨텐츠를 새로운 컨텐츠로 채우도록 재검증 요청이 발생합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 864px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABMElEQVQoz51SPU/DMBTMv2XlDzAgVhBTJ8QAE4gJJpi6hKUVqkBtYUCIVOoQKYmdOrHzYfuIHbkNH4JQKyffs/LuvXe2p7WGW13+U9xneS7RJTvejbcSrOva7kopEEJs/LXAX7CCjiit1lU451uNa3LWgqYjWUt7yFas5aqp3HSspII2sHELfIJRM59uRzZjzhYvmCynGC8f4S9GGL7f4/ZtiJvXO1zOr3E+u8Lp8wUG0zMcPp1gfzLA7sMxdkYH2BsfoazLjYfWN0rA8gy8EM3OkIkcecEhqgJJmiCiMZjIkPIVaAPCUyQGOQVp8N1DtfEwiePWy5yDEvo/Dx1hjFnRqqrg+z6EEIiiCEEQQEpp/el1y667siztoREKw9DetIEpZAT7vknvt5+6NvR9Rh9JCVjenLr8FQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;Return stale caching content for requests within swr, request re-validation&quot;
        title=&quot;Return stale caching content for requests within swr, request re-validation&quot;
        src=&quot;/static/4cfd14b60aa1d85a5dc28e2a9770979f/9cab2/swr-flow-2.png&quot;
        srcset=&quot;/static/4cfd14b60aa1d85a5dc28e2a9770979f/5a46d/swr-flow-2.png 300w,
/static/4cfd14b60aa1d85a5dc28e2a9770979f/0a47e/swr-flow-2.png 600w,
/static/4cfd14b60aa1d85a5dc28e2a9770979f/9cab2/swr-flow-2.png 864w&quot;
        sizes=&quot;(max-width: 864px) 100vw, 864px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;HTTP 요청이 60초(swr ~) 이후 시점에 발생한다면, 요청이 서버로 전달되어 컨텐츠를 반환받습니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;react-query-swr&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#react-query-swr&quot; aria-label=&quot;react query swr permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;react-query, swr&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://react-query.tanstack.com/&quot;&gt;react-query&lt;/a&gt;와 &lt;a href=&quot;https://swr.vercel.app/ko&quot;&gt;swr&lt;/a&gt;는 swr 전략을 취한 대표적인 데이터 패칭 도구입니다.&lt;/p&gt;
&lt;p&gt;클라이언트에서 리덕스를 사용한다면 서버로부터 전달받은 값을 리덕스에 저장하고 최신화된 데이터로서 사용됩니다.
하지만 특정 시점의 서버 데이터를 캡쳐한 것이고, 이 데이터가 최신화된 데이터라고 보장하기가 어렵습니다.&lt;/p&gt;
&lt;p&gt;그렇다보니 페이지 전환, 유저의 인터렉션이 새롭게 발생되면 새로운 요청을 통해
리덕스 스토어의 값을 업데이트해주어야 하는 최신화에 대한 의무와 시점에 대한 고민,
그리고 중복된 디스패치에 대한 제거는 오로지 클라이언트 개발자의 몫이었습니다.&lt;/p&gt;
&lt;p&gt;반면 react-query, swr은 낡은 캐시로부터 빠르게 컨텐츠를 반환하고,
백그라운드에서 요청을 통해 캐싱된 컨텐츠의 재검증을 진행하여 캐싱 레이어에서
최신화된 데이터를 보장할 수 있도록 swr 캐싱 전략을 취하고 있습니다.&lt;/p&gt;
&lt;p&gt;react-query의 경우, 비동기 데이터 소스에 대해 쿼리라는 고유키를 통해 관리하며
데이터 상태를 &lt;code class=&quot;language-text&quot;&gt;fresh&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;fetching&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;stale&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;inactive&lt;/code&gt; 로 표현하고,
&lt;code class=&quot;language-text&quot;&gt;staleTime&lt;/code&gt; 을 통해 프레시한 컨텐츠가 낡은 컨텐츠로 전환되는 시간을 설정하여
캐싱된 컨텐츠 특성에 따라 유효 시간을 개별 설정해줄 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const { data } = useQuery(&amp;#39;users&amp;#39;, getUsers, {
  staleTime: 5000,
  cacheTime: 1000 * 60 * 5,
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이러한 데이터 패칭 도구들은 클라이언트 개발에서 주기적 혹은 특정 트리거에 의해
서버의 값을 가져와 최신화된 데이터를 가져오려는 노력과 캐싱, 업데이트 및 동기화,
에러 핸들링 등 복잡한 비동기 과정을 앱에게 책임을 전가할 수 있도록 도와줍니다.&lt;/p&gt;
&lt;h2 id=&quot;incremental-static-regeneration&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#incremental-static-regeneration&quot; aria-label=&quot;incremental static regeneration permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;incremental static regeneration&lt;/h2&gt;
&lt;p&gt;넥스트에서는 애플리케이션을 빌드할 때 &lt;code class=&quot;language-text&quot;&gt;getStaticProps&lt;/code&gt; 를 통해
필요한 서버 데이터를 받아와 json 파일로 저장하고,
마크업 파일을 생성해 두어 요청 시 정적으로 빠르게 페이지를 제공합니다.
이를 정적 사이트 생성(&lt;a href=&quot;https://nextjs.org/docs/basic-features/data-fetching/get-static-props#statically-generates-both-html-and-json&quot;&gt;static site generation&lt;/a&gt;) 이라고 하는데요.&lt;/p&gt;
&lt;p&gt;하지만 빌드 시점에 미리 서버 데이터를 받아와 저장을 하다보니,
특정 시점에서 캡쳐된 데이터가 최신화 데이터로서 무효할 수 있습니다.
여기서, 넥스트는 잘 알려진 swr 전략을 취해 증분 정적 재생성(&lt;a href=&quot;https://nextjs.org/docs/basic-features/data-fetching/incremental-static-regeneration&quot;&gt;incremental static regeneration&lt;/a&gt;)을 가능케하여 이러한 문제를 해결합니다.&lt;/p&gt;
&lt;p&gt;사용법은 매우 간단한데, &lt;code class=&quot;language-text&quot;&gt;getStaticProps&lt;/code&gt; 의 반환 프로퍼티로서
&lt;code class=&quot;language-text&quot;&gt;revalidate&lt;/code&gt; 값을 설정해주면 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;export async function getStaticProps() {
  const response = await fetch(&amp;#39;...&amp;#39;)
  const posts = await res.json()

  return {
    props: {
      posts,
    },
    revalidate: 10,
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;a href=&quot;https://youthfulhps.dev/nextjs/next-isr/#%EC%A6%9D%EB%B6%84-%EC%A0%95%EC%A0%81-%EC%9E%AC%EC%83%9D%EC%84%B1%EC%9D%98-%ED%83%80%EC%9E%84%EB%9D%BC%EC%9D%B8&quot;&gt;증분 정적 재생성 타임라인&lt;/a&gt;은 swr 전략과 동일합니다.
&lt;code class=&quot;language-text&quot;&gt;revalidate&lt;/code&gt; 시간 이내의 페이지 요청은 빌드해 두었던 페이지와 데이터를 정적으로 빠르게 제공하고,
이후 재검증을 통해 페이지와 데이터를 재생성하여 최신화합니다.
이로서 이후 요청에 대해서는 업데이트된 페이지와 데이터 또한 정적으로 빠르게 제공할 수 있게 됩니다.&lt;/p&gt;
&lt;p&gt;그냥 &lt;code class=&quot;language-text&quot;&gt;getServerSideProps&lt;/code&gt; 로 요청 시점에 데이터 패칭을 하여 페이지를 제공하면 되지 않나?
싶지만, 서버 사이드 랜더링과 정적 사이트 생성은 단순히 서버 응답 시간(TTFB)를 현저히 향상시킬 수 있기 때문에
isr 적용을 적극적으로 고려해보아야 합니다.&lt;/p&gt;
&lt;h2 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h2&gt;
&lt;p&gt;아직 부족한 경험이지만, 캡쳐된 서버 데이터를 클라이언트에서 관리하기 위해 리덕스와 씨름해 보았거나,
서버 사이드 랜더링으로 인해 페이지 전환 속도에 아쉬움을 느껴보았다면
swr 전략을 기반으로한 구현체들이 주는 개발 경험이 정말 훌륭하다는 것을 공감하실텐데요.&lt;/p&gt;
&lt;p&gt;그 근간이 되는 swr 전략에 대해 알아보았습니다. 더 많은 예시들이나, 잘못된 설명이 있다면 언제든 코멘트 주시면 감사하겠습니다 :) 감사합니다.&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://jbee.io/react/thinking-about-global-state/&quot;&gt;전역 상태 관리에 대한 단상 (stale-while-revalidate)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://web.dev/i18n/ko/stale-while-revalidate/&quot;&gt;stale-while-revalidate로 최신 상태 유지&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[온디멘드 이미지 리사이징을 위한 인프라 구성]]></title><description><![CDATA[사용자 경험 품질 향상을 위한 이미지 최적화에서 온디멘드 이미지 리사이징
에 대한 이야기를 공유해드렸습니다. 이번 글에서는 CloudFront에서  를 통해 직접 구현해본 과정을 정리해보려 합니다. TL;DR S…]]></description><link>https://youthfulhps.dev/infra/image-optimization-with-cloudfront/</link><guid isPermaLink="false">https://youthfulhps.dev/infra/image-optimization-with-cloudfront/</guid><pubDate>Tue, 31 May 2022 14:05:04 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://youthfulhps.dev/web/image-optimization/&quot;&gt;사용자 경험 품질 향상을 위한 이미지 최적화&lt;/a&gt;에서 온디멘드 이미지 리사이징
에 대한 이야기를 공유해드렸습니다. 이번 글에서는 CloudFront에서 &lt;code class=&quot;language-text&quot;&gt;lambda@edge&lt;/code&gt; 를 통해 직접 구현해본 과정을 정리해보려 합니다.&lt;/p&gt;
&lt;h2 id=&quot;tldr&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#tldr&quot; aria-label=&quot;tldr permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;TL;DR&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;S3 버킷을 생성하고 이미지를 업로드합니다.&lt;/li&gt;
&lt;li&gt;CloudFront를 통해 S3 컨텐츠를 배포합니다.&lt;/li&gt;
&lt;li&gt;라시아징, webp 파일 형식 변환을 위한 노드 환경 람다 함수를 구현합니다.&lt;/li&gt;
&lt;li&gt;버킷 접근 권한 및 역할을 담은 IAM을 정의하고 람다 함수에 부여합니다.&lt;/li&gt;
&lt;li&gt;CloudFront의 오리진 응답 엣지에 람다 함수를 연동합니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;s3-샘플-이미지-업로드&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#s3-%EC%83%98%ED%94%8C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%97%85%EB%A1%9C%EB%93%9C&quot; aria-label=&quot;s3 샘플 이미지 업로드 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;S3, 샘플 이미지 업로드&lt;/h2&gt;
&lt;p&gt;일반적으로 사용되는 S3 버킷을 생성하는 과정과 동일합니다. &lt;code class=&quot;language-text&quot;&gt;모든 퍼블릭 엑세스 차단이 비활성화&lt;/code&gt; 가 선택된
버킷을 생성하고 샘플 이미지 객체를 업로드해주세요.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 38.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABO0lEQVQoz5VRSXbDIBTz/e/Qy/QO7aJDbCdpGtsJmNEG7KqCDO910UUWeh/ERxKfqtkfsN3tULctscVu/4XhLKCNgdK61EdQ1fUGddNiU9fYNA3ePz7R0kQqxQZdRB9BJUfJhbkT2UUIgcxra/9Jwj59Mbxx5mpedX0P6xwJkhRQ1kPaCcrYO6fZaFmtdWVvnIeZU6n5TJM/aw/rJ1RCSozq4qSIkYIn7SDI3U146cS55uSH/gzRvGB8foLevsJOoQQSDGGnGZXhxk8eKUWESISAGEOpN0Ty83U9zQGzkZi/3xBYY1oQyS+8nzUqISSG0WL0oQimlApu6dZ15TxH9P1w4Yi0rFgApPWniExMNtMoj4WfotAMCnvp4HiQRWNMcEyex5DF85PzrI/HDseu42X2hfnPC5z3yOF+AbnoZN7grE7QAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;create s3 bucket&quot;
        title=&quot;create s3 bucket&quot;
        src=&quot;/static/886281b9a152864e2531ecdde013164a/c1b63/s3-bucket.png&quot;
        srcset=&quot;/static/886281b9a152864e2531ecdde013164a/5a46d/s3-bucket.png 300w,
/static/886281b9a152864e2531ecdde013164a/0a47e/s3-bucket.png 600w,
/static/886281b9a152864e2531ecdde013164a/c1b63/s3-bucket.png 1200w,
/static/886281b9a152864e2531ecdde013164a/9239a/s3-bucket.png 1246w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;cloudfront-s3-컨텐츠-배포&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#cloudfront-s3-%EC%BB%A8%ED%85%90%EC%B8%A0-%EB%B0%B0%ED%8F%AC&quot; aria-label=&quot;cloudfront s3 컨텐츠 배포 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;CloudFront, S3 컨텐츠 배포&lt;/h2&gt;
&lt;p&gt;CloudFront 배포를 생성합니다. 기본적으로 CloudFront는 쿼리 문자열을 무시하게 되는데,
쿼리 문자열 파라미터 기반의 컨텐츠 캐싱이 가능하도록 &lt;code class=&quot;language-text&quot;&gt;캐시 키 및 원본 요청&lt;/code&gt;
에서 &lt;code class=&quot;language-text&quot;&gt;Lagacy cache settings&lt;/code&gt; 를 선택하여 컨텐츠 캐싱에 사용할 &lt;code class=&quot;language-text&quot;&gt;쿼리 문자열을 설정&lt;/code&gt; 해줍니다.&lt;/p&gt;
&lt;p&gt;쿼리 문자열은 이미지 변환에 대한 설정을 전달하기 위한 역할로서
&lt;code class=&quot;language-text&quot;&gt;너비, 높이, 이미지 핏, webp 변환&lt;/code&gt; 에 대한 설정값을 담을 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한, &lt;code class=&quot;language-text&quot;&gt;쿼리 문자열 파라미터 기반의 컨텐츠 캐싱&lt;/code&gt; 이라는 특징에 따라, 동일한 쿼리 조합의 요청에 대한
리사이징된 컨텐츠가 CloudFront에 캐싱되어 있다면, S3까지 오리진 요청이 전달되지 않고,
CloudFront에서 뷰어 응답으로 빠르게 컨텐츠를 전달합니다.&lt;/p&gt;
&lt;deckgo-highlight-code   &gt;
          &lt;code slot=&quot;code&quot;&gt;https://...cloudfront/sample-image.jpg?w=500&amp;amp;h=300&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 646px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 82.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAAAsTAAALEwEAmpwYAAABrElEQVQ4y5VUaXeCMBDk//82X1/bD7ZVoJcWLwhHuNHtzkJ4YMVqfGMgWYaZ3Q3WfP5Cr28Lms0e6PHpmTxvQ8fjkaqqYtSCsmyvS15rmoYwTqeT4HxYB98nP1C02+1pf2ivtU4py3JKEk1RFFMYRpTw2sEPeNbXCfM8pziO+eGEibQ8rMKQ55CUUv19EASUZllPNjWsxZdHjm3T0nZosbQFAatUqiUNo0juQYiXD9WdQwiTNOMclVdtDMel/RFh+3ZFUZwI4gTQkyqmlBliC5a8zZbz0xYBydesuq5rqrmi/4LjEI/OEIUZisKqTDv0b+MfgpobgHbqLfvcCrbjkvvxyUkvxLbfpQCEd1tOWe73asVYk+O+C3SaUlGUt9nmGKSptwy5IG1PBoMDzEDQFIaWQdpbxiZOCVThiCGnOCUgv3eIZfyhKKg28qZCzLGcClHCtkbo1vKikOaHCKOuJyx4E4pGlvgh2J8C0rTZ7qSQw+YWQmwiwbiWQhhMFKKS3kvpx9sK4R+FaOjV2pOvjbEgSjFfQueg7lIwIkQADj0+TfhU1YMq31MMQ/oL16kym/3742QAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;cloudFront&quot;
        title=&quot;cloudFront&quot;
        src=&quot;/static/bb8a52f68069f6b1bb7de64e65c6a92a/27524/cloudFront.png&quot;
        srcset=&quot;/static/bb8a52f68069f6b1bb7de64e65c6a92a/5a46d/cloudFront.png 300w,
/static/bb8a52f68069f6b1bb7de64e65c6a92a/0a47e/cloudFront.png 600w,
/static/bb8a52f68069f6b1bb7de64e65c6a92a/27524/cloudFront.png 646w&quot;
        sizes=&quot;(max-width: 646px) 100vw, 646px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;람다-함수에-부여할-iam-역할-생성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%9E%8C%EB%8B%A4-%ED%95%A8%EC%88%98%EC%97%90-%EB%B6%80%EC%97%AC%ED%95%A0-iam-%EC%97%AD%ED%95%A0-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;람다 함수에 부여할 iam 역할 생성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;람다 함수에 부여할 IAM 역할 생성&lt;/h2&gt;
&lt;p&gt;람다 함수에서 우리를 대신해 S3 객체에 접근할 수 있도록 &lt;code class=&quot;language-text&quot;&gt;s3:GetObject&lt;/code&gt; 와 같은 권한을 부여해주어야 합니다.
&lt;code class=&quot;language-text&quot;&gt;IAM 콘솔&lt;/code&gt; 로 접근하여 역할을 생성, &lt;code class=&quot;language-text&quot;&gt;AWS 서비스 / Lambda&lt;/code&gt; 를 선택하고 단계를 넘어갑니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 981px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 42.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABIElEQVQoz41S7W6EIBD0/R+qfYm296+5qoUCiiLKh1/ThTsvl0vTdpMJiM7s7EgxDAM4Y+g6De8dYgjwzmHbNtzXvu8Zxz5V2Tg8vTa02xDnGcuyoDAkKGQDpXtwoTKaps0vE3El4XVdb4Kp0XY9u7a6PScULyzg+aTxdpY46wWfFlCdhZQCjJw7N2Ua5xxlWSLQBDHG3LCua1RVBSFEPsuCH2rEqTYoRY933qFUFoxcto2CGSz6kSKIC6ZpykjEJJoErbXU0GGmcQ+XxWgNWiXJAcM0jpTfhZg+dD5gDCvCvOKxjhzv803IGUqlEKjzz7Vfcroj/YaCqR6t7miUkEfx3uf1yOrRwZ+CX5oykx3sYJDcpmtkjMlrwvE3/yv4DVBfbnoVbMAfAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;create-iam&quot;
        title=&quot;create-iam&quot;
        src=&quot;/static/a30b87eaf5e4a000e4fe0cb332379170/1c3a5/create-iam.png&quot;
        srcset=&quot;/static/a30b87eaf5e4a000e4fe0cb332379170/5a46d/create-iam.png 300w,
/static/a30b87eaf5e4a000e4fe0cb332379170/0a47e/create-iam.png 600w,
/static/a30b87eaf5e4a000e4fe0cb332379170/1c3a5/create-iam.png 981w&quot;
        sizes=&quot;(max-width: 981px) 100vw, 981px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;다음 단계에서는 &lt;code class=&quot;language-text&quot;&gt;정책 생성&lt;/code&gt; 을 통해 JSON 편집을 통해 권한을 편집합니다.
아래와 동일하게 작성하셔도 무방합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;Version&amp;quot;: &amp;quot;2012-10-17&amp;quot;,
  &amp;quot;Statement&amp;quot;: [
    {
      &amp;quot;Sid&amp;quot;: &amp;quot;VisualEditor0&amp;quot;,
      &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;,
      &amp;quot;Action&amp;quot;: [
        &amp;quot;iam:CreateServiceLinkedRole&amp;quot;,
        &amp;quot;lambda:GetFunction&amp;quot;,
        &amp;quot;lambda:EnableReplication&amp;quot;,
        &amp;quot;cloudfront:UpdateDistribution&amp;quot;,
        &amp;quot;s3:GetObject&amp;quot;,
        &amp;quot;logs:CreateLogGroup&amp;quot;,
        &amp;quot;logs:CreateLogStream&amp;quot;,
        &amp;quot;logs:PutLogEvents&amp;quot;,
        &amp;quot;logs:DescribeLogStreams&amp;quot;
      ],
      &amp;quot;Resource&amp;quot;: &amp;quot;*&amp;quot;
    }
  ]
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;정책 이름&lt;/code&gt; 을 설정하고, &lt;code class=&quot;language-text&quot;&gt;정책 생성&lt;/code&gt; 을 완료했다면, &lt;code class=&quot;language-text&quot;&gt;IAM&lt;/code&gt; 탭으로 돌아가
람다 함수에게 실행 역할 즉, AWS 서비스 및 리소스에 접근할 수 있는 엑세스 권한을 &lt;code class=&quot;language-text&quot;&gt;정책 연결&lt;/code&gt;을 통해 제공합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 985px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 24%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAjElEQVQY052OWw6CMBQFu3cX5Fr8M8FHgoW0hZZWgsW+jnJlAWCTyeT+TA8bbQ+lOjjniLZtMQwDpJR0L6+UshnGRYcHbyCEoMgS5JxTNISAnDNSSuQtsMPxglP9/O7IeK+BGCP9tncdLTxXd1TXG7TW0MaQzWrd6593wPxrQqMsamnhxgnz7OH9/3wAx1KCC2XdC/gAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;connect-policy&quot;
        title=&quot;connect-policy&quot;
        src=&quot;/static/f6d8a8940e62c5211434002e7fe55792/58bb7/connect-policy.png&quot;
        srcset=&quot;/static/f6d8a8940e62c5211434002e7fe55792/5a46d/connect-policy.png 300w,
/static/f6d8a8940e62c5211434002e7fe55792/0a47e/connect-policy.png 600w,
/static/f6d8a8940e62c5211434002e7fe55792/58bb7/connect-policy.png 985w&quot;
        sizes=&quot;(max-width: 985px) 100vw, 985px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;역할 / 신뢰 관계 / 신례 관계 편집&lt;/code&gt; 을 선택하여 마찬가지로 JSON 편집을 통해 역할에 신뢰 관계를 추가합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;Version&amp;quot;: &amp;quot;2012-10-17&amp;quot;,
  &amp;quot;Statement&amp;quot;: [
    {
      &amp;quot;Effect&amp;quot;: &amp;quot;Allow&amp;quot;,
      &amp;quot;Principal&amp;quot;: {
        &amp;quot;Service&amp;quot;: [&amp;quot;edgelambda.amazonaws.com&amp;quot;, &amp;quot;lambda.amazonaws.com&amp;quot;]
      },
      &amp;quot;Action&amp;quot;: &amp;quot;sts:AssumeRole&amp;quot;
    }
  ]
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;온디멘드-이미지-webp-파일-형식-변환을-위한-lambda-함수-생성-w-sharpjs&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%98%A8%EB%94%94%EB%A9%98%EB%93%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-webp-%ED%8C%8C%EC%9D%BC-%ED%98%95%EC%8B%9D-%EB%B3%80%ED%99%98%EC%9D%84-%EC%9C%84%ED%95%9C-lambda-%ED%95%A8%EC%88%98-%EC%83%9D%EC%84%B1-w-sharpjs&quot; aria-label=&quot;온디멘드 이미지 webp 파일 형식 변환을 위한 lambda 함수 생성 w sharpjs permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;온디멘드 이미지, WebP 파일 형식 변환을 위한 Lambda 함수 생성 (w/ sharp.js)&lt;/h2&gt;
&lt;p&gt;람다 함수를 생성합니다. 이때, 람다 트리거를 CloudFront로 설정할 수 있는 지역은
&lt;code class=&quot;language-text&quot;&gt;버지니아 북부&lt;/code&gt; 만 가능하기 때문에 지역을 변경하고 람다 함수를 생성해주세요.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 978px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA40lEQVQoz6VS2Y6DMAzM///klq2qSrAkQE4SYNY20FZ9KW0tjZxL4/HEqmka1HWNaSoopSDn/BWUMR1M19GmIMZExBOWZcE8zx9BtVrj51Sh+j0LBmtRiJQvpw23NZ2/gur7Abq38CHAOQ9rHcZxlPb3R6ye85EghQbXukGIUZCIjLPzQYrshfjsiErykAn/ENMoymJKlLP4uINDfD0AdW07VOcLKctCmDZCbETvhuJP4Pae41HhEdwIeWTM4FYPQ7z75r0U4mydk8xjxX6ud3dwVzux4mFsWw1Nn8Pj8a6yZ/wDNRURG9YxeiMAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;create-lambda&quot;
        title=&quot;create-lambda&quot;
        src=&quot;/static/57e65d67c8b4ae261a794e50e8bb41a8/914c7/create-lambda.png&quot;
        srcset=&quot;/static/57e65d67c8b4ae261a794e50e8bb41a8/5a46d/create-lambda.png 300w,
/static/57e65d67c8b4ae261a794e50e8bb41a8/0a47e/create-lambda.png 600w,
/static/57e65d67c8b4ae261a794e50e8bb41a8/914c7/create-lambda.png 978w&quot;
        sizes=&quot;(max-width: 978px) 100vw, 978px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;권한 / 구성&lt;/code&gt; 탭에서 생성한 IAM 역할을 설정합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 837px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 26.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAqElEQVQY042OyQrDMAxE/f/fmEJr6maxnX3xPpVd6KWQ9PBAMNLTMKU1VN9D1DWk0uBPgabroGqOpm1olqjbFv0wYJpnjNN0CtMky8vLun7Jh52U9ED9ZFeQcCxm5xystQVjDPbjQFXdwB8cIQR4yt0fMNUIHMbSkYfzHp7I0m3fqenyyWKC8QExJaQLmBJ32LwcQ2kSYizSLBTDime/4TXmeS8PS9sT3gNQgjcfQD13AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;set-policy&quot;
        title=&quot;set-policy&quot;
        src=&quot;/static/8eb26ebf210f9e4a278ce9a432ce7bc9/ddc81/set-policy.png&quot;
        srcset=&quot;/static/8eb26ebf210f9e4a278ce9a432ce7bc9/5a46d/set-policy.png 300w,
/static/8eb26ebf210f9e4a278ce9a432ce7bc9/0a47e/set-policy.png 600w,
/static/8eb26ebf210f9e4a278ce9a432ce7bc9/ddc81/set-policy.png 837w&quot;
        sizes=&quot;(max-width: 837px) 100vw, 837px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이제, 람다 함수 대시보드로 이동하여 이미지 리사이징, webp 포맷팅 적용을 위한 코드를 업로드합니다.
코드는 &lt;a href=&quot;https://medium.com/daangn/lambda-edge%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-on-the-fly-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A6%AC%EC%82%AC%EC%9D%B4%EC%A7%95-f4e5052d49f3&quot;&gt;AWS Lambda@Edge에서 실시간 이미지 리사이즈 &amp;#x26; WebP 형식으로 변환&lt;/a&gt;를 참고하고 약간의 수정을 더하여 작성하였는데, 위 글에서도 잘 정리되어 있지만, 구현하면서 짚고 넘어가야 될 부분들이 몇 가지 있었는데요.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;노드 환경에서 동작하는 람다 머신이 별도로 가지고 있지 않은 모듈은 직접 &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 폴더를 함께 압축하여 제공해주어야 했습니다.&lt;/strong&gt; 의존성 해결을 위한 별도의 설치 과정이 포함되어 있지 않습니다.
&lt;code class=&quot;language-text&quot;&gt;querystring&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;aws-sdk&lt;/code&gt; 를 포함한 몇 가지 모듈들은 이미 의존성이 해결되어 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Dependencies resolved

const querystring = require(&amp;#39;querystring&amp;#39;)
const AWS = require(&amp;#39;aws-sdk&amp;#39;)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;람다 함수에서 바디를 조작했다면, 그 결과가 1MB 이하여야 했습니다.&lt;/strong&gt; 만약 1MB 보다 크다면, 이미지의 퀄리티를 단계적으로 낮추는 방법으로 접근했습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const MEGABYTE = 1046528
const byteLength = Buffer.byteLength(resizedImage, &amp;#39;base64&amp;#39;)

if (byteLength &amp;gt; MEGABYTE) {
  resizedImage.toFormat(requiredFormat, { quality: 90 })
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;퀄리티 저하의 한계점을 넘어가거나, 타임 아웃이 되면 원본을 반환했습니다.&lt;/strong&gt;
1MB 제약을 지키기 위해서 변환 과정이 너무 오래 걸리거나, 이미지 퀄리티가
너무 저하되는 경우 원본을 반환하도록 했습니다.&lt;/p&gt;
&lt;p&gt;이제 비즈니스에 맞게 코드를 수정하고, &lt;code class=&quot;language-text&quot;&gt;node_modules&lt;/code&gt; 와 함께 압축된 코드 업로드를 마치셨다면,
람다 함수 상단 메뉴 &lt;code class=&quot;language-text&quot;&gt;작업 / Lambda@edge 배포&lt;/code&gt; 를 선택합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 812px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 36.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAA2UlEQVQoz5XRTW7CMBAFYJ+6t+qCm3RBq5RsGkQaxyEoJXEy47/HYIVFpSKopc9vNmNbY9U0DYriE2VZYppGBO/hHMP/4h5yzLDWQpELWFbk4yqs4tOu/Sw9qh4DPvSIXX3Etmrxvm9R1D12zQnbL50dfhjtnKBtEPFP31PAcZYDLTmczhaT5Lhwdp4pp4sACwrpMXmlk1TDMKCq9uj7HsYYmNZAa42u68BEeTb/WcrJJ7AMlaTxmreaiLEslOuU0l3xVscoGaGeufXeYbLBkgd1FabXF9DbBhcz6CBzqjHQjAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;upload-code&quot;
        title=&quot;upload-code&quot;
        src=&quot;/static/4156216eefefc2712ad4f0d24616971f/63ec5/upload-code.png&quot;
        srcset=&quot;/static/4156216eefefc2712ad4f0d24616971f/5a46d/upload-code.png 300w,
/static/4156216eefefc2712ad4f0d24616971f/0a47e/upload-code.png 600w,
/static/4156216eefefc2712ad4f0d24616971f/63ec5/upload-code.png 812w&quot;
        sizes=&quot;(max-width: 812px) 100vw, 812px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;CloudFront 이벤트는 &lt;a href=&quot;https://youthfulhps.dev/web/image-optimization/#lambdaedge&quot;&gt;사용자 경험 품질 향상을 위한 이미지 최적화&lt;/a&gt;에 기반하여 &lt;code class=&quot;language-text&quot;&gt;오리진 응답&lt;/code&gt; 을 설정합니다. 이제, 람다 함수를 &lt;code class=&quot;language-text&quot;&gt;배포&lt;/code&gt; 합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 810px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 71.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABeklEQVQ4y6VTi06DQBDkt/0r458YbavWUqutRV53vK9AGXcOMK2hiY9LJsDd7ezO7uDsdu+YzRe4u59hvniAUgpN0+BwOPwcdW2feV7A0TpBEIRI0xSnq+s6HI/HX8PZ+ArL5xVWrovtdgdWrLVG27b4y3J8qc5111ivX+yTZHmeW9ljpZcWz77D2e89UHYmJIQZelILrOyJoHFvKqEThBF0kqIyBlVlUFYVirK0xK30hNJ79O/sE5Px/iRhLFONoliqK5Bm2RcomcHtBfBskpDBlKyUtqMnETFWM0VU01ZS5SThhx9g8/qGIBTr2D4WSMRClvRM8gDZG5NODUamHODxaYm954EDimPVB0mwBYPH94HUGvmkwjPCUgaQJIm1C/8Sfv9nOalIjHWKvChRFL1cLQn45zAJk/WDi+w+FRBKzrKT/ofiFk7f8XUO14sRCSkJaWpawlgbVXaPVRP8LgeM5/Y+7WZqaZVIxj+XaTo08Rbl9RXM7Q0+AZ02RHec2QQWAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;distribution-lambda&quot;
        title=&quot;distribution-lambda&quot;
        src=&quot;/static/fb945c5c14381aae0d1b9ff3f6836096/d7542/distribution-lambda.png&quot;
        srcset=&quot;/static/fb945c5c14381aae0d1b9ff3f6836096/5a46d/distribution-lambda.png 300w,
/static/fb945c5c14381aae0d1b9ff3f6836096/0a47e/distribution-lambda.png 600w,
/static/fb945c5c14381aae0d1b9ff3f6836096/d7542/distribution-lambda.png 810w&quot;
        sizes=&quot;(max-width: 810px) 100vw, 810px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h2&gt;
&lt;p&gt;단순히 코드 레벨과 물리적인 대응 방안을 고민하는 단계에서 더 넓은 접근 방식을 배울 수 있었던 좋은 경험이었습니다. 이미지 리사이징, webp 포맷팅이 잘 적용되는 지 확인해보실 수 있는 간단한 &lt;a href=&quot;https://github.com/youthfulhps/image-ondemand-resizing&quot;&gt;프로젝트&lt;/a&gt;를 구성해두었으니 경험해보실 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/daangn/lambda-edge%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-on-the-fly-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A6%AC%EC%82%AC%EC%9D%B4%EC%A7%95-f4e5052d49f3&quot;&gt;https://medium.com/daangn/lambda-edge로-구현하는-on-the-fly-이미지-리사이징-f4e5052d49f3&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[사용자 경험 품질 향상을 위한 이미지 최적화]]></title><description><![CDATA[많은 이미지를 다루는 페이지의 경우, 이미지 최적화에 신경쓰지 않으면 사용자 경험 지표에서 많은 감점을 받기 쉽습니다.
사용자 경험 지표를 측정해보면, 이미지 관련된 감점 요소들이 정말 많은데요. Properly size images Serve…]]></description><link>https://youthfulhps.dev/web/image-optimization/</link><guid isPermaLink="false">https://youthfulhps.dev/web/image-optimization/</guid><pubDate>Sun, 29 May 2022 16:05:05 GMT</pubDate><content:encoded>&lt;p&gt;많은 이미지를 다루는 페이지의 경우, 이미지 최적화에 신경쓰지 않으면 사용자 경험 지표에서 많은 감점을 받기 쉽습니다.
사용자 경험 지표를 측정해보면, 이미지 관련된 감점 요소들이 정말 많은데요.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Properly size images&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Serve images in next-gen formats&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Defer offscreen images&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Image elements do not have explicit width and height&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;어떻게 하면 유저 경험 측면에서 사랑받을 수 있는 이미지를 랜더링할 수 있을 지에 대해 고민하고 작업한 내용들을 기록해볼 까 합니다.&lt;/p&gt;
&lt;h2 id=&quot;이미지-요소의-속성을-이해하자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%9A%94%EC%86%8C%EC%9D%98-%EC%86%8D%EC%84%B1%EC%9D%84-%EC%9D%B4%ED%95%B4%ED%95%98%EC%9E%90&quot; aria-label=&quot;이미지 요소의 속성을 이해하자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이미지 요소의 속성을 이해하자&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;img /&gt;&lt;/code&gt;는 필수 속성인 &lt;code class=&quot;language-text&quot;&gt;src&lt;/code&gt;를 포함하여 옵션으로 설정하는 속성들 또한 중요한 역할을 맡고 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;alt&lt;/code&gt;&lt;/strong&gt; 속성은 대체 텍스트로서, 이슈로 인해 이미지 랜더링이 어려울 때 이미리를 대신하여 대체 텍스트를 랜더링하는 역할 외에도,
이미지 묘사의 목적으로 사용되는 텍스트로서 스크린 리더에게 전달되어 이미지 대신 낭독되어 접근성을 높일 수 있습니다.&lt;/p&gt;
&lt;p&gt;또한, 검색 엔진이 사이트를 크롤링하고 색인을 생성할 때 이미지 해석을 위한 용도로 사용됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;img src=&amp;quot;/images/NYCpark.png&amp;quot; alt=&amp;quot;Aerial view of Central Park in New York&amp;quot; /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;width, height&lt;/code&gt;&lt;/strong&gt; 는 이미지의 치수를 나타내는 속성이지만, 리플로우(reflow)를 방지할 수 있도록
브라우저에게 이미지의 치수를 전달하여 이미지가 로드되는 동안 적절한 공간을 할당할 수 있도록 도와줍니다.&lt;/p&gt;
&lt;p&gt;만약 뷰포트 기반 반응형 스타일을 위해 CSS를 통해 치수를 정의했다면, &lt;code class=&quot;language-text&quot;&gt;aspect-ratio&lt;/code&gt; 스타일 속성을
추가하여 레이아웃 시프트를 방지하여 &lt;a href=&quot;https://web.dev/i18n/ko/cls/&quot;&gt;Cumulative Layout Shift&lt;/a&gt; 의 감점 요소를 제거할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;img src=&amp;quot;/images/NYCpark.png&amp;quot; width=&amp;quot;640&amp;quot; height=&amp;quot;360&amp;quot; alt=&amp;quot;Aerial view ...&amp;quot; /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;srcset&lt;/code&gt;&lt;/strong&gt; 은 동일한 비율의 다양한 사이즈를 가지는 이미지 소스의 세트입니다. 단일 사이즈라면 &lt;code class=&quot;language-text&quot;&gt;src&lt;/code&gt;를 사용하고,
다양한 이미지 소스를 가지고 있을 때 사용합니다.&lt;/p&gt;
&lt;p&gt;이미지 소스와 그에 따른 원본 사이즈를 명시해주면, 이미지 소스의 선택권을 브라우저에게 위임할 수 있으며
브라우저 스스로 현재 뷰포트에 최적화된 이미지를 선택할 수 있도록 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;img
  srcset=&amp;quot;
    images/NYCpark_small.png   400w,
    images/NYCpark_medium.png  700w,
    images/NYCpark_large.png  1000w
  &amp;quot;
/&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;sizes&lt;/code&gt;&lt;/strong&gt; 는 미디어조건(선택적)과 그에 따라 최적화되어 출력될 이미지 크기를 지정합니다. 이 또한
브라우저에게 이미지 크기 선택을 위임할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;img
  sizes=&amp;quot;
    (max-width: 500px) 444px, 
    (max-width: 800px) 777px, 
    1222px
  &amp;quot;
/&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;webp-이미지-포맷을-사용하자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#webp-%EC%9D%B4%EB%AF%B8%EC%A7%80-%ED%8F%AC%EB%A7%B7%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90&quot; aria-label=&quot;webp 이미지 포맷을 사용하자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;webp 이미지 포맷을 사용하자&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;webp&lt;/code&gt;는 이미지 압축 효과를 강점으로 이미지로 인해 발생하는 웹 사이트의 트래픽을 감소시키고,
로딩 시간을 단축하는 데 중점을 두고 있습니다. &lt;code class=&quot;language-text&quot;&gt;JPEG&lt;/code&gt; 와 유사한 손실 압축 포맷이지만,
화질 저하를 최소화하면서 파일 크기를 &lt;code class=&quot;language-text&quot;&gt;JPEG&lt;/code&gt; 대비 10~80% 정도까지 압축이 가능한 포맷입니다.&lt;/p&gt;
&lt;p&gt;만약 정적 이미지 파일에 대한 접근이 문제가 없다면, 단순히 이미지 포맷을 변경해도 좋고
&lt;code class=&quot;language-text&quot;&gt;next&lt;/code&gt; 와 함께 사용할 수 있는 &lt;a href=&quot;https://github.com/cyrilwanner/next-optimized-images&quot;&gt;next-optimized-images&lt;/a&gt;
와 같은 라이브러리를 사용해서 이미지의 확장자를 &lt;code class=&quot;language-text&quot;&gt;webp&lt;/code&gt; 로 쉽게 변환할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ yarn add next-optimized-images webp-loader&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// next.config.js

const withOptimizedImages = require(&amp;#39;next-optimized-images&amp;#39;)

module.exports = withOptimizedImages({...})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;jsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;picture style={{ objectFit: &amp;#39;cover&amp;#39; }}&amp;gt;
  &amp;lt;source srcSet={require(&amp;#39;../public/NYCpark.png?webp&amp;#39;)} type=&amp;quot;image/webp&amp;quot; /&amp;gt;
  &amp;lt;img src=&amp;quot;/NYCpark.png&amp;quot; /&amp;gt;
&amp;lt;/picture&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;적절한-이미지-사이즈를-사용하자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%81%EC%A0%88%ED%95%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%82%AC%EC%9D%B4%EC%A6%88%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90&quot; aria-label=&quot;적절한 이미지 사이즈를 사용하자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;적절한 이미지 사이즈를 사용하자&lt;/h2&gt;
&lt;p&gt;적절한 이미지 사이즈를 사용해야 하는 이유는 상당히 직관적입니다. 데스크탑에서 사용되는 이미지를 모바일에서
제공하면 2~4배의 데이터를 소비하게 되니, 다양한 장치를 위한 다양한 사이즈의 이미지를 제공해야 한다는 것인데요.&lt;/p&gt;
&lt;p&gt;이에 대한 지표로서, &lt;code class=&quot;language-text&quot;&gt;Lighthouse&lt;/code&gt; 에서는 랜더링된 이미지보다 실제 이미지 사이즈가 크지 않은 것을 이상적인 케이스로
삼고 이에 대한 점수를 부여합니다.&lt;/p&gt;
&lt;p&gt;적절한 이미지 사이즈를 사용하기 위해서는 결국 다양한 사이즈의 물리적인 이미지를 제공하는 것이 해결책이며,
노드 환경에서 사용할 수 있는 &lt;a href=&quot;https://web.dev/serve-responsive-images/&quot;&gt;sharp.js&lt;/a&gt;를 통해
리사이징된 이미지를 만들어 위에서 언급한 &lt;code class=&quot;language-text&quot;&gt;srcset&lt;/code&gt; 속성을 통해 제공해주어야 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;!-- before --&amp;gt;
&amp;lt;img src=&amp;quot;NYCpark-large.jpg&amp;quot; /&amp;gt;

&amp;lt;!-- after --&amp;gt;
&amp;lt;img
  src=&amp;quot;NYCpark-large.jpg&amp;quot;
  srcset=&amp;quot;NYCpark-small.jpg 480w, NYCpark-large.jpg 1080w&amp;quot;
  sizes=&amp;quot;50vw&amp;quot;
/&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;이미지-고착과-개선-방안&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%EB%AF%B8%EC%A7%80-%EA%B3%A0%EC%B0%A9%EA%B3%BC-%EA%B0%9C%EC%84%A0-%EB%B0%A9%EC%95%88&quot; aria-label=&quot;이미지 고착과 개선 방안 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이미지 고착과 개선 방안&lt;/h2&gt;
&lt;p&gt;위에서 이미지를 최적화할 수 있는 코드레벨적으로, 물리적으로의 최적화할 수 있는 방안들을 정리해보았는데요.
하지만, 실무에서 경험상 &lt;code class=&quot;language-text&quot;&gt;webp&lt;/code&gt; 포맷과 다양한 사이즈의 이미지를 제공하지 않거나, 못하겠다 생각한 경우가 많았습니다.&lt;/p&gt;
&lt;p&gt;가령, 유저 혹은 컨텐츠 제공자가 직접 이미지를 업로드하는 경우 확장자를 제한하거나 변환 과정을 거쳐야 하며,
회사 규모에 따라 S3와 같은 클라우드에 업로드 되어 있는 객체에 대해 마음껏 접근하기가 어려운 경우가 많고,
만약 가능하다고 해도 확장자와 이미지 사이즈를 메뉴얼하게 변경한다는 것은 하루 아침에 해결될 문제가 아닙니다.&lt;/p&gt;
&lt;p&gt;이러한 문제를 당근마켓에서는 &lt;a href=&quot;https://medium.com/daangn/lambda-edge%EB%A1%9C-%EA%B5%AC%ED%98%84%ED%95%98%EB%8A%94-on-the-fly-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A6%AC%EC%82%AC%EC%9D%B4%EC%A7%95-f4e5052d49f3&quot;&gt;AWS Lambda@Edge에서 실시간 이미지 리사이즈 &amp;#x26; WebP 형식으로 변환&lt;/a&gt; 하는 방안을 착안하였고
개선점에 대해서 공유해주셨는데요. 개선 방안에 대한 큰 그림을 이해해봅시다.&lt;/p&gt;
&lt;h2 id=&quot;lambdaedge&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#lambdaedge&quot; aria-label=&quot;lambdaedge permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Lambda@edge&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Lambda@edge&lt;/code&gt;는 CloudFront에 전달된 이벤트를 트리거 삼아 람다 함수를 실행할 수 있는 기능입니다.
그 이벤트로는 크게 네 가지가 존재합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 29.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABUklEQVQY01WRyU/CUBCH+WONRw/evWqiHow3lyDhoDckEU0McQmyhLoiVVxYq4WiQEUwtZS+z9eC2yQzmTeT35eZeQGkCSG8gJ9bfdy39ug5ZGyCciRManoCZM/tdRGuLLv8M48TEGOQ647UxrPKYXyZ4+w2W7sL5PMxeCmgR9e4X5xBP49wsL/k9zd3ZrmrZLEsm+HQ8fUBL9i2TU3TaBpNmuYL1U6JRq9O7ilLTY0xeEzTf0hi3SdpFeJU9Av0XgO1fopayhFcD9JqtX6BpmmiKAo13eCtqGBsTdFNhXhPrPKRDPJ6fYiu7GFcHdFObNAIT2LKupUJ8ZSOsLK67jN+gI7jyOkMbLm13XykGJ2nentKOXdCu5CEahYhHe0MS92nsj0nJ89QvkpgVAoYcjOP4QO/b/j3sK4sOWP3crej4WiXDOs3iM/+T38g/v+Lp/0C+WO26QcB8MUAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;implement lambda edge&quot;
        title=&quot;implement lambda edge&quot;
        src=&quot;/static/b7ce02ec5d7cf34c8a52479fa47301ed/c1b63/lambda.png&quot;
        srcset=&quot;/static/b7ce02ec5d7cf34c8a52479fa47301ed/5a46d/lambda.png 300w,
/static/b7ce02ec5d7cf34c8a52479fa47301ed/0a47e/lambda.png 600w,
/static/b7ce02ec5d7cf34c8a52479fa47301ed/c1b63/lambda.png 1200w,
/static/b7ce02ec5d7cf34c8a52479fa47301ed/b67f3/lambda.png 1338w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;우선 유저로부터 전달된 요청이 어떻게 처리되는 지 흐름을 파악해봅시다.
&lt;code class=&quot;language-text&quot;&gt;유저로부터 CloudFront로 요청 (뷰어 요청)&lt;/code&gt;이 전달됩니다. 이 때
CloudFront에서는 요청에 대한 응답이 캐싱되어 있다면 캐싱된 컨텐츠를 반환하고,
없다면 &lt;code class=&quot;language-text&quot;&gt;S3로 컨텐츠에 대한 요청 (오리진 요청)&lt;/code&gt;을 전달합니다.
&lt;code class=&quot;language-text&quot;&gt;S3는 CloudFront로부터 전달받은 요청에 대해 응답 (오리진 응답)&lt;/code&gt;합니다.
CloudFront는 S3로 부터 전달받은 컨텐츠를 캐싱하고, &lt;code class=&quot;language-text&quot;&gt;유저에게 컨텐츠를 응답 (뷰어 응답)&lt;/code&gt;합니다.&lt;/p&gt;
&lt;p&gt;여기서, &lt;code class=&quot;language-text&quot;&gt;lambda@edge&lt;/code&gt;는 뷰어 요청과 응답, 오리진 요청과 응답의 미들웨어와 같은 기능을 하며
응답과 요청을 가공할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;온디멘드-이미지-리사이징&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%98%A8%EB%94%94%EB%A9%98%EB%93%9C-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EB%A6%AC%EC%82%AC%EC%9D%B4%EC%A7%95&quot; aria-label=&quot;온디멘드 이미지 리사이징 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;온디멘드 이미지 리사이징&lt;/h2&gt;
&lt;p&gt;이제 어떻게 실시간 이미지 요청에 대한 리사이징을 구현할 수 있을까요?
결론부터 말씀드리면, 오리진 응답으로 전달받은 컨텐츠에 대해 &lt;code class=&quot;language-text&quot;&gt;lambda@edge&lt;/code&gt;를 통해
리사이징, webp 포맷이 적용된 이미지를 CloudFront로 전달합니다.&lt;/p&gt;
&lt;p&gt;유저로부터 이미지 컨텐츠에 대한 뷰어 요청이 CloudFront에 전달되었다고 생각해봅시다.
CloudFront는 요청에 대한 캐싱되어 있는 컨텐츠 여부를 파악합니다. 만약, 캐싱되어 있다면
빠르게 뷰어 응답으로 이미지 컨텐츠를 반환합니다. 반대로 캐싱되어 있는 컨텐츠가 없다면, S3로 오리진 요청을 보내
이미지 컨텐츠를 오리진 응답으로 반환받습니다.&lt;/p&gt;
&lt;p&gt;이 때 &lt;code class=&quot;language-text&quot;&gt;오리진 응답&lt;/code&gt;을 트리거로 하는 &lt;code class=&quot;language-text&quot;&gt;lambda@edge&lt;/code&gt; 를 통해 S3로 부터 전달받은 이미지를 리사이징하고,
webp 이미지 포맷으로 변경하여 CloudFront에게 반환합니다. CloudFront는 이를 캐싱한 후에
뷰어 응답으로 유저에게 이미지 컨텐츠를 반환합니다.&lt;/p&gt;
&lt;p&gt;결과적으로, &lt;strong&gt;S3에 존재하는 이미지의 사이즈가 크고 webp 포맷이 아닐지라도, 유저는 리사이징된 webp 파일 확장자의
이미지 컨텐츠를 반환받게 됩니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;처음 뷰어 요청으로 지목된 이미지의 경우 이미지 리사이징 과정에서 약간의 시간이 소요되지만,
이후 CloudFront에서 캐싱되어 빠르게 최적화된 이미지를 반환받을 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h2&gt;
&lt;p&gt;통계적으로, 이미지는 웹 페이지에서 평균 68% 정도의 용량을 차지하는 컨텐츠입니다. 그 만큼
웹 최적화와 사용자 경험 지표에 대해 많은 영향을 끼치는 부분인데요. 이미지 최적화는 다른 최적화 작업에 비해
그 결과가 가시적이고 직관적이기 때문에 최적화 작업을 통해 감점 요소를 제거하는 경험을 해보시길 바랍니다.&lt;/p&gt;
&lt;p&gt;온디멘드 이미지 리사이징에 대한 인프라 작업은 따로 포스팅할 예정입니다! 긴 글 읽어주셔서 감사합니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[자바스크립트 프로토타입 톺아보기]]></title><description><![CDATA[…]]></description><link>https://youthfulhps.dev/javascript/javascript-prototype/</link><guid isPermaLink="false">https://youthfulhps.dev/javascript/javascript-prototype/</guid><pubDate>Sat, 19 Mar 2022 00:05:02 GMT</pubDate><content:encoded>&lt;p&gt;자바스크립트는 프로토타입 기반의 객체 지향 프로그래밍 언어입니다. 개인적으로 프로토타입에 대한 큰 그림을 이해하고 있다고 생각했는데,
이직을 준비하면서 프로토타입만 마주하면 작아지는 제 모습을 보게 됩니다.&lt;/p&gt;
&lt;p&gt;자연스레 프로토타입 객체로부터 상속받은 메서드를 사용하면서도, 직접 프로토타입 객체를 다룰 기회는 적었는데요.
어쩌면 가장 익숙하지만 낯선 프로토타입 기반을 다시금 공부해보려 합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1086px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 49.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACr0lEQVQozyWS+09SYRzGzz/VT8bNAwIBBxWOjItBKEgGB09mQiomEHhhlUnDtppZoeu+bivdureyVm1lbS2rtWr1Q1v9CZ9e7Yd3797tu8/zfJ/nlWyyjZbtRgwGE07ZSpu1DavNhSy7cNgV3K52PO6OrTsSCfH7zwf+/tmgJxLAbnPgcbmxyg62bdvO7NwkksFgxmy0kAr5qOkxtIifSJdKl9qF36eieDqxC7DD4RVvP99+vuH7x/voMRXZKGO1WDGbZFpaLLidLqRcspv5kd2cKaYpp6Pke0PM7EuQTkQJh4JEI0HavT7sbQqqqvL91zqf1m8zN5qi0+bE2WoTwFZMxv9Hmh1OcfVojuqeGENijVEBXJzUGc724XQoBANdKO52LK1ufH6Vrz9es/H2Fs1pnbjiRZHttAmXRoNly6k0kYpxYizDWG83iyWNmhbj2FCC2vgAhXGdmbJOeSxNUEQQ8AdYf7/Kq5UGCxMZdnd20GG14xBAk4hty2FBDXD5cI6losZ8vp9CoptSb5CKHufO1Rr3l0tcqg9zeLiXykCSt29Weff0As1DGqM9YXyiEKtZFj2YMQqoNGhTqGpJoSiAQ31M9u+ilAijxYLcPFtm9fQ4Jyf2UOwLUS8OsPbsEl827tIsZ6iKmYTbg01kaBTATZfSkN3L/p4o0yWdpdp+6puFeIWIcLt28wgrpw9y8mA/M9ko1b0JVm7N8+nzPer5NIV4iGYlS8TlwthiwiLA0j7xJbQOP5XiIC+fLbJ89ABTqW4eXDvGkys1rjcO0Mgnmc7s5FA2Tm1E42yjxLn5Mtn+Hi7M5Vio6Dg2MxTFSJnWHRTCYTFQZO3hKR7fmOXuUpXnjxY4XxtkeWqARi7Jkb1xypkYI6kox4X4Yn2cgOKhOZfnxcUpJsX6snD4D/pP0IdSntOOAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;thumbnail&quot;
        title=&quot;thumbnail&quot;
        src=&quot;/static/2be1781c7f40f713d1d34bcebb6f9d99/f3a19/thumbnail.png&quot;
        srcset=&quot;/static/2be1781c7f40f713d1d34bcebb6f9d99/5a46d/thumbnail.png 300w,
/static/2be1781c7f40f713d1d34bcebb6f9d99/0a47e/thumbnail.png 600w,
/static/2be1781c7f40f713d1d34bcebb6f9d99/f3a19/thumbnail.png 1086w&quot;
        sizes=&quot;(max-width: 1086px) 100vw, 1086px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;객체-그리고-프로토타입-객체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EA%B0%9D%EC%B2%B4-%EA%B7%B8%EB%A6%AC%EA%B3%A0-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4&quot; aria-label=&quot;객체 그리고 프로토타입 객체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;객체, 그리고 프로토타입 객체&lt;/h2&gt;
&lt;p&gt;자바스크립트의 모든 객체는 자신의 부모격이 되는 객체와 연결되어 있습니다. 그리고, 자식 객체는 부모격이 되는 객체의 프로퍼티와 메서드를
마치 자신의 프로퍼티와 메서드처럼 사용할 수 있습니다. 객체 지향의 상속과 같은 패턴이죠!
자식 객체는 &lt;code class=&quot;language-text&quot;&gt;hasOwnProperty&lt;/code&gt; 메서드가 없음에도 호출할 수 있는 것처럼요. &lt;strong&gt;여기서, 부모격이 되는 객체를 프로토타입 객체라 부릅니다.&lt;/strong&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const child = {
  name: &amp;#39;Brandon&amp;#39;,
  age: 29,
}

console.log(child.hasOwnProperty(&amp;#39;name&amp;#39;)) // true&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;prototype&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#prototype&quot; aria-label=&quot;prototype permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;[[Prototype]]&lt;/h2&gt;
&lt;p&gt;자식 객체는 어떻게 부모 객체의 프로퍼티와 메서드에 문제없이 접근하고 상속받을 수 있을까요? 자바스크립트의 모든 객체는 &lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt; 이라는 인터널 슬롯을 가지고 있고, 이를 통해 부모 객체를 참조하고 있어서 &lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt; 객체의 데이터 프로퍼티를 상속받을 수 있게 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;__proto__&lt;/code&gt; 접근자 프로퍼티로 접근할 수 있는데, 이는 &lt;code class=&quot;language-text&quot;&gt;Object.getPrototypeOf()&lt;/code&gt; 가 내부적으로 호출되어 프로토타입 객체를 반환해준다고 합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 31.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAxklEQVQY05WQuRLCMAxE8yOQw/HtyAkx10BBxf//0SIZhoaGFDujHclPKzcxzSjlAqKMlAjWWFhtoEXWoVcGXT/+rcb6iPvjieVwgxoNdq3CvlNou5GlNsEqcN8OCOsNfr1CLytCJAyD3gz6An2YOF3hkycYG+B8Qj+8mz2Dpd6ihvKK0/mKYyFkipj4L/NSYFyENh6WF3hObdnLQrlAQogfuR9SrnX12qGRgZkBlIlTJq4X1rE+1sbVQZkR/wNkQPwApSf+BWXcrh8HMRihAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;prototype-dir&quot;
        title=&quot;prototype-dir&quot;
        src=&quot;/static/3700caa950c0dc54dd84f4274ceb95d6/c1b63/prototype-dir.png&quot;
        srcset=&quot;/static/3700caa950c0dc54dd84f4274ceb95d6/5a46d/prototype-dir.png 300w,
/static/3700caa950c0dc54dd84f4274ceb95d6/0a47e/prototype-dir.png 600w,
/static/3700caa950c0dc54dd84f4274ceb95d6/c1b63/prototype-dir.png 1200w,
/static/3700caa950c0dc54dd84f4274ceb95d6/bd9eb/prototype-dir.png 1442w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;prototype-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#prototype-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;prototype 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;prototype 프로퍼티&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;함수 객체는 일단 객체와는 달리, &lt;code class=&quot;language-text&quot;&gt;prototype&lt;/code&gt; 프로퍼티를 소유하고 있습니다.&lt;/strong&gt; 물론 &lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt; 도 가지고 있죠.&lt;/p&gt;
&lt;p&gt;여기서, &lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;prototype&lt;/code&gt; 프로퍼티는 함수가 생성자 함수로서 호출되어 새롭게 객체를 생성할 때 생성된 객체의 프로토타입 객체를 가리키고 있습니다.&lt;/strong&gt;
쉽게 설명하자면, 새롭게 생성된 객체에게 프로토타입 객체를 참조할 수 있도록 전달해주는 역할을 합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 32%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAk0lEQVQY052QUQ6DIBBEOYmAFhQkAitabNp4/1NNV26gHy+Zj83LzApjPGZfkHNEphV+XtDJHkq/INVwGzGHiJQzizx8SE2kL/pnCGsdyvFD/Z7Y3ycLTZM+RVw1R/pgogptJ0ie20nN9Z/NFqo3cHGDWysCbe2HCx0wY2jyu1KhWZhYROuOwhBn6xMG46D44O7kP9NKquPadyxLAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;function-prototype&quot;
        title=&quot;function-prototype&quot;
        src=&quot;/static/aaf45b22c2c7360cd05383919bf65553/c1b63/function-prototype.png&quot;
        srcset=&quot;/static/aaf45b22c2c7360cd05383919bf65553/5a46d/function-prototype.png 300w,
/static/aaf45b22c2c7360cd05383919bf65553/0a47e/function-prototype.png 600w,
/static/aaf45b22c2c7360cd05383919bf65553/c1b63/function-prototype.png 1200w,
/static/aaf45b22c2c7360cd05383919bf65553/a2792/function-prototype.png 1462w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Person(name) {
  this.name = name
}

const brandon = new Person(&amp;#39;brandon&amp;#39;)

console.log(brandon.hasOwnProperty(&amp;#39;prototype&amp;#39;)) // false
console.log(Person.hasOwnProperty(&amp;#39;prototype&amp;#39;)) // true

console.log(Person.prototype === brandon.__proto__) // true&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;constructor-프로퍼티&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#constructor-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0&quot; aria-label=&quot;constructor 프로퍼티 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;constructor 프로퍼티&lt;/h2&gt;
&lt;p&gt;프로토타입 객체는 &lt;code class=&quot;language-text&quot;&gt;constructor&lt;/code&gt; 라는 프로퍼티를 가지고 있습니다. &lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;constructor&lt;/code&gt; 프로퍼티는 객체의 입장에서 자신을 생성한 객체를 가리키게 됩니다.&lt;/strong&gt;
가령, brandon 객체의 프로토타입 객체의 &lt;code class=&quot;language-text&quot;&gt;constructor&lt;/code&gt; 프로퍼티는 &lt;code class=&quot;language-text&quot;&gt;Person&lt;/code&gt; 생성자 함수를 가리키게 되는데요. 아래와 같은 전개를 통해 참조됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Person&lt;/code&gt; 생성자 함수를 통해 &lt;code class=&quot;language-text&quot;&gt;brandon&lt;/code&gt; 객체가 생성된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;brandon&lt;/code&gt; 객체의 프로토타입 객체는 &lt;code class=&quot;language-text&quot;&gt;Person.prototype&lt;/code&gt; 이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;brandon&lt;/code&gt; 객체의 프로토타입 객체 &lt;code class=&quot;language-text&quot;&gt;Person.prototype&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;constructor&lt;/code&gt; 프로퍼티는 자신을 생성한 객체 즉, &lt;code class=&quot;language-text&quot;&gt;Person&lt;/code&gt;을 가리킨다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABZ0lEQVQoz5VSTU/CQBDl//8Azp6NJ6NnQhNj4sEYDaYoLYUWCmXp99Kv7T53t1KgUcFJJpPdnXnz3sz2IIzzGrzuuLhr3rjyS633V3LzxlvQS7wnC7P1G4LJAGSiYWtoCM2hujuAdhr92hwNIFs9obLuQd5v4b7cIBxdI5kOUNeNbFZQVHminBWpgmSMIUkS5HnegimG+4Ms9YMIWV5iufLgLFwQQrCjFJvZK2YjDcuPR9j6A3ZpLIAKeJ6HOI5BRc6+ee8wdI4sy1RSGASIogi+72M8HiuJJRNMv+UVRXEiN01TlGV5kHy8ySgM4TgObNuGZVnK6zxG4M0RbuZIA1c09JVcyU6Cua6rRnDCsAUUzCSgYRiKHdmsQSd3MLU+Pod9kOcr0MjDYuliaprQdR2miO236TKUs6iqSkmQA69rBl5EqChBSbfgeSAKRI5gJPOkfBnbpfy0+nN29tscM/zPJ+6OS8YvIaBWwIeUbg8AAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;person-prototype&quot;
        title=&quot;person-prototype&quot;
        src=&quot;/static/c9177aaf0e0ecc64c60021d5d4a1dd9a/c1b63/person-prototype.png&quot;
        srcset=&quot;/static/c9177aaf0e0ecc64c60021d5d4a1dd9a/5a46d/person-prototype.png 300w,
/static/c9177aaf0e0ecc64c60021d5d4a1dd9a/0a47e/person-prototype.png 600w,
/static/c9177aaf0e0ecc64c60021d5d4a1dd9a/c1b63/person-prototype.png 1200w,
/static/c9177aaf0e0ecc64c60021d5d4a1dd9a/d61c2/person-prototype.png 1800w,
/static/c9177aaf0e0ecc64c60021d5d4a1dd9a/97a96/person-prototype.png 2400w,
/static/c9177aaf0e0ecc64c60021d5d4a1dd9a/9ade0/person-prototype.png 3002w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Person(name) {
  this.name = name
}

//Person 생성자 함수를 통해 brandon객체가 생성된다.
const brandon = new Person(&amp;#39;Brandon&amp;#39;)

//brandon 객체의 프로토타입 객체는 Person.prototype이다.
console.log(brandon.__proto__ === Person.prototype)

//brandon 객체의 프로토타입 객체 Person.prototype의 constructor 프로퍼티는 자신을 생성한 객체
//즉, Person을 가리킨다.
console.log(Person.prototype.constructor === Person)

// brandon 객체를 생성한 객체는 Person() 생성자 함수이다.
console.log(brandon.constructor === Person)

// Person() 생성자 함수를 생성한 객체는 Function() 생성자 함수이다.
console.log(Person.constructor === Function)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;프로토타입-체인&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8&quot; aria-label=&quot;프로토타입 체인 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;프로토타입 체인&lt;/h2&gt;
&lt;p&gt;자바스크립트는 특정 객체의 프로퍼티나 메서드에 접근하려고 할 떄 해당 객체에 접근하려는 프로퍼티 또는 메서드가 없다면,
&lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt; 이 가리키는 링크를 따라 자신의 부모 객체, 즉 프로토타입 객체의 프로퍼티 또는 메서드를 검색하게 됩니다.
&lt;strong&gt;이러한 상속 개념의 패턴을 구현하기 위한 매커니즘이 프로토타입 체인이라 합니다.&lt;/strong&gt; 변수를 검색하는 메커니즘인
실행컨텍스트의 스코프체인과 유사한 역할과 동작을 띄고 있네요.&lt;/p&gt;
&lt;p&gt;상단의 예시에서 &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; 라는 객체는 &lt;code class=&quot;language-text&quot;&gt;hasOwnProperty&lt;/code&gt; 메서드를 가지고 있지 않지만, 호출이 가능했던 것은 &lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt; 이 링크를 따라
&lt;code class=&quot;language-text&quot;&gt;Object.prototype&lt;/code&gt; 를 참조하여 &lt;code class=&quot;language-text&quot;&gt;hasOwnProperty&lt;/code&gt; 메서드를 호출한 동작에 대한 근거가 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const child = {
  name: &amp;#39;Brandon&amp;#39;,
  age: 29,
}

//child 객체는 hasOwnProperty 메서드를 가지고 있지 않지만, 호출이 가능하다.
console.log(child.hasOwnProperty(&amp;#39;name&amp;#39;)) // true

//child 객체의 프로토타입 객체는 Object.prototype이다.
console.log(child.__proto__ === Object.prototype) // true

//Object.prototype은 hasOwnProperty 메서드를 소유하고 있다.
console.log(Object.prototype.hasOwnProperty(&amp;#39;hasOwnProperty&amp;#39;)) // true&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;프로토타입-체인의-종점&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8%EC%9D%98-%EC%A2%85%EC%A0%90&quot; aria-label=&quot;프로토타입 체인의 종점 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;프로토타입 체인의 종점&lt;/h2&gt;
&lt;p&gt;그렇다면, &lt;strong&gt;프로토타입 체인의 마지막 링크는 어떤 객체를 가리키고 있을까요?&lt;/strong&gt;
사실, 이 질문은 프로토타입을 깊게 이해하기 전 면접에서 받았던 질문인데요. 제가 프로토타입을 깊게 공부하도록 만든 질문이기도 합니다.&lt;/p&gt;
&lt;p&gt;우선, 객체를 어떻게 생성하는 지부터 이야기해볼까요? 쉽게 객체를 정의할 수 있는 객체 리터럴 방식, 생성자 함수 그리고 &lt;code class=&quot;language-text&quot;&gt;Object()&lt;/code&gt; 생성자 함수로
객체를 정의합니다. 여기서 &lt;strong&gt;객체 리터럴 방식은 결국 &lt;code class=&quot;language-text&quot;&gt;Object()&lt;/code&gt; 생성자 함수로 생성하는 것을 단순화한 축약 표현&lt;/strong&gt;이니, 내부적으로는 생성자 함수 그리고 &lt;code class=&quot;language-text&quot;&gt;Object()&lt;/code&gt; 생성자 함수를
통해 객체를 정의한다고 볼 수 있겠네요.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Object()&lt;/code&gt; 생성자 함수도 함수이니, &lt;code class=&quot;language-text&quot;&gt;prototype&lt;/code&gt; 프로퍼티를 소유하고 있습니다. 즉, 아래와 같이 참조가 전개됩니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABYklEQVQoz5VSTU+DQBDt//8BevZoPOlRT00bTx40aj9iCxGw0ELL14IssPucXVpKjdo6yWMC83gz83Z7oJBSQIqaIPagb1ShrOoSp0bvL7Js1HQ+FT31Iw8mWM/6WM+HGpE5RLF83or+1OiX5mpC9ahXD6jMG6xH13AfrxC/XiI17iDIBl0vc1QFa8CZtkKQLXmeg3PeiukJ2xfCJoyRFyVcbwXbWSAIAmRZhsB+gTUawJncwybkLCahUtfTNNUc1aDxsOMVLwr4/gpRFBIxQRiGmE6nUNSShhXb9YqCH6zLGE1eVfuVd8ariOMYjuPAtm2YpqkhS4bIdzSyyEMUbrRIkiQ6u67bmbBzQjtBy7Iwn80wHo+xXHoo329hDs7w1j9H9HRBoi4+Fh4Mw9AclVsPv5+S6qTGV1CGq4ORPEbJfFRZAPG5IbJAXdctZ7fugWBX9FhIHLk23Q/ynxe5a5fKX72lVxBa0ii8AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;object-prototype&quot;
        title=&quot;object-prototype&quot;
        src=&quot;/static/f3a1d7b41af93bf4e9fac96e4613e42a/c1b63/object-prototype.png&quot;
        srcset=&quot;/static/f3a1d7b41af93bf4e9fac96e4613e42a/5a46d/object-prototype.png 300w,
/static/f3a1d7b41af93bf4e9fac96e4613e42a/0a47e/object-prototype.png 600w,
/static/f3a1d7b41af93bf4e9fac96e4613e42a/c1b63/object-prototype.png 1200w,
/static/f3a1d7b41af93bf4e9fac96e4613e42a/d61c2/object-prototype.png 1800w,
/static/f3a1d7b41af93bf4e9fac96e4613e42a/97a96/object-prototype.png 2400w,
/static/f3a1d7b41af93bf4e9fac96e4613e42a/7f486/object-prototype.png 3010w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;프로토타입 체인을 따라서 더 올라가볼까요? &lt;code class=&quot;language-text&quot;&gt;Object()&lt;/code&gt; 생성자 함수 또한 &lt;code class=&quot;language-text&quot;&gt;[[Prototype]]&lt;/code&gt; 를 가지고 있고 다음과 같이 참조가 전개됩니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Object&lt;/code&gt; 생성자 함수를 통해 &lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; 객체가 생성된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; 객체의 프로토타입 객체는 &lt;code class=&quot;language-text&quot;&gt;Object.prototype&lt;/code&gt; 이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;child&lt;/code&gt; 객체의 프로토타입 객체 &lt;code class=&quot;language-text&quot;&gt;Object.prototype&lt;/code&gt; 의 &lt;code class=&quot;language-text&quot;&gt;constructor&lt;/code&gt; 프로퍼티는 자신을 생성한 객체 즉, &lt;code class=&quot;language-text&quot;&gt;Object&lt;/code&gt; 생성자 함수를 가리킨다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Object.__proto__&lt;/code&gt; 는 &lt;code class=&quot;language-text&quot;&gt;Function.prototype&lt;/code&gt; 이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Function.prototype.__proto__&lt;/code&gt; 는 &lt;code class=&quot;language-text&quot;&gt;Object.prototype&lt;/code&gt; 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB4ElEQVQoz22TSW/bQAyF9f/vPfTSUxqggIFc+g/S9BInjRM38lIvsuJYjixptMvavs6Ma9VpTYDQiOI88vFRRtu2KGv3IYF1i7+UbvURqzvpt7RFgMo45p2ainX3/5yNLpA5lLMril9XvPQvSUY9immPNnk5fG8qqn1OXebymen3ozVN052Nv+iHQJwkiDBGiBDHcfA8jzTLScUW2/zGyrzBfr5mt56gcIQQ7HY70jSlKIpDh6etV1VFGEqw7Zb1eq2BR6MRURTRyJQj8bKs2O/33d2yLHWOwRmr6xpns2FlWRpUAYYiIE1ChL8jEh5FnpEkqe4sz3N839fd6g7LqqaqGwkkXfIoZGUFtFgsMM1nHocmjZjh//jE7Pojr98/kK5u2Gw9rOWSyWTCcDgkCAKMOvMQP7+wvf/Mun/B7uGCZPqVqiw0de1RTBq6ZL5F5Fqk3lJyDuUIWj0iRVfRV+IY1DmEY8L1I749INk8SWXmxHGEbdty4C7Om6Rj3+M+XOIMegRPl7RifFyed+My2v9CsnhNp7Lve4zGU91Z/DogsGVh6446fXu3f90eog/NwdUeaBolGymKmuF8PpeimHLOzdnF/teMcwlKZbVbrutqcSyptiqiizeHwqd/yKn9BhHXSX6+PIjLAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;object-prototype-chain&quot;
        title=&quot;object-prototype-chain&quot;
        src=&quot;/static/88932170cb27eea840bf5e2f6a3d29d1/c1b63/object-prototype-chain.png&quot;
        srcset=&quot;/static/88932170cb27eea840bf5e2f6a3d29d1/5a46d/object-prototype-chain.png 300w,
/static/88932170cb27eea840bf5e2f6a3d29d1/0a47e/object-prototype-chain.png 600w,
/static/88932170cb27eea840bf5e2f6a3d29d1/c1b63/object-prototype-chain.png 1200w,
/static/88932170cb27eea840bf5e2f6a3d29d1/d61c2/object-prototype-chain.png 1800w,
/static/88932170cb27eea840bf5e2f6a3d29d1/97a96/object-prototype-chain.png 2400w,
/static/88932170cb27eea840bf5e2f6a3d29d1/1307b/object-prototype-chain.png 3000w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// Object 생성자 함수를 통해 child 객체가 생성된다.
const child = {
  name: &amp;#39;Brandon&amp;#39;,
}

// child 객체의 프로토타입 객체는 Object.prototype이다.
console.log(child.__proto__ === Object.prototype)

// child 객체의 프로토타입 객체 Object.prototype의 constructor 프로퍼티는 자신을 생성한 객체
//즉, Object 생성자 함수를 가리킨다.
console.log(Object.prototype.constructor === Object)

// Object.__proto__ 는 Function.prototype이다.
console.log(Object.__proto__ === Function.prototype)

// Function.prototype.__proto__ 는 Object.prototype이다.
console.log(Function.prototype.__proto__ === Object.prototype)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이번엔 객체를 생성하는 또 다른 방법으로 &lt;strong&gt;생성자 함수를 통해 생성된 객체의 프로토타입 체인에 대한 전개를 확인해 보겠습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;우선, 생성자 함수를 선언하는 단계부터 간단하게 알아보자면, 함수 선언식, 표현식 그리고 &lt;code class=&quot;language-text&quot;&gt;Function()&lt;/code&gt; 생성자 함수를 통해 함수를 선언할 수 있습니다.
함수 표현식은 가시적으로도 함수 리터럴 방식을 사용하고 있습니다. &lt;strong&gt;함수 선언식의 경우 자바스크립트 엔진이 내부적으로 함수 기명 표현식으로 변환되어 사용됩니다.
즉, 함수 선언식, 표현식 모두 함수 리터럴 방식을 사용하고 있다고 할 수 있습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;여기서 함수 리터럴 방식은 &lt;code class=&quot;language-text&quot;&gt;Function()&lt;/code&gt; 생성자 함수를 통해 함수를 선언하는 것을 단순화한 표현이니, 결국 함수 선언 방법 세 가지는 모두 &lt;code class=&quot;language-text&quot;&gt;Function()&lt;/code&gt; 생성자 함수를
통해 선언되는 것과 같습니다. 그럼, &lt;code class=&quot;language-text&quot;&gt;Function()&lt;/code&gt; 생성자 함수의 프로토타입 체인이 어떻게 전개되는 지 보겠습니다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Person&lt;/code&gt; 생성자 함수를 통해 &lt;code class=&quot;language-text&quot;&gt;brandon&lt;/code&gt; 객체가 생성된다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;brandon&lt;/code&gt; 객체의 프로토타입 객체는 &lt;code class=&quot;language-text&quot;&gt;Person.prototype&lt;/code&gt; 이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Person&lt;/code&gt; 생성자 함수의 프로토타입 객체는 &lt;code class=&quot;language-text&quot;&gt;Function.prototype&lt;/code&gt; 이다.&lt;/li&gt;
&lt;li&gt;&lt;code class=&quot;language-text&quot;&gt;Function.prototype&lt;/code&gt; 의 프로토타입 객체는 &lt;code class=&quot;language-text&quot;&gt;Object.prototype&lt;/code&gt; 이다.&lt;/li&gt;
&lt;/ul&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Person(name) {
  this.name = name
}

// Person 생성자 함수를 통해 brandon 객체가 생성된다.
const brandon = new Person(&amp;#39;Brandon&amp;#39;)

// brandon 객체의 프로토타입 객체는 Person.prototype이다.
console.log(brandon.__proto__ === Person.prototype)

// Person 생성자 함수의 프로토타입 객체는 Function.prototype이다.
console.log(Person.__proto__ === Function.prototype)

// Function.prototype의 프로토타입 객체는 Object.prototype이다.
console.log(Function.prototype.__proto__ === Object.prototype)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;객체 선언 방식에 대한 프로토타입 체인을 거슬러 올라가 봤는데요. 객체 리터럴, 생성자 함수 방식이나 결국은 &lt;strong&gt;모든 객체의 부모 객체인 &lt;code class=&quot;language-text&quot;&gt;Object.prototype&lt;/code&gt; 객체에서
프로토타입 체인이 끝나는 것을 확인할 수 있습니다. 그래서, 모든 객체의 프로토타입 체인의 종점은 &lt;code class=&quot;language-text&quot;&gt;Object.prototype&lt;/code&gt; 객체가 됩니다.&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;프로토타입-체인의-동작&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EC%B2%B4%EC%9D%B8%EC%9D%98-%EB%8F%99%EC%9E%91&quot; aria-label=&quot;프로토타입 체인의 동작 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;프로토타입 체인의 동작&lt;/h2&gt;
&lt;p&gt;프로토타입 체인은 객체의 프로퍼티를 참조할 때 해당 객체에 프로퍼티가 없는 경우 프로토타입 체인이 동작합니다.
만약, 객체의 프로퍼티에 값을 할당하는 경우는 프로퍼티가 있다면 재할당을, 프로퍼티가 없다면 동적으로 할당되어 참조가 가능하기 때문에
이런 경우에는 프로토타입 체인이 동작하지 않습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Person(name) {
  this.name = name
}

Person.prototype.job = &amp;#39;junior developer&amp;#39;

const brandon = new Person(&amp;#39;Brandon&amp;#39;)
const max = new Person(&amp;#39;Max&amp;#39;)

max.job = &amp;#39;senior developer&amp;#39;

console.log(brandon.job)
console.log(max.job)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;프로토타입-객체의-확장&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4%EC%9D%98-%ED%99%95%EC%9E%A5&quot; aria-label=&quot;프로토타입 객체의 확장 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;프로토타입 객체의 확장&lt;/h2&gt;
&lt;p&gt;위의 예제를 보면, &lt;code class=&quot;language-text&quot;&gt;Person.prototype&lt;/code&gt; 에 ‘job’이라는 새로운 프로퍼티를 추가한 것을 확인할 수 있습니다.
프로토타입 객체는 객체이기 때문에 프로토타입 체인에 즉시 반영되는 프로퍼티를 추가/삭제할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function Person(name) {
  this.name = name
}

const brandon = new Person(&amp;#39;Brandon&amp;#39;)

Person.prototype.sayName = function() {
  console.log(this.name)
}

brandon.sayName()&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;추가적으로, 자바스크립트에는 객체 이외에도 기본형 값들에 대한 원시 타입이 존재합니다. 기본형들은 불면이며 메서드를 가지지 않는다는 점에서
객체와 구분되는데, 기본형인 &lt;code class=&quot;language-text&quot;&gt;string&lt;/code&gt; 의 경우 메서드를 가지고 있는 것처럼 동작합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;#39;primitive&amp;#39;.charAt(3) // &amp;quot;m&amp;quot;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;charAt은 분명 기본형 &lt;code class=&quot;language-text&quot;&gt;string&lt;/code&gt; 의 메서드가 아니지만, 자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환합니다.
만약, 기본형에서 &lt;code class=&quot;language-text&quot;&gt;charAt&lt;/code&gt; 에 접근하게 되면 자바스크립트는 기본형을 &lt;code class=&quot;language-text&quot;&gt;String&lt;/code&gt; 객체로 래핑하고, 메서드를 호출하고 마지막에 래핑할 때 사용했던 객체를
버립니다. &lt;strong&gt;즉, 원시 타입으로 프로퍼티나 메서드를 참조하면 관련된 객체를 래핑하여 프로토타입 객체를 공유하게 됩니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;결론적으로, 원시 타입을 확장하고자 한다면 객체가 아닌 원시 타입에 프로퍼티나 메서드를 추가할 수는 없지만, 원시 타입과 관련된 객체의 프로토타입에 프로퍼티나 메서드를 추가하면 원시 타입에서도 공유받아 사용할 수 있게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const str = &amp;#39;string&amp;#39;

str.sayValue = function() {
  console.log(&amp;#39;string&amp;#39;)
}

str.sayValue() // TypeError: str.sayValue is not a function&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const str = &amp;#39;string&amp;#39;

String.prototype.sayValue = function() {
  console.log(&amp;#39;string&amp;#39;)
}

str.sayValue() // &amp;quot;string&amp;quot;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;프로토타입-객체의-변경&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EB%B3%80%EA%B2%BD&quot; aria-label=&quot;프로토타입 객체의 변경 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;프로토타입 객체의 변경&lt;/h2&gt;
&lt;p&gt;프로토타입 객체는 결정된 프로토타입 객체를 임의로 다른 객체로 변경할 수 있는데요. 프로토타입 객체의 변경 시점을 기준으로
이전에 생성된 객체는 기존 프로토타입 객체에, 이후에 생성된 객체는 변경된 프로토타입 객체에 바인딩되는 것을 주의해야 합니다.&lt;/p&gt;
&lt;p&gt;프로토타입 객체가 변경이 되면, &lt;code class=&quot;language-text&quot;&gt;Person&lt;/code&gt; 생성자 함수의 프로토타입 객체가 일반 객체로 변경되면서, &lt;code class=&quot;language-text&quot;&gt;Person.prototype.constructor&lt;/code&gt; 가
제거되고, 프로토타입 체이닝에 의해 &lt;code class=&quot;language-text&quot;&gt;Object.prototype.constructor&lt;/code&gt; 인 &lt;code class=&quot;language-text&quot;&gt;Object&lt;/code&gt; 생성자 함수로 변경이 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABxklEQVQoz31TTW/TQBDN//8FcOTCAaoiuKBegKqAIsEhwaFN49hO/L22s/Y2/ow/Xme3MZFQmyeNvF7Nzr5583aCMxiGQYVEURQoy/K432Po/wvak5jgeOilkNjv93AcB1EUIQhCdGcITAacR9u2yLIMjDEkux02Gwt88wtiO0Vi/AS3puDmd1SJ/sRQVu3oUHM4oJXRdWiEUGuJjv4D34dlmjApFtofFOYV+s0nsPl7pLeXaM0P6NjvY8uEWvsIMXtDCW/Brl9BTF+jdr6qhJ70ycReRZRw+AFDP5xpuaxrCFtDeX+D9O4HogXRj/8i82/RNI1MQxqsEVhzxPYCiXtHrA+KeZqmqKpKXTrqPeGkS1rUiDUqslphl1cIGWlle0o33/eQcw87fwXBTPquadqFKsQ5V9MXJJG8QBVsSL/YNBBbBph+D5fWeZ5TsZCK+Vgulyqx7iTXJ9TEfLSJhByaHN4/DVtKqChKKsTjGK7nwTDW0PU1wsBHFc4RLr/A0a6Q6N/AE4YwZLBtG9vtFpZlnVoeFyMKMq9sRbbrui4eRIbGuUY4e4dgdoHK/IymeiALceXL0Z8nHz5j5BdfDk5tPzdhiUf5dEnVbe0+zQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;prototype-change&quot;
        title=&quot;prototype-change&quot;
        src=&quot;/static/708f924117a12ce9baf29cd46b544367/c1b63/prototype-change.png&quot;
        srcset=&quot;/static/708f924117a12ce9baf29cd46b544367/5a46d/prototype-change.png 300w,
/static/708f924117a12ce9baf29cd46b544367/0a47e/prototype-change.png 600w,
/static/708f924117a12ce9baf29cd46b544367/c1b63/prototype-change.png 1200w,
/static/708f924117a12ce9baf29cd46b544367/d61c2/prototype-change.png 1800w,
/static/708f924117a12ce9baf29cd46b544367/97a96/prototype-change.png 2400w,
/static/708f924117a12ce9baf29cd46b544367/0e909/prototype-change.png 3008w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;프로토타입 객체를 임의로 변경해야 하는 일이 있을 지는 의문이지만, 사이드 이펙트는 없을 지 걱정부터 됩니다.&lt;/p&gt;
&lt;h2 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h2&gt;
&lt;p&gt;가장 익숙한 것이 낯설게 느껴지는 프로토타입에 대한 공부가 아니었나 싶습니다. 전개를 쉽게 이해하고자 그림을 그려가면서 표현을 해봤는데요.
정확하게 표현을 한 것인지 잘못된 부분은 없는 지 다시 한번 확인해보면서 자주 꺼내볼 수 있는 글을 적게되어 매우 뿌듯합니다 :)
글에서 잘못된 이해로 인해 표현이 적절하지 않은 부분이 있다면 언제든 지적해주시면 감사하겠습니다.&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://poiemaweb.com/js-prototype&quot;&gt;https://poiemaweb.com/js-prototype&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[Incremental Static Regeneration 타임라인 이해하기]]></title><description><![CDATA[최근 CRA…]]></description><link>https://youthfulhps.dev/nextjs/next-isr/</link><guid isPermaLink="false">https://youthfulhps.dev/nextjs/next-isr/</guid><pubDate>Sat, 08 Jan 2022 21:06:16 GMT</pubDate><content:encoded>&lt;p&gt;최근 CRA 프로젝트를 넥스트로 이관하는 작업이 한창입니다. 넥스트는 서버 사이드 랜더링과 동시에 클라이언트 사이드 랜더링을
동시에 지원하기 때문에 점진적 이관이 가능했죠. 단순히 빌드가 실패되는 문제들을 제외하면요.&lt;/p&gt;
&lt;p&gt;이후 적절한 &lt;code class=&quot;language-text&quot;&gt;getStaticProps&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;getStaticPaths&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;getServerSideProps&lt;/code&gt; 를 통해 서버 사이드에서 데이터 패칭이
이루어질 수 있도록 작업했습니다.&lt;/p&gt;
&lt;p&gt;작업할 때 서버 사이드 랜더링(&lt;code class=&quot;language-text&quot;&gt;Server Side Rendering&lt;/code&gt;)보다는 정적 사이트 생성(&lt;code class=&quot;language-text&quot;&gt;Static Site Generation&lt;/code&gt;) 방식으로
접근하려 했습니다.&lt;/p&gt;
&lt;h2 id=&quot;ssr-vs-ssg&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#ssr-vs-ssg&quot; aria-label=&quot;ssr vs ssg permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;SSR vs SSG&lt;/h2&gt;
&lt;p&gt;넥스트는 서버 사이드에서 데이터 패칭을 할 수 있도록 두 가지 함수를 제공합니다.
두 함수의 가장 큰 차이점은 단연 데이터 패칭의 시점인데요.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;getServerSideProps&lt;/code&gt;의 경우&lt;/strong&gt;, 클라이언트에서 요청이 들어올 때
데이터 패칭을 통해 외부 데이터를 json파일에 담고, 마크업을 생성하여 클라이언트로 전달합니다.&lt;/p&gt;
&lt;p&gt;반대로 &lt;strong&gt;&lt;code class=&quot;language-text&quot;&gt;getStaticProps&lt;/code&gt;의 경우&lt;/strong&gt;, 빌드 시 한번만 모든 페이지의 마크업과 데이터 패칭을 통해
얻은 외부 데이터를 json파일에 담아두고, 요청 때 캐싱되어 있는 마크업, json 파일을 클라이언트로 전달합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 56.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABPUlEQVQoz41S6cqCUBD1/Z/DF/GfIIhoblAklRu5YJnaOn1nYC721bcMnGZus9xzrqPRlz0eD/qP3e/3lxiQXvGaBKvVimzbJtd1yfd9RhiGdD6fudHzPM4vl0taLBbkOA4FQUBxHDNeBgLDMNA0TTzgcrmwH8eRJI/z9Xpl3G43xRBn5ISl9pfcT3m5YJ5TDPGTJAnTX6/XVJYl1XXNHkxgYNE0DVVVRWmass+yjOuOxyOrUwwRRFFEuq7z20BG3/f8phgEA5vtdquad7sdD8zznDabDe33+3fJp9OJgTPeUth9MgyGAtS9SZbgcDjwTUVR8M2IIVPkyMq0bcsKMBQ9kD9fHW0+HU2QgIECNM5rsC6mafJ6WZZFhmEopkryHF3XMbP5EksOhg8BgBnqoEhqFcPvTT/999uKSe4JX0VSsavrbWQAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;comparison&quot;
        title=&quot;comparison&quot;
        src=&quot;/static/cd29985dffb91fc65d52899ac3d1fb4c/c1b63/comparison.png&quot;
        srcset=&quot;/static/cd29985dffb91fc65d52899ac3d1fb4c/5a46d/comparison.png 300w,
/static/cd29985dffb91fc65d52899ac3d1fb4c/0a47e/comparison.png 600w,
/static/cd29985dffb91fc65d52899ac3d1fb4c/c1b63/comparison.png 1200w,
/static/cd29985dffb91fc65d52899ac3d1fb4c/73a2e/comparison.png 1439w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;정적-생성을-지향했던-이유&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%95%EC%A0%81-%EC%83%9D%EC%84%B1%EC%9D%84-%EC%A7%80%ED%96%A5%ED%96%88%EB%8D%98-%EC%9D%B4%EC%9C%A0&quot; aria-label=&quot;정적 생성을 지향했던 이유 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;정적 생성을 지향했던 이유&lt;/h2&gt;
&lt;p&gt;정적 생성된 페이지는 클라이언트의 요청 시 상당히 빠르게 제공됩니다.
빌드 시 생성한 마크업과 데이터가 담긴 json을 제공하기 때문인데요.&lt;/p&gt;
&lt;p&gt;이는 &lt;code class=&quot;language-text&quot;&gt;Time to First Byte (TTFB)&lt;/code&gt;를 크게 줄일 수 있을 뿐만 아니라, &lt;code class=&quot;language-text&quot;&gt;First Input Delay (FID)&lt;/code&gt;와 같은 Web Vital Score를 개선하는 데 큰 도움이 됩니다.&lt;/p&gt;
&lt;p&gt;좋지 못한 네트워크 상에서 비교 측정해봤을 때 초 단위로 측정되는 &lt;code class=&quot;language-text&quot;&gt;SSR&lt;/code&gt;에 반해 &lt;code class=&quot;language-text&quot;&gt;SSG&lt;/code&gt;는 밀리 초 단위로
측정되는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 725px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 14.666666666666666%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAfUlEQVQI143PQQ6CMABEUa4BBpQihQLaFqWAJnVrNJp4/8N8yw26eLufSSYZThY7TvSDphQ1RVGRp4I8i5SW7Isjg7nQ9ppkvXte7y9Xt7DLDrRzh/0Z9EdHMaFtrORhJ57ek5z1yC2MbqTsEKqmXToap6JsbaUkc3joJ8cfZudbtKRgxOIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;ttfb-ssr&quot;
        title=&quot;ttfb-ssr&quot;
        src=&quot;/static/b48a30b5a039e12be6c87bd8e1198e25/a0209/ttfb-ssr.png&quot;
        srcset=&quot;/static/b48a30b5a039e12be6c87bd8e1198e25/5a46d/ttfb-ssr.png 300w,
/static/b48a30b5a039e12be6c87bd8e1198e25/0a47e/ttfb-ssr.png 600w,
/static/b48a30b5a039e12be6c87bd8e1198e25/a0209/ttfb-ssr.png 725w&quot;
        sizes=&quot;(max-width: 725px) 100vw, 725px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 725px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 14.666666666666666%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgElEQVQI15XNSw6CMAAAUc4hUQpUaBHbEiEG5Rc3QiAuvP9dxp7A6OJtZwJXNRh3QR4VkUg5hAn73R/CmDTTnKuaRCqCednoxwdCSEQqMYvFbt76nVkN7uXIb5q6KHk/Z5rSENy7kW6YcP4QxQnqqlFt8RPd5mTDgDtZ5q6n8uEPSkpb6WVDb5cAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;ttfb-ssg&quot;
        title=&quot;ttfb-ssg&quot;
        src=&quot;/static/7fc71abf4225f99ff2b462510ff84e9b/a0209/ttfb-ssg.png&quot;
        srcset=&quot;/static/7fc71abf4225f99ff2b462510ff84e9b/5a46d/ttfb-ssg.png 300w,
/static/7fc71abf4225f99ff2b462510ff84e9b/0a47e/ttfb-ssg.png 600w,
/static/7fc71abf4225f99ff2b462510ff84e9b/a0209/ttfb-ssg.png 725w&quot;
        sizes=&quot;(max-width: 725px) 100vw, 725px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;추가적으로 클라이언트의 요청 횟수에 상관없이 서버측은 빌드 시 제공된 한번의 응답이면 충분하게 됩니다.&lt;/p&gt;
&lt;h2 id=&quot;증분-정적-재생성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A6%9D%EB%B6%84-%EC%A0%95%EC%A0%81-%EC%9E%AC%EC%83%9D%EC%84%B1&quot; aria-label=&quot;증분 정적 재생성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;증분 정적 재생성&lt;/h2&gt;
&lt;p&gt;그러나 한 가지 염두해야 할 것이 있다면, 제공하는 서비스 특성상 데이터가 실시간으로 업데이트되어야 한다면
&lt;strong&gt;빌드되는 시점에 받은 외부 데이터가 최신화된 데이터로서 유효하지 않다는 점&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;그래도 넥스트가 정적 생성을 권장하는 근거가 있다면, &lt;a href=&quot;https://vercel.com/docs/concepts/next.js/incremental-static-regeneration&quot;&gt;증분 정적 재생성&lt;/a&gt;
(Incremental Static Regeneration)라 생각이 듭니다.&lt;/p&gt;
&lt;p&gt;위 문서를 읽어보면 증분 정적 재생성을 하기 위해서는 &lt;code class=&quot;language-text&quot;&gt;getStaticProps&lt;/code&gt;의 반환 프로퍼티로 &lt;code class=&quot;language-text&quot;&gt;revalidate&lt;/code&gt; 값을
설정하면, 설정된 초 단위 마다 넥스트에서 데이터 유효성 검사를 진행할거다 정도로 쉽게 받아드릴 수 있습니다.&lt;/p&gt;
&lt;p&gt;하지만, &lt;code class=&quot;language-text&quot;&gt;revalidate&lt;/code&gt; 가 되는 시점과 트리거에 대한 이해가 필연적입니다.&lt;/p&gt;
&lt;h2 id=&quot;증분-정적-재생성의-타임라인&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A6%9D%EB%B6%84-%EC%A0%95%EC%A0%81-%EC%9E%AC%EC%83%9D%EC%84%B1%EC%9D%98-%ED%83%80%EC%9E%84%EB%9D%BC%EC%9D%B8&quot; aria-label=&quot;증분 정적 재생성의 타임라인 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;증분 정적 재생성의 타임라인&lt;/h2&gt;
&lt;p&gt;증분 정적 재생성(&lt;code class=&quot;language-text&quot;&gt;ISR&lt;/code&gt;)은 &lt;code class=&quot;language-text&quot;&gt;SSG&lt;/code&gt; 과 동일한 넥스트 API(&lt;code class=&quot;language-text&quot;&gt;getStaticProps&lt;/code&gt;)로 정적 페이지를 생성합니다. &lt;code class=&quot;language-text&quot;&gt;revalidate&lt;/code&gt; 값을 설정하여
생성된 페이지를 업데이트하도록 알리는데요.&lt;/p&gt;
&lt;p&gt;단순하게 &lt;code class=&quot;language-text&quot;&gt;revalidate&lt;/code&gt;값이 20초라면, 특정 페이지에 대한 첫 요청이
들어온 이후 20초마다 한번 씩 유효성 검사를 한다는 것으로 오해할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABH0lEQVQoz61TYUvDMBDN//8XokJVVBy4KTKdOK1MsOyLX4TpNtiMraut2G1tLs80JVtaql/c0Qf37iWvl0vLsOFgJpFSath5FVWtuq9kaBv/FlWtbm1hqOqkRJIEUuQzjsDfOdIshVC1WTjDh0Ku5zU/8BGpNaq3Yo+CMWe1b04EltF8xZfxQsNEEn6Dkqz2BMyYPSdDuL6HXtDH9fgely+3cPmjxtXrnYbh7UEXnaGrcg830wf0+RMkUbnDbuLhML7AcdiGMznFzugEB8E59v0z7I4amu/xFpy3JrYGR5o70ya2Jw20xh1QJtaGQgjQXKx7T9XztSiNQFp6mh/fPrGSyHS4un5rwKSZNfA8/4PnFwpZeLC6b+k/nG36T/kBXvdWIswmZzoAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;wrong&quot;
        title=&quot;wrong&quot;
        src=&quot;/static/2216cba94a9164a33086e2c74a9323f9/c1b63/wrong.png&quot;
        srcset=&quot;/static/2216cba94a9164a33086e2c74a9323f9/5a46d/wrong.png 300w,
/static/2216cba94a9164a33086e2c74a9323f9/0a47e/wrong.png 600w,
/static/2216cba94a9164a33086e2c74a9323f9/c1b63/wrong.png 1200w,
/static/2216cba94a9164a33086e2c74a9323f9/1bba3/wrong.png 1433w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;정확한 플로우는 공식 문서에서 다음과 같이 설명하고 있습니다. 이제, 이 플로우를 하나 씩 살펴 봅시다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABM0lEQVQoz52S6a6CQAyFef/H0wQCgixqEBdQtgSC1nxNShDvrztJ0216eqZT5/V6SV3X8nw+Z8F/PB4q2GVZqk0O3batvN9v4aDN5jjDMMhut5MoiiQMQ7XRQRCI7/uSZZlst1txXVf2+/0cg8ifgGY0TSNVVSkDGMHsdrvNTImRJ36/31UvAQ1UAelGQVEUKufzWa7X6+zneS6Xy2UWfPJrhmjHDObDJbqbWBM0IMYKAsia3RcgBWmaShzHcjqdJEkSnSsxfEAZAc/GNh8iS6Yz4PF41GKEoZsQB9BY2ytsnsx3HMdvhtCnEAEElofDQX8Vnyb8OnFibAF5Y9r3/S8gl1gNz/Nks9koAEU8G1BGYOBmo/Fh+zNDW2J7Rtd12miaJs3bR6xlveDOcin/e5Y//QG6pkhkD6LgGgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;isr-flow&quot;
        title=&quot;isr-flow&quot;
        src=&quot;/static/bf23846d96f83f4ba7e4723f33816ad8/c1b63/isr-flow.png&quot;
        srcset=&quot;/static/bf23846d96f83f4ba7e4723f33816ad8/5a46d/isr-flow.png 300w,
/static/bf23846d96f83f4ba7e4723f33816ad8/0a47e/isr-flow.png 600w,
/static/bf23846d96f83f4ba7e4723f33816ad8/c1b63/isr-flow.png 1200w,
/static/bf23846d96f83f4ba7e4723f33816ad8/85e74/isr-flow.png 1436w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;revalidate&lt;/code&gt; 는 20초, 빌드 시 페이지 정적 생성이 이루어졌다면,
초기 페이지를 요청(1)한다면, 0s 기준으로 캐싱되어 있는 페이지를 응답받습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABBUlEQVQoz61T0UrDMBTN///CoCCbTFxBnSDCnnxydG7dxlD6MEWnFi2lqYFO2yTH9LquUfYyt0sOzWnI4Z57WoY9F9Na4y/Kqp5bC256+V8xEsyyDJxzJDwBTzlyWUBBQ2m1FaommFIKQgh8xCmM0k5VipLlUvQuncPntxjGM3hvY/RDH4NoSuiHI8IgmsAzuH4drrg5e/cxiwIoqaxQzOYqu0E7vsBxdImDxxM48w4Ow3OCc+8Sb7100Xw+RSM4It5cnMF5ctF96EHmRR1KUZi5LWXde26W+KqtmDO9rOeRi09zyfIqf1yuO6RLdhDEfnM7KL0hNKycsmqY9qeyC2f7/lO+AWLcVuG9XqJ4AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;isr-step-1&quot;
        title=&quot;isr-step-1&quot;
        src=&quot;/static/b10448a487895f3798cd16f6763ef007/c1b63/step-1.png&quot;
        srcset=&quot;/static/b10448a487895f3798cd16f6763ef007/5a46d/step-1.png 300w,
/static/b10448a487895f3798cd16f6763ef007/0a47e/step-1.png 600w,
/static/b10448a487895f3798cd16f6763ef007/c1b63/step-1.png 1200w,
/static/b10448a487895f3798cd16f6763ef007/e515d/step-1.png 1430w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;만약, 20초 이내에 새로운 요청(2)을 보냈다면, 이것 또한 기존 캐싱되어 있는 페이지를 응답받습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABB0lEQVQoz62TW0sCQRTH5/t/ix4WopuUhCFEatpNIwifohfvqyvjarRbOWf+zjkg4y69bHngMOc3s/znXGYV9mzKWou8s23XwoL5jf8KqyRJoLWGXmjEyxiGDJwcyFIh314sJbNoNJ5hOY0xH82QLj4BU7xc1pKSiQjd+A2t6Bk3/TvcjttoDB/RCjtoOq+7mL0p3EZt8CDM543JE17CLsiQz5Dt/usVpdU1yqsaDkeXCHrnOJ1XcRJVEfQvhI+nVzgKKzh4PxPmOJiUURnUYdbGD8UYA0rXPncX/nx8e05dj1LfAznb+Zzbw1VmMswMQsiz/YUpMzjLArKvdp9K/un8hdW+/5QNu7FWVJPUnrEAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;isr-step-2&quot;
        title=&quot;isr-step-2&quot;
        src=&quot;/static/e924db212802ad75c4e7f965fb35ea20/c1b63/step-2.png&quot;
        srcset=&quot;/static/e924db212802ad75c4e7f965fb35ea20/5a46d/step-2.png 300w,
/static/e924db212802ad75c4e7f965fb35ea20/0a47e/step-2.png 600w,
/static/e924db212802ad75c4e7f965fb35ea20/c1b63/step-2.png 1200w,
/static/e924db212802ad75c4e7f965fb35ea20/1bba3/step-2.png 1433w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;드디어 20초가 지나서 새로운 요청(3)을 보냈습니다. 넥스트에서는 설정해둔 20초가 지났기 때문에
캐싱된 페이지에 대해 유효성 검사를 진행하고, 새롭게 캐싱된 페이지가 전달될 거라 기대하지만, 그렇지 않습니다.
&lt;strong&gt;마찬가지로, 캐싱된 페이지를 응답받습니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJUlEQVQoz61TXU+DMBTl//8LE6eJn3EzcRpNhjLdzHQPxgcfNCq4AVsYjhXG2ttj6SRgYhyJazjhnrT30HNKDax5GFJKrEI28vdKwSqLqoppQcYYgiBAMAkQTkPM0zkiNgOLGaJZhIXgUPsESfoT+Ue15TiOMfrwEXoTDF8HGDs+fNsFn6WAqJ5fpqUtCxJ4CJ9geT20nA6uvTucv1zhxr9HW9Wm09Ww3J6GaXc0b6v6cniLvvcIEvSdoVwqW0kfh9ML1D9b2HaOsfXewP74DHujU9Te6gpH2PWa2HFPsPF8gE3Fs7o2aKBpmxBcFIfCOQclJW8L9URpYSUWkAkV09kcL3lVrURUZKibysFrVnD5C6cfB5XZXGoYeZjlX+M/3Fj3TfkCbqdVS0Qj/5IAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;isr-step-3&quot;
        title=&quot;isr-step-3&quot;
        src=&quot;/static/eebdbd40e5a2b218404d6e20b6767d8a/c1b63/step-3.png&quot;
        srcset=&quot;/static/eebdbd40e5a2b218404d6e20b6767d8a/5a46d/step-3.png 300w,
/static/eebdbd40e5a2b218404d6e20b6767d8a/0a47e/step-3.png 600w,
/static/eebdbd40e5a2b218404d6e20b6767d8a/c1b63/step-3.png 1200w,
/static/eebdbd40e5a2b218404d6e20b6767d8a/b6c94/step-3.png 1429w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이 단계에서 예상과는 다르게 새롭게 재생성된 페이지를 전달받지 못한 것에 대해 약간의 혼란이 생깁니다.
그렇다면, 넥스트는 어느 시점에서 새롭게 유효성을 검사할까요?&lt;/p&gt;
&lt;p&gt;바로, &lt;strong&gt;20초가 지나서 전달된 새로운 요청(3)이 유효성 재검사의 트리거가 됩니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABl0lEQVQoz41S20rDQBDN/7+KSC0IiootIr755gf4oBSK4KUxm9A0SbO535rbcWdqi0YfHDjJ7O7s2TMXra5rFEWBqqqw2WwwtL7v/w0yjYjCMITruvB9H0EQwHEceJ7H+03T4L9GpBo5bdsygfQl9IUOz/UgDIEiy1EW5R5VWTGG63pTQ2ncKtxJvc8fcLK+wal7i7E5xdHiEmNrimNrgsO3c8bInGAkrnDwcsbrY7U+FBe41u/QNu2WkD5d28Ep1nAaH27t4yOy8OK+K18yFlLgba1jVa0Zz/YrPkITdunBzGws4xVz7AlZZdv/qEcsI5SpalauUiq2zUqCGK7toK1UXSm8+bqjfl3X/UyZlSq/67cHMpBI0gRBGHCjqEFCCBjCwOPTI2azGTdyF78zbTgaZDRKUkpkWcagrhOpYRiYz+eIomh/Rj5NR5qm3Fxt2HZWquRTQBzHfIFGi2y5XMKyLCaiPQI9TLF5nvM97a9Z2hkppXEigiRJmMy2bYZpmrxHqn6lPCT7nv6+vup1UkupD0m+l+wTXAVLDpDcvfIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;isr-step-4&quot;
        title=&quot;isr-step-4&quot;
        src=&quot;/static/f1b70e24e4931788a802afc692f1cf8f/c1b63/step-4.png&quot;
        srcset=&quot;/static/f1b70e24e4931788a802afc692f1cf8f/5a46d/step-4.png 300w,
/static/f1b70e24e4931788a802afc692f1cf8f/0a47e/step-4.png 600w,
/static/f1b70e24e4931788a802afc692f1cf8f/c1b63/step-4.png 1200w,
/static/f1b70e24e4931788a802afc692f1cf8f/4c5bd/step-4.png 1435w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;넥스트는 20초가 지난 시점에서 새로운 요청(3)이 들어오면 기존의 캐싱되어 있던 페이지의 유효성을 재검사합니다.
&lt;strong&gt;이때 재생성이 성공한다면, 기존의 캐싱된 페이지는 무효화되며, 재생성된 페이지가 새롭게 캐싱됩니다.&lt;/strong&gt;
만약, 모종의 이유로 재생성에 실패한다면, 기존의 캐싱된 페이지가 유효하게 유지됩니다.&lt;/p&gt;
&lt;p&gt;이 시점을 왜 재생성의 트리거로 설정했을 까라는 생각을 오래했는데, 20초 마다 조건없이 재생성하기 보다는,
20초 이후 새로운 요청이 들어와 업데이트된 정보를 필요로 하는 클라이언트의 수요를 확인하고
재생성이 이루어지는 것이 훨씬 경제적일 거라는 판단이지 않을까라는 개인적인 생각을 했습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABOUlEQVQoz61Sy07CQBTt/3+FCZogCYloQl1ofAZQI+hCNxojUqAdkLb0zTyOM6OF1oV04U1Obk57cua+DPxzGEIIbIOKPG81rCKqaqYN4ziG67pYSHhLH2mWIoxCRHGEQOYVo5B1ggv+J/JHdcvKlIwd+I6L6fsEc4uAfNigQQaw6vNTXrplzjmevBd0SR8Xoxv0nAFO367RIwN0nT6urFuNjn2vcSk1indt+W96h0fnGUJ6rCtU0Ukf0FyeoOWfYc86wu6whcbsGA1iojY80Nh3TNTtNnZem5rXp23UJocwR+fglG2WwhgDT2ip/HgRAtkPSeSMkk3vqyAFinL23WWpwnzwTGL2OYc1tjTIjCBbZVCq9QKUtrQooQz0dyMfZvHefN/Xm1fZ8zxQSkvnU9T/5kbVe6t6i19Gw1N61dj6iwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;isr-step-5&quot;
        title=&quot;isr-step-5&quot;
        src=&quot;/static/fcce8f8d1e4728edca4cf3b3ecef0d4b/c1b63/step-5.png&quot;
        srcset=&quot;/static/fcce8f8d1e4728edca4cf3b3ecef0d4b/5a46d/step-5.png 300w,
/static/fcce8f8d1e4728edca4cf3b3ecef0d4b/0a47e/step-5.png 600w,
/static/fcce8f8d1e4728edca4cf3b3ecef0d4b/c1b63/step-5.png 1200w,
/static/fcce8f8d1e4728edca4cf3b3ecef0d4b/1bba3/step-5.png 1433w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;재생성이 완료된 이후 시점에서 새로운 요청(4)이 들어온다면, 재생성이 성공했다는 가정하에 재생성된 페이지를 응답 받게 됩니다.&lt;/p&gt;
&lt;h2 id=&quot;isr를-적용하기-앞서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#isr%EB%A5%BC-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0-%EC%95%9E%EC%84%9C&quot; aria-label=&quot;isr를 적용하기 앞서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;ISR를 적용하기 앞서&lt;/h2&gt;
&lt;p&gt;사실, 실시간으로 업데이트되어야 하는 제품 상세 페이지에 ISR을 적용하기란 생각보다 불안했습니다.
그래서 ISR을 타임라인을 그려보기도 하고, 생각보다 비슷한 걱정을 한 이야기들을 보기 위해 괜히
&lt;a href=&quot;https://github.com/vercel/next.js/discussions?discussions_q=ecommerce&quot;&gt;디스커션&lt;/a&gt;
을 읽어보기도 했습니다.&lt;/p&gt;
&lt;p&gt;맘 편하게 &lt;code class=&quot;language-text&quot;&gt;TTFB&lt;/code&gt; 를 조금 양보하더라도 서버 사이드에서 데이터 패칭하도록 할까 라는 생각도 했었지만,
SSG의 응답 속도를 한번이라도 경험해보신 분들은 절대 포기못 할 속도일 겁니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 709px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 61.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAADZElEQVQozz2Sa0+TBxiG318yUShCaStnJqcgFDQgLadSKAqUDmQIWlB0IEbBIWwCahnGMYGoRE3cihSDRIdDOoRY5RBhynSEEZmTcuiB7mCWXXu3D/tw5/525XpyP4K5OoP82HC00eFU7Y2nLkuJPjGK3LidjJiMuBasLA91smQxYZ/7jod9t+k420V/ezs/DnzJi2Ez+sIq8nWlFGTqEfpqNKTHRXD9RCHHMhPIjg4jOSKUhiIVbx9dZWN+DPvQZWZaP2bh689ZX5xl7Z2H4bs2fr5/hz9/GOHMyWaSlRp0aXkIT5pzmbpQwtWKVFIjQ0gIDyZcJuWzKj3WS8exntYyWJPFeMcnmPJSGfvGwt/v3zM98yvTI0/56/Ukz59NYSg8Sk56PsL9OjW16ijCg0JQxsQQGxaKzEdCozGfxf42XpvKeNJUxHR7Jd21dZi/6mfh6Uuso4vYxhZw/7LCb+urPBgaR6MuREiJDMRX4kewTEGoXMGHCgVhAVIay7JYuF7PeGMJ8xfLeXuzBdvgY0YtNuYev2LGtsxPs+/YWHHidjh58XyR6kMNCF5eEqR+MjFSFP4BIlQuGvpxslSH9byR9jwlo+cO8+bbu6y8WsO57MS15sa17mbTKbYIW7O7MfdNcUEcS5BL5SIsgAB/Gf6+UoICFEi2Sqgo0DB3q41uw156jRpmb1/jd7sHpwhwbjj/73+BLocH6/eLnG/uQQhSBBIREsoOmRyfbT74ekvw9tpGVGgwV2qL6TJq6a5M506DkaXZN7hcmyLIgXPN9R9w07HJ/NwKA5YpTOe6EbZ8sBX/7RJ2iKfuit2JNk1FScF+DHoDhn156HbHUJymJDNpD60tN1m1/4Fz3YFDjNvhYumlnQHzNG0tN6jQlSHERUaSkhhPbqaaE5XldLY28ezhIPdu9XKgqJg9KVoSElKJj01Ck2Gg68ogqysePG4Prg3Rdt3Do+FJPj1ST1laDoIqKZFdkdEEyQPFx1RTUZjPxFA/TcdryVblUFp6jAMlleRm5JAcv5uzp5oYHZpg5N4kDywT9PVa6O+5gfniJWpVWeLKW7zxEVf13y5Dm5LCfrWKmoNl1Bw+ir6gnCPVZ/iiQ7T9qBS1Mgm9Rse+jCKM5afpvWyh/tApTOUHsfV00qLJ5h/7U27IJe1LfwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;fast&quot;
        title=&quot;fast&quot;
        src=&quot;/static/33d2719e99724dfa5a914b88059481ef/4d08a/fast1.png&quot;
        srcset=&quot;/static/33d2719e99724dfa5a914b88059481ef/5a46d/fast1.png 300w,
/static/33d2719e99724dfa5a914b88059481ef/0a47e/fast1.png 600w,
/static/33d2719e99724dfa5a914b88059481ef/4d08a/fast1.png 709w&quot;
        sizes=&quot;(max-width: 709px) 100vw, 709px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;나름의 합의점을 찾자면, ISR을 통해 속도 최적화를 챙기면서
가격 변동이나 남은 수량과 같은 실시간 정보를 필요로 하는 곳은 랜더링 직후 클라이언트에서 데이터 패칭을 통해
UI에 영향이 가지 않는 선에서 스토어를 업데이트해주는 방향을 선택할 수 있습니다.&lt;/p&gt;
&lt;p&gt;ISR과 함께 데이터 재검증에 대한 고민을 하다보니 &lt;a href=&quot;https://swr.vercel.app/ko&quot;&gt;SWR&lt;/a&gt;가 자주 등장하는데요.
ISR를 적용하고 나서 풀어야 할 숙제가 남아 있기 때문에 SWR를 추가적으로 공부해보려 합니다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;SWR&lt;/code&gt; 을 &lt;code class=&quot;language-text&quot;&gt;ISR&lt;/code&gt; 와 함께 사용한 예제들을 보면 정적 랜더링 이후 포커싱이 돌아오거나, 네트워크가 회복되었을 때 데이터 패칭을 통해 업데이트된 외부 데이터를 UI에
적용시켜줍니다. 어쩌면 스토어 따윈 필요로 하지 않는 클라이언트 개발이 얼마 남지 않은 것 같네요.b&lt;/p&gt;
&lt;h2 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h2&gt;
&lt;p&gt;최근 넥스트로 이관하면서 최적화에 재미가 붙은 것 같습니다. 작업할 때 Web Vital Score을 신경쓰게 되었고,
페이지별로 감점 요소를 찾고 추가 작업을 합니다. 이번 작업을 진행하면서 고민할 것들도 늘었구요.&lt;/p&gt;
&lt;p&gt;그러다 오른 점수를 보면 마냥 행복해지는 게 숙명이 아닌 가 싶습니다. 얼른 90점을 넘겨 초록색 게이지를 보고 싶네요!&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1016px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 38.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABMElEQVQoz21Q0WrDMAyMZMeJEzuJMzo2NhgbbBT2UBi0L9sf7P+/5ybJaSmjgUOycnc6u1nXFTFGpJQwDANyzpjn2fplWWyuUF4pxapB+nIDzTRNUBQRL8tsZmqqJmqo55QyxlwXXpCmumwcjW+QcyOfCXe7HdK8mlhnIQSMQp7UfBzgo7f5GRTvEPqE0HXI04JpLhhGMXSOjeCYsH908FwFfd/DOSeEDtQOIB9BYdyQwF2qc0HjpYYMbqNqCfeZcPx8xunwjp8PG8q7bobkwF5MXYuGJSXXys6DNOmWWAN55athGRr8Hh/wfXjB6a2vhpLQ+ypiIRNV8bkys/R0gS5XfuO4XvlpDfh6jTXVdmXe/pn4nwHfOJshEdtW13b2Xja8fkNLRRfz696uunHO+AN/ea6NbgcEfgAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;web-vital-score&quot;
        title=&quot;web-vital-score&quot;
        src=&quot;/static/23eff5fbf5f5c901814a7b14b9a3daa1/f4281/web-vital-score.png&quot;
        srcset=&quot;/static/23eff5fbf5f5c901814a7b14b9a3daa1/5a46d/web-vital-score.png 300w,
/static/23eff5fbf5f5c901814a7b14b9a3daa1/0a47e/web-vital-score.png 600w,
/static/23eff5fbf5f5c901814a7b14b9a3daa1/f4281/web-vital-score.png 1016w&quot;
        sizes=&quot;(max-width: 1016px) 100vw, 1016px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[CRA 프로젝트를 next.js로 전환해보자]]></title><description><![CDATA[웹 개발을 하면서 정량적인 지표를 보는 것에 재미가 들린 요즘, 지표는
엄청난 동기를 부여하곤 합니다.
최근 Lighthouse…]]></description><link>https://youthfulhps.dev/nextjs/cra-to-next/</link><guid isPermaLink="false">https://youthfulhps.dev/nextjs/cra-to-next/</guid><pubDate>Sun, 26 Dec 2021 21:05:09 GMT</pubDate><content:encoded>&lt;p&gt;웹 개발을 하면서 정량적인 지표를 보는 것에 재미가 들린 요즘, 지표는
엄청난 동기를 부여하곤 합니다.
최근 &lt;a href=&quot;https://developers.google.com/web/tools/lighthouse&quot;&gt;Lighthouse&lt;/a&gt;로
프러덕션의 사용자 경험에 대한 점수가 여럿 빨간불을 켜고 있는 것을 보고는
이제 더 이상 최적화를 미룰 수 없겠다는 생각이 들게 되었는데요.&lt;/p&gt;
&lt;p&gt;현재 프러덕션은 클라이언트 사이드에서 랜더링을 담당하고 있기 때문에
검색 엔진 최적화 측면에서 취약하다는 단점이 존재했고, 사용자 경험 지표를
챙겨 검색 엔진에게 예쁨 받을 수 있는 프러덕션이 되기 위해
랜더링 동작을 서버 사이드에서 담당할 수 있도록 전환하고자 했습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 766px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACrklEQVQozx2S31NSexTFzzTjNM2UIgLKyUwSbSQlCRA1EVMh0QMivw56zuGHp0RCESOTzOyHNeO908+XHqrpsbnvt//v03d6WLNe9l57zdpLCswE8U0HGA/4GLvjZWo+iJJd4n5qmTV9jVwxx2ouwW6txqtmnfOjJql4inAkSSpdoaDuoG3uUjT2MbQG0sjoEP1XnbiGbjDuHadqPqDdbrG//4jj9mOetXbZyGZ4KPCktMHrWokDs0atUuf50RtOX/zL6ck/tJ++/cuSZ8xHKDRHZDZGvdqgvqmyk06yV8hwKpZPt0s0NZWZsdvM+fy0jDwvtw0OtBztqsmPT5/5+OEbn7/85OztF6Rt8xAjucX6Yg5ztUwztok6n+IgplO5u4AyM01DXcfd52Kwz01FibEZvcdycFo4Nvhxfsab86/8/PWb45P3SLFZhbBwFwpHmJ0K0048ImO0aBQOqfij3PN7Ka0skE5uEAnNU0/HiQb8BD1+crFl3olo/vv1P+WtFt+FqDTgnmA8OI/bc5vR4VscLpVJJUy0+Bb7kQxN3aCkZDjYey1yNDhUNR6sZNCiGxSX1jnWVR5mClg7LJy8/IBU8ikUR6OYnhh7d5IcTSi0PIs89izQGJnCHAmw55mi6vbx4laYs9EILZeXHfkG1aFJdNGOYYeVC5JEJqkjVXqHqcoegZsYvW40hxh0uij3DqLbZQo9VlRrJ2qPhYUuK6FOOyuWK2QtF1GsVrITXvziWIfUQT6/jbRmk0k7+knb+1kXyDqukXdcFzxA3taHZndScTiZFGIDrpsMilhki51odzcRp4ypGeg5E6dthOnQonhKl42E1SkgE+++itLdx6qll0XhZLazh7tddryXrmC73EP8/hqFnM6ALD4uX2duZk50VEXL6wQmExS1Mn8AVrN0Gm6MNFUAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;thumbnail&quot;
        title=&quot;thumbnail&quot;
        src=&quot;/static/615cd6a72681d75d43cafff342ae1b99/f7616/thumbnail.png&quot;
        srcset=&quot;/static/615cd6a72681d75d43cafff342ae1b99/5a46d/thumbnail.png 300w,
/static/615cd6a72681d75d43cafff342ae1b99/0a47e/thumbnail.png 600w,
/static/615cd6a72681d75d43cafff342ae1b99/f7616/thumbnail.png 766w&quot;
        sizes=&quot;(max-width: 766px) 100vw, 766px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이번 글에서는 next.js를 통해 서버 사이드 랜더링 방식으로 전환하는 과정에
대해서 정리해볼까 하는데요. 아무래도 기저에 있는 프러덕션 프레임워크를
변경하는 작업이다 보니, 우선 문제없이 빌드가 되는 단계까지 정리해보고자
합니다.&lt;/p&gt;
&lt;p&gt;참고로 next.js는 클라이언트, 서버 사이드 랜더링을 혼용하여 사용할 수
있기 때문에 랜더링 이전에 데이터를 패칭하거나, 특정 액션을 수행하기 위해
getServerSideProps 등의 함수를 사용하지 않는 이상 여전히
클라이언트 사이드 랜더링으로 동작하게 됩니다.&lt;/p&gt;
&lt;h2 id=&quot;의존성-업데이트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%98%EC%A1%B4%EC%84%B1-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8&quot; aria-label=&quot;의존성 업데이트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;의존성 업데이트&lt;/h2&gt;
&lt;p&gt;next.js를 설치해주어야 합니다. &lt;code class=&quot;language-text&quot;&gt;react-scripts&lt;/code&gt; 와
&lt;code class=&quot;language-text&quot;&gt;react-router-dom&lt;/code&gt; 은 이제 제거해도 좋습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;//package.json

&amp;quot;next&amp;quot;: &amp;quot;12.0.4&amp;quot;, //resolve
&amp;quot;react-scripts&amp;quot;: &amp;quot;4.0.3&amp;quot;, //remove
&amp;quot;react-router-dom&amp;quot;: &amp;quot;^5.2.0&amp;quot;, //remove

&amp;quot;scripts&amp;quot;: {
  &amp;quot;start:dev&amp;quot;: &amp;quot;craco start&amp;quot;, //remove
  &amp;quot;start:dev&amp;quot;: &amp;quot;next dev&amp;quot;, //add
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;환경-변수-업데이트&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%99%98%EA%B2%BD-%EB%B3%80%EC%88%98-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8&quot; aria-label=&quot;환경 변수 업데이트 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;환경 변수 업데이트&lt;/h2&gt;
&lt;p&gt;환경 변수의 접두어를 변경해주어야 합니다. CRA 프로젝트는 REACT_APP 이라는 접두어를
사용하는 반면, &lt;a href=&quot;https://nextjs.org/docs/basic-features/environment-variables#exposing-environment-variables-to-the-browser&quot;&gt;next.js&lt;/a&gt;는 NEXT_PUBLIC 이라는 접두어를 사용합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;//.env

REACT_APP_BASE_PATH=https://... //remove
NEXT_PUBLIC_BASE_PATH=https://... //add&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;에셋을-위한-넥스트-환경-설정&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%97%90%EC%85%8B%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%84%A5%EC%8A%A4%ED%8A%B8-%ED%99%98%EA%B2%BD-%EC%84%A4%EC%A0%95&quot; aria-label=&quot;에셋을 위한 넥스트 환경 설정 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;에셋을 위한 넥스트 환경 설정&lt;/h2&gt;
&lt;p&gt;기존 프로젝트에서 사용 중인 에셋 파일들을 유지하고 사용하기 위해
로더가 필요합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;//package.json

&amp;quot;@svgr/webpack&amp;quot;: &amp;quot;^6.0.0&amp;quot;,   //resolve&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;//next.config.js

module.exports = {
  webpack(config) {
    config.module.rules.push({
      test: /\.svg$/,
      use: [&amp;#39;@svgr/webpack&amp;#39;],
    })

    return config
  },
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import Icon from &amp;#39;@assets/icons/Icon.svg&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;_app-생성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#_app-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;_app 생성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;_app 생성&lt;/h2&gt;
&lt;p&gt;next.js를 사용할 때는 지정된 프로젝트 구조를 따라주어야 합니다.
CRA 프로젝트에서 애플리케이션 최상단의 App을 &lt;code class=&quot;language-text&quot;&gt;_app.tsx&lt;/code&gt; 으로
변경해주어야 합니다.&lt;/p&gt;
&lt;p&gt;next.js의 _app 파일의 기본 구조는 다음 코드와 같고,
이하 기존 프로젝트에서 사용 중이던 모듈들을
동일하게 추가해주면 됩니다. 추가적인 정보는 &lt;a href=&quot;https://nextjs.org/docs/advanced-features/custom-app&quot;&gt;_app.tsx&lt;/a&gt;
문서를 참고해 주세요.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;//src/pages/_app.tsx

import type { AppProps } from &amp;quot;next/app&amp;quot;;

function MyApp({ Component, pageProps }: AppProps) {
  return &amp;lt;Component {...pageProps} /&amp;gt;;
}

export default MyApp;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;_document-생성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#_document-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;_document 생성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;_document 생성&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;_document.tsx&lt;/code&gt; 파일을 생성해주어야 합니다.
도큐먼트 파일은 도큐먼트의 최상단 태그들을 보강하는 데 사용되며,
meta, script 와 같은 태그들이 추가됩니다.&lt;/p&gt;
&lt;p&gt;_document 파일의 기본 구조는 다음 코드와 같고, 기존 프로젝트의
&lt;code class=&quot;language-text&quot;&gt;index.html&lt;/code&gt; 파일에 구성되어 있는 요소들을 하나 씩 옮겨주시면 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import Document, { Html, Head, Main, NextScript } from &amp;#39;next/document&amp;#39;

class MyDocument extends Document {
  static async getInitialProps(ctx) {
    const initialProps = await Document.getInitialProps(ctx)
    return { ...initialProps }
  }

  render() {
    return (
      &amp;lt;Html&amp;gt;
        &amp;lt;Head /&amp;gt;
        &amp;lt;body&amp;gt;
          &amp;lt;Main /&amp;gt;
          &amp;lt;NextScript /&amp;gt;
        &amp;lt;/body&amp;gt;
      &amp;lt;/Html&amp;gt;
    )
  }
}

export default MyDocument&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;주위하실 점은 head 태그에 추가되는 title, link, viewport 와 같은 태그들은
_app 에 선언되어야 한다고 합니다. 만약, _document 에 추가하면
&lt;a href=&quot;https://nextjs.org/docs/messages/no-document-viewport-meta&quot;&gt;경고&lt;/a&gt;를 받게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import type { AppProps } from &amp;quot;next/app&amp;quot;;
import Head from &amp;quot;next/head&amp;quot;;

function MyApp({ Component, pageProps }: AppProps) {
  return (
    &amp;lt;&amp;gt;
      &amp;lt;Head&amp;gt;
        &amp;lt;title&amp;gt;Porject title&amp;lt;/title&amp;gt;
        &amp;lt;link rel=&amp;quot;shortcut icon&amp;quot; href=&amp;quot;/favicon.png&amp;quot; /&amp;gt;
        &amp;lt;meta
          name=&amp;quot;viewport&amp;quot;
          content=&amp;quot;width=device-width, initial-scale=1, shrink-to-fit=no&amp;quot;
        /&amp;gt;
        ...
      &amp;lt;/Head&amp;gt;
      &amp;lt;Component {...pageProps} /&amp;gt;
    &amp;lt;/&amp;gt;
  );
}

export default MyApp;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;페이지-디렉토리를-통한-라우팅-적용&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%8E%98%EC%9D%B4%EC%A7%80-%EB%94%94%EB%A0%89%ED%86%A0%EB%A6%AC%EB%A5%BC-%ED%86%B5%ED%95%9C-%EB%9D%BC%EC%9A%B0%ED%8C%85-%EC%A0%81%EC%9A%A9&quot; aria-label=&quot;페이지 디렉토리를 통한 라우팅 적용 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;페이지 디렉토리를 통한 라우팅 적용&lt;/h2&gt;
&lt;p&gt;next.js에서 각각의 페이지는 pages 폴더의 파일 혹은 폴더명을 기반으로
라우팅됩니다. path params을 전달받는 페이지 또한 다음과 같이 구성할 수 있고,
기존 프로젝트에서 사용된 라우터들은 이제 제거해도 좋습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;src/_app.tsx =&amp;gt; https://.../
src/pages/me/index.tsx =&amp;gt; https://.../me
src/pages/project/[projectId].tsx =&amp;gt; https://.../project/{projectId}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;라우팅-모듈-대체&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%9D%BC%EC%9A%B0%ED%8C%85-%EB%AA%A8%EB%93%88-%EB%8C%80%EC%B2%B4&quot; aria-label=&quot;라우팅 모듈 대체 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;라우팅 모듈 대체&lt;/h2&gt;
&lt;p&gt;컴포넌트 레벨에서 라우팅을 담당하는 컴포넌트나 페이지 전환이 이루어지는 로직이 있다면
&lt;code class=&quot;language-text&quot;&gt;react-router-dom&lt;/code&gt;의 Link 컴포넌트나, &lt;code class=&quot;language-text&quot;&gt;useHistory&lt;/code&gt;를 통해
구현되어 있을텐데요.&lt;/p&gt;
&lt;p&gt;next.js에서 클라이언트 라우팅 동작을 도와주는
&lt;code class=&quot;language-text&quot;&gt;next/router&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;next/link&lt;/code&gt; 로 대체할 수 있습니다.
추가적인 정보는 &lt;a href=&quot;https://nextjs.org/docs/api-reference/next/link&quot;&gt;next/link&lt;/a&gt;,
&lt;a href=&quot;https://nextjs.org/docs/api-reference/next/router&quot;&gt;next/router&lt;/a&gt;를 참고하면 좋습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;;
// import { Link } from &amp;quot;react-router-dom&amp;quot;;
import Link from &amp;#39;next/link&amp;#39;;
import { withRouter, NextRouter } from &amp;#39;next/router&amp;#39;;

type HeaderProps = {
  children: React.ReactNode;
  router: NextRouter;
} &amp;amp; with;

function Header({ children, router }: HeaderProps) {
  return (
    &amp;lt;header className={className}&amp;gt;
      ...
      &amp;lt;Link {...} href={to}&amp;gt;
        &amp;lt;a&amp;gt;{children}&amp;lt;/a&amp;gt;
      &amp;lt;/Link&amp;gt;
    &amp;lt;/header&amp;gt;
  );
}

export default withRouter(NavLink);  //hoc&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;;
import Link from &amp;#39;next/link&amp;#39;;
import { useRouter } from &amp;#39;next/router&amp;#39;;
// import { Link, useHistory } from &amp;#39;react-router-dom&amp;#39;;

type HeaderProps = {
  children: React.ReactNode;
};

function Header({  children }: HeaderProps) {
  // const history = useHistory();
  const router = useRouter();

  const handleLogoClick = () =&amp;gt; {
    // history.push(&amp;#39;/&amp;#39;);
    router.push(&amp;#39;/&amp;#39;);
  }

  return (
    &amp;lt;header className={className}&amp;gt;
      ...
      &amp;lt;Logo onClick={handleLogoClick}/&amp;gt;
      &amp;lt;Link {...} href={to}&amp;gt;
        &amp;lt;a&amp;gt;{children}&amp;lt;/a&amp;gt;
      &amp;lt;/Link&amp;gt;
    &amp;lt;/header&amp;gt;
  );
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;또한, path params은 router를 통해 참조할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;;
import { useRouter } from &amp;#39;next/router&amp;#39;;

function ProjectPage() {
  ...

  const router = useRouter();

  useEffect(() =&amp;gt; {
    if (!router.isReady) return;
    const {projectId} = router.query;
    ...
  },[router.isReady])
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;마운트-이후-시점이-보장되지-않는-window-객체-참조-처리&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%9A%B4%ED%8A%B8-%EC%9D%B4%ED%9B%84-%EC%8B%9C%EC%A0%90%EC%9D%B4-%EB%B3%B4%EC%9E%A5%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94-window-%EA%B0%9D%EC%B2%B4-%EC%B0%B8%EC%A1%B0-%EC%B2%98%EB%A6%AC&quot; aria-label=&quot;마운트 이후 시점이 보장되지 않는 window 객체 참조 처리 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마운트 이후 시점이 보장되지 않는 window 객체 참조 처리&lt;/h2&gt;
&lt;p&gt;서버에서 랜더링할 때는 window 객체를 참조할 수 없기 때문에
마운트 이후 시점이 보장되지 않는 곳에서 window 객체에 접근한
코드는, 마운트 이후 시점이 보장되는 로직 전개로 처리해주어야 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React, { useEffect, useRef } from &amp;#39;react&amp;#39;;

function MainPage() {
  const isMobile = useRef&amp;lt;boolean&amp;gt;(false);

  useEffect(() =&amp;gt; {
    if (typeof window !== &amp;#39;undefined&amp;#39;) {
      isMobile.current = window.innerWidth &amp;lt;= 450;
    }
  },[]);

  return ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;서버사이드에서-js-내부-css-스타일-적용&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C%EC%97%90%EC%84%9C-js-%EB%82%B4%EB%B6%80-css-%EC%8A%A4%ED%83%80%EC%9D%BC-%EC%A0%81%EC%9A%A9&quot; aria-label=&quot;서버사이드에서 js 내부 css 스타일 적용 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;서버사이드에서 JS 내부 CSS 스타일 적용&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;styled-components&lt;/code&gt; 를 통해 컴포넌트를 스타일링한다면,
바벨 플러그인을 통해 서버 사이드에서 정의된 스타일이 적용된 후
랜더링될 수 있도록 설정해주어야 합니다.
추가적인 내용은 &lt;a href=&quot;https://styled-components.com/docs/advanced#nextjs&quot;&gt;styled-components&lt;/a&gt; 를 참고하시면 좋습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;//package.json

&amp;quot;babel-plugin-styled-components&amp;quot;: &amp;quot;^2.0.1&amp;quot;,  //resolve&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;//.babelrc
{
   &amp;quot;presets&amp;quot;: [&amp;quot;next/babel&amp;quot;],
   &amp;quot;plugins&amp;quot;: [
     [
       &amp;quot;styled-components&amp;quot;,
       {
         &amp;quot;ssr&amp;quot;: true,
         &amp;quot;displayName&amp;quot;: true,
         &amp;quot;preprocess&amp;quot;: false
       }
     ]
   ]
 }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;tsx&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;//_document.tsx

import Document, {
  Html,
  Head,
  Main,
  NextScript,
  DocumentContext,
} from &amp;#39;next/document&amp;#39;
import { ServerStyleSheet } from &amp;#39;styled-components&amp;#39;

class MyDocument extends Document {
  static async getInitialProps(ctx: DocumentContext) {
    const sheet = new ServerStyleSheet()
    const originalRenderPage = ctx.renderPage
    try {
      ctx.renderPage = () =&amp;gt;
        originalRenderPage({
          enhanceApp: App =&amp;gt; props =&amp;gt; sheet.collectStyles(&amp;lt;App {...props} /&amp;gt;),
        })

      const initialProps = await Document.getInitialProps(ctx)
      return {
        ...initialProps,
        styles: (
          &amp;lt;&amp;gt;
            {initialProps.styles}
            {sheet.getStyleElement()}
          &amp;lt;/&amp;gt;
        ),
      }
    } finally {
      sheet.seal()
    }
  }

  render() {
    return (
      &amp;lt;Html&amp;gt;
        &amp;lt;Head&amp;gt;&amp;lt;/Head&amp;gt;
        &amp;lt;body&amp;gt;
          &amp;lt;Main /&amp;gt;
          &amp;lt;NextScript /&amp;gt;
        &amp;lt;/body&amp;gt;
      &amp;lt;/Html&amp;gt;
    )
  }
}

export default MyDocument&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h2&gt;
&lt;p&gt;next.js를 적용하면서 당연하게도 많은 빌드 문제를 겪었는데요.
‘빌드만 성공해보자’ 라는 생각으로 작업을 진행했던 기억이 나는데요.
최근 다수의 프로젝트들이 next.js를 적용하려는 작업들이 진행 중인 만큼
next.js는 &lt;a href=&quot;https://nextjs.org/docs/advanced-features/codemods&quot;&gt;codemods&lt;/a&gt;
를 지원하여 CRA 애플리케이션을 자동으로 변환하는 도구를 제공하고 있으니
살펴 보시면 좋을 것 같습니다.&lt;/p&gt;
&lt;p&gt;추가적으로 서버 사이드 리덕스 스토어 관리나, 페이지 초기 데이터 패칭을
위한 정의 등 많은 이슈들을 만나게 될텐데, 궁금하신 점, 잘못된 부분이
있다면 언제든 지적해주시면 감사하겠습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[나는 제네레이터를 알고 사용하는 걸까?]]></title><description><![CDATA[리덕스 사가는 ES6에 새롭게 도입된 제네레이터 (Generator…]]></description><link>https://youthfulhps.dev/javascript/do-I-know-javascript-generator/</link><guid isPermaLink="false">https://youthfulhps.dev/javascript/do-I-know-javascript-generator/</guid><pubDate>Sun, 21 Nov 2021 22:05:01 GMT</pubDate><content:encoded>&lt;p&gt;리덕스 사가는 ES6에 새롭게 도입된 제네레이터 (Generator) 문법을 사용하여 유용하게 비동기 처리를 할 수 있게 해줍니다.
현재 운영 중인 프러덕션 또한, 리덕스에서 사이드 이펙트가 존재할 만한 비동기적인 비지니스 로직을 관리하기 위해 리덕스 사가 미들웨어를 사용하고 있는데요.&lt;/p&gt;
&lt;p&gt;늘 사용하고 있는 문법이고 동작 또한 해석이 되니 작업에 문제는 없지만, 제네레이터에 대한 이론적인 이해 정도를 스스로 질문했을 때
한창 공부했을 때의 이론적 대답이 쉽게 나오지 않는 걸 느끼고 다시 한번 정리를 해볼 까 합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 692px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAADG0lEQVQozx2T6VNTdxSG77/RdirDtCIQVk1iQkgIWchG9tysZL25AiGEIEpEjQZqUQrjuLSKU8gAFuuMXfzQmfa/e3raD2fO3PnNPOc973mv4rJOE/ZYiPisxAI2CnE3Ccc0lYiTVl2lt7NMp5GhWYmyuZKiu12jkIty3WpkTU/RXslIqRTjLrS0DyXoMlFIuVEjDtJRJ8WEm53mEm/2tzjuVHm5o3PQXaW3rdHdqrAn3w/vVmndUqnnAqSDNhq1JCevHvH8cROllguiFUL833MhsjEXmZCdFw2VTtqDJpMPOjrP7mk0y4vca+XpbuYoqgu47SZUAabCTnY2SgTcMyjrWop1TWVDT6NXE2iqj/2Uh6N6FC0TIBua5e1aio8PalTDNspBK9WUk2B0genJUXmfoaklROksg1e+QFkpLrK8FEIvhtmW+iDQU5lYTvjRC2E6eT/vGinORNXd2Dyvkw5eLHkIzN3AYjZwu+Sjng+w6LczZriKsiqQukAf1GL8vZLlz7xA0iHyxQyt8DzfReboicd7qhvvnB3z5CR3/CYc0xOMjw6xXfFTzvjIZYLk00EBlsKsliN8ENjvxRg/Jby8lVWPIvPsus3cX7DwVPzajQtc7PhhrcJ6PUO1mmWlnmW1nqahZ2hI1ytJFE2O0ZJr9ZM++mqAN7LukW2ch1JdAVauD7Eh0F2J1JN5I/9UEpyILTVRVUy6qGZ9LEukbpUi6OUoSkF8KUhUSo4pNk0jdG8aWDMMsGkx0LZNEL/6JemRK/TsU9yZGeeVb4bP2RAXksf9XpPT4yd8+viSz7/9yB+fXqMUZY1iOkBB1op7bxIxXqM89BXLAu+IolVRuGUZ40Li1DCP0JgY5CTk4C9R+X6vzbEAT959zy8Xh1y+P0KJR1xEQk7+62pqgeyig60bQ+jGYW7PTpIc/pqliW85FyvWTMPExwd5JBE59lq5lL/k5PQpZ1Ln/Wf8evkcxey0YXXPYXM58HhnyQUc3DcOUZ76hrasqdknWJJ6bL5GfWyA+OgAbTlkU4Ydim9n54f0f97nrH8g0AP+BQ+F71uVRRCTAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;thumbnail&quot;
        title=&quot;thumbnail&quot;
        src=&quot;/static/3680d6a9d644d9a43883a52be0c08cb8/91e7e/thumbnail.png&quot;
        srcset=&quot;/static/3680d6a9d644d9a43883a52be0c08cb8/5a46d/thumbnail.png 300w,
/static/3680d6a9d644d9a43883a52be0c08cb8/0a47e/thumbnail.png 600w,
/static/3680d6a9d644d9a43883a52be0c08cb8/91e7e/thumbnail.png 692w&quot;
        sizes=&quot;(max-width: 692px) 100vw, 692px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;참고로, 이 글은 &lt;a href=&quot;https://poiemaweb.com/es6-iteration-for-of&quot;&gt;이터레이션&lt;/a&gt;, &lt;a href=&quot;https://poiemaweb.com/es6-generator&quot;&gt;제네레이터&lt;/a&gt;의 전개와 예시가 유사합니다.
저는 바이블처럼 여기는 &lt;a href=&quot;https://poiemaweb.com/&quot;&gt;PoiemaWeb&lt;/a&gt; 글을 참고하여 공부하며 정리하기를 좋아합니다.&lt;/p&gt;
&lt;h2 id=&quot;제네레이터-왜-등장했을-까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0-%EC%99%9C-%EB%93%B1%EC%9E%A5%ED%96%88%EC%9D%84-%EA%B9%8C&quot; aria-label=&quot;제네레이터 왜 등장했을 까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;제네레이터, 왜 등장했을 까?&lt;/h2&gt;
&lt;p&gt;제네레이터는 ES6에서 도입된 새로운 함수입니다. 그 역할은 이터러블을 간편하게 구현할 수 있도록 고안된 함수라고 설명합니다.&lt;/p&gt;
&lt;p&gt;그렇다면, 제네레이터를 사용하지 않고 어떻게 이터러블을 구현하는 지 알아보면, 제네레이터의 등장이 더 와닿을 수 있을 것 같은데요.&lt;/p&gt;
&lt;p&gt;여기서 먼저 짚고 넘어가고 싶은 것은, 제네레이터를 이야기 할때면 꼭 등장하지만 늘 혼동되는 이터레이션 (iteration), 이터러블 (iterable), 이터레이터 (iterator)를 먼저 알아보고, 제네레이터를 사용하지 않고 어떻게 이터러블을 구현하는 지 알아봅시다.&lt;/p&gt;
&lt;h2 id=&quot;이터레이션-프로토콜-데이터-순회-이렇게-약속하자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%EC%85%98-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%88%9C%ED%9A%8C-%EC%9D%B4%EB%A0%87%EA%B2%8C-%EC%95%BD%EC%86%8D%ED%95%98%EC%9E%90&quot; aria-label=&quot;이터레이션 프로토콜 데이터 순회 이렇게 약속하자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이터레이션 프로토콜, 데이터 순회 이렇게 약속하자&lt;/h2&gt;
&lt;p&gt;ES6에서 도입된 이터레이션 프로토콜 (Iteration Protocol)은 데이터 컬렉션을 순회하기 위한 프로토콜입니다.
여기서, 이터레이션 프로토콜에는 이터러블 프로토콜 그리고, 이터레이터 프로토콜이 있습니다. 용어가 벌써 혼동되기 시작하는데,
심호흡 한번 하고 넘어가보죠.&lt;/p&gt;
&lt;h2 id=&quot;이터러블-순회할-수-있는-데이터-공급자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94-%EC%88%9C%ED%9A%8C%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EA%B8%89%EC%9E%90&quot; aria-label=&quot;이터러블 순회할 수 있는 데이터 공급자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이터러블, 순회할 수 있는 데이터 공급자&lt;/h2&gt;
&lt;p&gt;이터러블 프로토콜 (Iterable Protocol)을 준수한 객체를 이터러블이라고 합니다.
구현되었거나, 프로토타입 체인에 의한 상속을 통해 &lt;code class=&quot;language-text&quot;&gt;Symbol.iterator&lt;/code&gt; 메서드를 가지고 있는 객체를 말합니다.&lt;/p&gt;
&lt;p&gt;이터러블은 &lt;code class=&quot;language-text&quot;&gt;for...of&lt;/code&gt; 문에서 순회할 수 있고, &lt;code class=&quot;language-text&quot;&gt;Spread&lt;/code&gt; 문법의 대상이 될 수 있습니다. 번뜩 생각나는 대표적인 객체는 배열입니다.
&lt;code class=&quot;language-text&quot;&gt;for...of&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Spread&lt;/code&gt; 의 대상으로 배열을 사용할 수 있었던 근거가 여기 있었군요.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const numbers = [1, 2, 3, 4, 5];

console.log(Symbol.iterator in numbers); // true

for (let number of numbers) {
  console.log(number);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;반면, 일반 객체는 &lt;code class=&quot;language-text&quot;&gt;Symbol.iterator&lt;/code&gt; 메서드를 가지고 있지 않기 때문에 이터러블이 아닙니다.
프로토타입 체인으로부터 &lt;code class=&quot;language-text&quot;&gt;Symbol.iterator&lt;/code&gt;를상속받지 못했기 때문인데요. 하지만, 구현해준다면 이터러블 프로토콜을 준수한 이터러블이 될 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const object = { a: 1, b: 2, c: 3 };

console.log(Symbol.iterator in object); // false

for (const property of object) {
  // TypeError: object is not iterable
  console.log(property);
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;이터레이터-순회-데이터-공급자의-다음-엘리먼트에는-이렇게-접근하자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0-%EC%88%9C%ED%9A%8C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EA%B8%89%EC%9E%90%EC%9D%98-%EB%8B%A4%EC%9D%8C-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8%EC%97%90%EB%8A%94-%EC%9D%B4%EB%A0%87%EA%B2%8C-%EC%A0%91%EA%B7%BC%ED%95%98%EC%9E%90&quot; aria-label=&quot;이터레이터 순회 데이터 공급자의 다음 엘리먼트에는 이렇게 접근하자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이터레이터, 순회 데이터 공급자의 다음 엘리먼트에는 이렇게 접근하자&lt;/h2&gt;
&lt;p&gt;이터레이터 프로토콜 (iterator protocol)을 준수하는 객체를 이터레이터라고 합니다.
next 메서드를 소유하며, 호출 시 이터러블을 순회하며 &lt;code class=&quot;language-text&quot;&gt;value&lt;/code&gt;,&lt;code class=&quot;language-text&quot;&gt;done&lt;/code&gt; 프로퍼티를 갖는 이터레이터 result 객체를 반환하는 객체를 말합니다.&lt;/p&gt;
&lt;p&gt;이터러블은 &lt;code class=&quot;language-text&quot;&gt;Symbol.iterator&lt;/code&gt; 메서드를 가지고 있다고 언급했는데요. 이 메서드를 호출하면 이터레이터를 반환합니다.
물론, 이터레이터 프로토콜을 준수한다면 next 메서드를 가지고 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const arr = [1, 2, 3, 4, 5];

const iterator = arr[Symbol.iterator]();

console.log(&amp;quot;next&amp;quot; in iterator); // true

let resultObject = iterator.next();
console.log(resultObject); // {value: 1, done: false}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;순회 데이터 컬렉션 엘리먼트들을 순회하기 위한 포인터 역할을 담당하는 메서드가 바로 &lt;code class=&quot;language-text&quot;&gt;next&lt;/code&gt; 입니다.
&lt;code class=&quot;language-text&quot;&gt;next&lt;/code&gt; 메서드를 호출하면 이터러블을 순차적으로 순회합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;console.log(iterator.next()); // {value: 1, done: false}
console.log(iterator.next()); // {value: 2, done: false}
...
console.log(iterator.next()); // {value: 5, done: false}
console.log(iterator.next()); // {value: undefined, done: true}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;이터레이션-프로토콜-다양한-데이터-공급자의-약속된-순회-방식을-제공하자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%EC%85%98-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EA%B8%89%EC%9E%90%EC%9D%98-%EC%95%BD%EC%86%8D%EB%90%9C-%EC%88%9C%ED%9A%8C-%EB%B0%A9%EC%8B%9D%EC%9D%84-%EC%A0%9C%EA%B3%B5%ED%95%98%EC%9E%90&quot; aria-label=&quot;이터레이션 프로토콜 다양한 데이터 공급자의 약속된 순회 방식을 제공하자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이터레이션 프로토콜, 다양한 데이터 공급자의 약속된 순회 방식을 제공하자&lt;/h2&gt;
&lt;p&gt;이터레이션 프로토콜에 속하는 이터러블 프로토콜과 이터러블 그리고, 이터레이터 프로토콜과 이터레이터를 간단하게 알아봤는데요.
이터레이션 프로토콜이 왜 필요할까요?&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Array&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;String&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Map&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Set&lt;/code&gt; 등 다양한 데이터 공급자들이 각각의 순회 방식을 갖고 있다면, 다양한 순회 방식을 지원하는
데이터 소비자가 필요합니다. 가령, &lt;code class=&quot;language-text&quot;&gt;Array&lt;/code&gt;는 &lt;code class=&quot;language-text&quot;&gt;for...of&lt;/code&gt;로 순회할 수 있지만, &lt;code class=&quot;language-text&quot;&gt;String&lt;/code&gt; 은 &lt;code class=&quot;language-text&quot;&gt;String&lt;/code&gt; 만의 데이터 소비자가 필요하게 되는 것이죠.&lt;/p&gt;
&lt;p&gt;결국, 이터레이션 프로토콜이 하고자 하는 목적은 다양한 데이터 공급자인 소스들이 동일한 약속된 순회 방식을 갖도록 하여
데이터 소비자에게 일정한 인터페이스를 제공하자는 것이 목적입니다.&lt;/p&gt;
&lt;h2 id=&quot;제네레이터를-사용하지-않고-이터러블을-생성해보자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EA%B3%A0-%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%B4%EB%B3%B4%EC%9E%90&quot; aria-label=&quot;제네레이터를 사용하지 않고 이터러블을 생성해보자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;제네레이터를 사용하지 않고, 이터러블을 생성해보자&lt;/h2&gt;
&lt;p&gt;제네레이터와 관련된 프로토콜에 대한 용어 정의를 간단하게 했으니, 이제 다시 본론으로 돌아와 제네레이터를 사용하지 않고
이터레이션 프로토콜을 준수하는 이터러블을 구현해보겠습니다.&lt;/p&gt;
&lt;p&gt;이터레이션 프로토콜인 이터러블 프로토콜을 준수하기 위해 &lt;code class=&quot;language-text&quot;&gt;Symbol.iterator&lt;/code&gt; 메서드를 구현하여 이터레이터를 반환해주었고,
&lt;code class=&quot;language-text&quot;&gt;next&lt;/code&gt; 메서드를 구현하여 이터레이터 프로토콜을 준수해 주었습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const arithmeticSequence = (function () {
  let cur = 0;

  return {
    [Symbol.iterator]() {
      return this;
    },
    next() {
      cur += 1;
      return { value: cur, done: cur === 5 };
    },
  };
})();

for (let cur of arithmeticSequence) {
  console.log(cur); // 1, 2, 3, 4
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;제네레이터를-사용해서-이터러블을-생성해보자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%B4%EB%B3%B4%EC%9E%90&quot; aria-label=&quot;제네레이터를 사용해서 이터러블을 생성해보자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;제네레이터를 사용해서 이터러블을 생성해보자&lt;/h2&gt;
&lt;p&gt;위와 동일한 데이터 컬렉션을 가지는 이터러블을 제네레이터를 통해 구현해보겠습니다.
상단의 구현방법보다 훨씬 간편하게 이터러블을 생성할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const arithmeticSequence = (function* () {
  let cur = 0;

  while (cur &amp;lt; 4) {
    cur += 1;
    yield cur;
  }
})(); //prettier issue  =&amp;gt; }());

for (let cur of arithmeticSequence) {
  console.log(cur); // 1, 2, 3, 4
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;제네레이터-동작-방식과-정의&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D%EA%B3%BC-%EC%A0%95%EC%9D%98&quot; aria-label=&quot;제네레이터 동작 방식과 정의 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;제네레이터, 동작 방식과 정의&lt;/h2&gt;
&lt;p&gt;제네레이터는 일반 함수와 다르게 함수의 코드 블록을 한 번에 실행하지 않고, 함수 코드 블록 실행을 잠시 멈추었다가
필요한 시점에 재시작할 수 있습니다.&lt;/p&gt;
&lt;p&gt;일반 함수를 호출하면 return 문에서 반환하는 값을 반환받게 되는데, 제네레이터 함수를 호출하면 제네레이터를 반환받습니다.&lt;/p&gt;
&lt;p&gt;이 제네레이터는 이터러블이면서, 이터레이터인 객체입니다. 즉, 프로토콜을 입각해 생각해보면 &lt;code class=&quot;language-text&quot;&gt;Symbol.iterator&lt;/code&gt; 메서드를
소유함과 동시에 &lt;code class=&quot;language-text&quot;&gt;next&lt;/code&gt; 메서드를 소유하는 객체를 가지고 있는 이터레이터입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function* counter () {
  for (const count of [1,2,3,4,5]) yield count;
}

let generator = counter();

console.log(Symbol.iterator in generator);  // true

for (const count of generator) {
  console.log(count);
}

generator = counter();

console.log(&amp;#39;next&amp;#39; in generator);  // true

console.log(generator.next()); // {value: 1, done: false}
console.log(generator.next()); // {value: 2, done: false}
...
console.log(generator.next()); // {value: 5, done: false};
console.log(generator.next()); // {value: undefined, done: true}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;제네레이터-비동기-처리에-사용해보자&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90&quot; aria-label=&quot;제네레이터 비동기 처리에 사용해보자 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;제네레이터, 비동기 처리에 사용해보자&lt;/h2&gt;
&lt;p&gt;제네레이터를 사용하면 비동기 처리를 동기처럼 동작하도록 구현할 수 있습니다. 가령, 사이드 이펙트가 존재하는 API 함수에서
데이터를 성공적으로 전달받았을 때 혹은 실패하였는 지 결과를 기다린 후에 next 메서드를 통해 연개된 동작을 재시작할 수 있습니다.&lt;/p&gt;
&lt;p&gt;ES7에서 도입된 &lt;code class=&quot;language-text&quot;&gt;async, await&lt;/code&gt; 를 통해 제네레이터보다 직관적으로 비동기 처리를 동기적으로 처리할 수 있게 됐지만, 참고할 만한 동작입니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function getUser(generator, username) {
  fetch(`https://api.github.com/users/${username}`)
    .then((res) =&amp;gt; res.json())
    .then((user) =&amp;gt; generator.next({ userName: user.name, error: false }))
    .catch((error) =&amp;gt; generator.next({ userName: &amp;quot;unknown&amp;quot;, error: true }));
}

const generator = (function* () {
  let user;
  user = yield getUser(generator, &amp;quot;youthfulhps&amp;quot;);
  if (user.error) {
    //...handle error
    return;
  }

  console.log(user.userName);
})();

generator.next();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h2 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h2&gt;
&lt;p&gt;실무에서 당연하게 사용하고 있었던 리덕스 사가의 제네레이터에 대한 개념을 다시 한번 정리해서 흝어져있던
퍼즐이 다시 맞춰지는 것 같아 기분이 좋습니다. 실무에서 경험한 것들을 정리하는 위주로 블로그를 활용했었는데
종종 공부하는 글도 적는 습관을 들여야 할 것 같습니다 :)&lt;/p&gt;
&lt;h2 id=&quot;reference&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#reference&quot; aria-label=&quot;reference permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Reference&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://poiemaweb.com/es6-iteration-for-of&quot;&gt;https://poiemaweb.com/es6-iteration-for-of&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://poiemaweb.com/es6-generator&quot;&gt;https://poiemaweb.com/es6-generator&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[OpenAPI 스펙 주도 개발을 통해 클라이언트 개발 환경을 개선하기 위한 노력들]]></title><description><![CDATA[클라이언트 개발을 하다보면 작업이 대기 상태가 되버리는 경우를 자주 경험합니다.
기획과 API…]]></description><link>https://youthfulhps.dev/development/benefits-specification-driven-development/</link><guid isPermaLink="false">https://youthfulhps.dev/development/benefits-specification-driven-development/</guid><pubDate>Thu, 28 Oct 2021 09:05:28 GMT</pubDate><content:encoded>&lt;p&gt;클라이언트 개발을 하다보면 작업이 대기 상태가 되버리는 경우를 자주 경험합니다.
기획과 API 개발이 완료되지 않아 기다리거나, 마이너한 기획의 변경 사항이
발생하는 경우, 최종 산출물을 다루는 클라이언트 개발 영역에서의 수정사항은
눈덩이처럼 불어납니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 690px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC4UlEQVQozy2S3VMTVxjGc9dxxhmLNoSEfO1uNml2N9mQIAgkoIkQYiCEhAAhCRCSYD6UQYrWqa1UKSNWHfshOFOnV144Mt563T/t18PoxTPve87F73nO+x7LYN8AbqsDl9VGNDTG4q0auXSZufSaUJnp6wWGAjq6x0NQUQnrJtnpIq1aj9Z6l61Km621Ns1aR9TbWFyXBbDfgdvuRHZKSE4f0qCC7PajuiSmjSCRASvSxQsELl/C8Pm5FoszfjUhFGdidJK40MRIQvSJc6AVWcBCXgnF7sIrJIlzQPbjvvId9/M5fi4tsX1jihlVxttvI6SFMbQQhh5C/97ACApphrg3sCg2O6mAymJII+GTUJ1eJIcHxaOgeRUe5Bc47XV5Ud+kl0oyqqqYepiwgGoCFA5FMMNDopqYZhSL4RhkL5PmaHWV2/FxNKebgBRAcfsIKQFebbf4d/8H3nS7HK9VmI5dxS+rRIM6jXyBWCT2BfoVbBkRw/51qcjvlSrtRBxT8hExRtHUmJinQiWZ5K9mk5cCtn0zJcwUismbvPtxn8NeD00kjQrouWJDw1gmgxqHpRKHC3l2JieRrXZsV7yY2qhYlIdhr8zxeo39bIZZsQhVpK/Pz3Pyy3OmxjPouk44HPmS8vzJm9l5HpWW2UmmqAnn6+YQEacd/Typ36CYrvGkUmNTmJnhPD5lCps1woDjBh5vmlupRcq5JVbmCiwLWdrVNt3aNve7D5mfKZBLZsinciJhkkikSGHliOzcvvh7HcZGVhnov0bft1HcriSyLBIG0uxUt9jbaHJvo4Glkq9yp7nLvfZPrK+0eHn8Nydv3nN6esbb0w98OPuPJ88+8cfJZ84+fuaft+9ZKnY4ePya8souF74xKC00eHbwnIMHT7E0VhuiOaJVvUuj0qFe22U23WB2ps5ysUdn7x3ljT951Dpgq/6QbKaB1z3GxFiRgDpD36Vh9OAsvz1+wfHT1/wPMweNVHQlodsAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;A man with an awkwardly raised hand&quot;
        title=&quot;A man with an awkwardly raised hand&quot;
        src=&quot;/static/b8727cde6de119e0ea1caf4a9627128d/1e043/thumbnail.png&quot;
        srcset=&quot;/static/b8727cde6de119e0ea1caf4a9627128d/5a46d/thumbnail.png 300w,
/static/b8727cde6de119e0ea1caf4a9627128d/0a47e/thumbnail.png 600w,
/static/b8727cde6de119e0ea1caf4a9627128d/1e043/thumbnail.png 690w&quot;
        sizes=&quot;(max-width: 690px) 100vw, 690px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h2 id=&quot;스펙-설계-참여하기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%8A%A4%ED%8E%99-%EC%84%A4%EA%B3%84-%EC%B0%B8%EC%97%AC%ED%95%98%EA%B8%B0&quot; aria-label=&quot;스펙 설계 참여하기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;스펙 설계 참여하기&lt;/h2&gt;
&lt;p&gt;기획과 함께 진행되어야 하는 스펙 설계 단계는 항상 참석하고자 했습니다.
순탄한 개발 루틴과 클라이언트 코드 레벨에서의 잡음을 줄여야 하는 입장에서
기획을 보며 많은 시간 고민이 필요했는데요.&lt;/p&gt;
&lt;h3 id=&quot;이거-클라이언트에서-처리하는-게-맞을까요&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4%EA%B1%B0-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EC%97%90%EC%84%9C-%EC%B2%98%EB%A6%AC%ED%95%98%EB%8A%94-%EA%B2%8C-%EB%A7%9E%EC%9D%84%EA%B9%8C%EC%9A%94&quot; aria-label=&quot;이거 클라이언트에서 처리하는 게 맞을까요 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이거 클라이언트에서 처리하는 게 맞을까요?&lt;/h3&gt;
&lt;p&gt;기능상의 특정 상태값을 산출하는 비용을 클라이언트, 서버 중 어디서
담당하는 것이 효율적인 지에 대해 밀고 당기기가 필요했습니다.
이 과정에서 많은 응답 필드들의 효용성을 확인할 수 있는데요.
어떤 것이 불필요하고, 어떤 것이 누락되었는 지 한번 더 생각하게 되는 단계가 됩니다.&lt;/p&gt;
&lt;p&gt;한편으로는 클라이언트 코드 레벨을 지키기 위한 어필이기도 했습니다.
간단한 예시로, 배열 형태의 응답을 특정 필드값으로 소팅을 하는 것을
클라이언트에서 진행해야 하는 경우가 있다면, 클라이언트 개발하는 입장에서
불필요하게 발생하는 비용에 대해 한번쯤은 사전에 공유해보는 것도 중요하다고 생각하게 됩니다.&lt;/p&gt;
&lt;h3 id=&quot;클라이언트-네임스페이스는-주로-api-인터페이스를-따라가니까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-%EB%84%A4%EC%9E%84%EC%8A%A4%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%8A%94-%EC%A3%BC%EB%A1%9C-api-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4%EB%A5%BC-%EB%94%B0%EB%9D%BC%EA%B0%80%EB%8B%88%EA%B9%8C&quot; aria-label=&quot;클라이언트 네임스페이스는 주로 api 인터페이스를 따라가니까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;클라이언트 네임스페이스는 주로 API 인터페이스를 따라가니까&lt;/h3&gt;
&lt;p&gt;클라이언트 코드레벨의 네임스페이스는 주로 API 인터페이스를 따라가는 경향이 큽니다.
그렇다보니, 썩 내키지 않은 이름이지만 오히려 변경했을 때 지저분해지는 코드덕에
유지한채 진행하는 경우가 많았습니다.&lt;/p&gt;
&lt;p&gt;이름 짓기는 항상 고민되지만, 최적의 이름이 아니더라도 적합한 이름에 대해
함께 고민해야 하고 충분히 공감할 수 있는 이름 짓기에 욕심가지고 참여해야 합니다.&lt;/p&gt;
&lt;h3 id=&quot;이-도메인은-처음이니까&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9D%B4-%EB%8F%84%EB%A9%94%EC%9D%B8%EC%9D%80-%EC%B2%98%EC%9D%8C%EC%9D%B4%EB%8B%88%EA%B9%8C&quot; aria-label=&quot;이 도메인은 처음이니까 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;이 도메인은 처음이니까&lt;/h3&gt;
&lt;p&gt;새로운 도메인에 대한 문제를 풀어나가는 과정에서 CRUD가 어떻게 진행될 것이란 것에
대해 미리 큰 그림을 그릴 수 있다면, 작업을 킥오프할 때 큰 자신감을 얻을 수 있습니다.&lt;/p&gt;
&lt;p&gt;주로 데이터를 담아내고 추상화하는 과정에 대한 기획부터 API 설계 단계에서
도메인에 대해 많은 이야기가 오고 가기 때문에, 담당하는 도메인 지식을 미리 파악하는
자세를 취하고자 했습니다.&lt;/p&gt;
&lt;h2 id=&quot;api-함수와-인터페이스-자동-생성&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#api-%ED%95%A8%EC%88%98%EC%99%80-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EC%9E%90%EB%8F%99-%EC%83%9D%EC%84%B1&quot; aria-label=&quot;api 함수와 인터페이스 자동 생성 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;API 함수와 인터페이스 자동 생성&lt;/h2&gt;
&lt;p&gt;실무에서 V2 API가 등장하게 되었습니다. 새로운 API 함수와 관련 인터페이스들을
다수 새롭게 정의했어야 했는데, 번거롭고 휴먼에러가 발생할 여지가 많은 작업인 만큼
작업의 체력소모가 심했습니다.
&lt;a href=&quot;https://www.youtube.com/watch?v=J4JHLESAiFk&quot;&gt;OpenAPI Specification으로 타입-세이프하게 API 개발하기: 희망편 VS 절망편&lt;/a&gt;
을 보고 바로 적용해봐야 겠다 생각했던 작업이기도 했는데요.&lt;/p&gt;
&lt;p&gt;세션에서 소개하는 &lt;a href=&quot;https://github.com/OpenAPITools/openapi-generator&quot;&gt;openapi-generator&lt;/a&gt;
는 API 명세서를 기준으로 API 함수와 인터페이스들을 자동으로 정의해주는 생성기들을 제공합니다.
간단하게 설치를 진행하고 설정 파일을 추가해서 데모를 진행해봅시다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;openapi-generator는 jvm 환경에서 동작하기 때문에,
로컬에 java sdk가 설치되어 있어야 커멘드 가능합니다.&lt;/em&gt;&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ yarn add @openapitools/openapi-generator-cli -g&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// openapi.json

{
  &amp;quot;modelPackage&amp;quot;: &amp;quot;src/model&amp;quot;,
  &amp;quot;apiPackage&amp;quot;: &amp;quot;src/api&amp;quot;,
  &amp;quot;withSeparateModelsAndApi&amp;quot;: true
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이후 서빙되어 있는 API 명세서의 주소를 입력으로 고정해두면 API가 업데이트됨에
따라 스크립트를 통해 업데이트된 API와 인터페이스들을 취할 수 있게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;json&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// package.json

&amp;quot;script&amp;quot;: {
  &amp;quot;generate-interface&amp;quot;: &amp;quot;openapi-generator-cli generate -i https://.../openapi.json
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ yarn generate-interface&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;API 함수와 인터페이스 정의 자동화를 통해 휴먼에러를 최소화하고 비즈니스 로직에
집중할 수 있게 해주고 또한, 스펙을 기준으로 백엔드단과 소통할 수 있는 환경을
이끌 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;생성된 결과물은 &lt;a href=&quot;https://github.com/youthfulhps-tutorial/react-typescript-openapi-generator&quot;&gt;데모&lt;/a&gt;
에서 확인하실 수 있습니다.&lt;/em&gt;&lt;/p&gt;
&lt;h2 id=&quot;api-목킹하기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#api-%EB%AA%A9%ED%82%B9%ED%95%98%EA%B8%B0&quot; aria-label=&quot;api 목킹하기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;API 목킹하기&lt;/h2&gt;
&lt;p&gt;클라이언트 개발 단계의 대기 상태를 최소화하기 위해 실제 API가 개발되기 전에
API 목킹이 필요했습니다. &lt;a href=&quot;https://stoplight.io/open-source/prism&quot;&gt;Prism&lt;/a&gt;
을 통해 API 명세서에 따라 API 목킹하여 로컬에서 서버를 실행할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ yarn global add @stoplight/prism-cli&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ prism mock https://.../openapi.json&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 915px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 49%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABk0lEQVQoz32S207CQBRF+RkotNwslELLTdpCC7QUCq0gxkTjuz75G3IR49duz0wRUMGHk5lkkpW195mEWjPw/PIKaxBBKJmoVA0oaodPvqijKDf4FK7qyOU1CBkFabFyOH9PIi0q+Nh9YhA9QVAdtNoO5HILdj9A1x5j4IZwRzdwBlN0uj7S2SpS6fJFaELKVbFabdGfPSJFhrpuQsrV4PSnHDIazzEObgkaYURn23D5+0VDMatis37nwGTJQJsMi3KT2/WcCTf0yLA/nMGmUTQrtjsDOwDXeyAzbDR71F2d27Hx/DkmwZIDVb0LQaLIQulHl6e2R8OQgGULmmYiS+WzDtmw/lhsFtnq+chIKkR6z1CXZzuMDbccmCTDVsvmhizuN9AfLzD0Qn52qEPNGEEs6AQs/xf5gQxNbijl46UwoOcTcBID2V1hsVnMk03/jbzZxUuRTTSbNv25RrwUe78U6pH1GYT3uPYWSF3Y8PHbvG0wvKMOK9ewLA81smBRh17E+2NLCaZLOG4EWbdpKfJF4Be8KV3V3P/lnwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;mock&quot;
        title=&quot;mock&quot;
        src=&quot;/static/1ebe9205c33274a94f940b4df121e195/4255a/mock-log.png&quot;
        srcset=&quot;/static/1ebe9205c33274a94f940b4df121e195/5a46d/mock-log.png 300w,
/static/1ebe9205c33274a94f940b4df121e195/0a47e/mock-log.png 600w,
/static/1ebe9205c33274a94f940b4df121e195/4255a/mock-log.png 915w&quot;
        sizes=&quot;(max-width: 915px) 100vw, 915px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;목서버로 요청을 보내면, API 명세서에 정의되어 있는 모델 예시 데이터를 응답에 담아 전달하기 때문에
예시 데이터가 실제와 유사할 수록 좋습니다.&lt;/p&gt;
&lt;h2 id=&quot;내친김에-목-데이터까지&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%82%B4%EC%B9%9C%EA%B9%80%EC%97%90-%EB%AA%A9-%EB%8D%B0%EC%9D%B4%ED%84%B0%EA%B9%8C%EC%A7%80&quot; aria-label=&quot;내친김에 목 데이터까지 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;내친김에 목 데이터까지&lt;/h2&gt;
&lt;p&gt;API 목킹도 좋지만 정적인 목 데이터가 필요한 경우도 있습니다. 테스트를 할 때
일일히 정의해주어야 하거나, 스토리북 컴포넌트에 전달하고 싶은 경우인데요.&lt;/p&gt;
&lt;p&gt;자동으로 생성된 인터페이스들에 맞춰 목데이터를 생성해주는 &lt;a href=&quot;https://github.com/google/intermock&quot;&gt;intermock&lt;/a&gt;
을 사용해서 목데이터를 생성해봅시다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;shell&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;~$ yarn add intermock&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;간단하게 스크립트를 작성해서 우리가 원하는 인터페이스의 목데이터만을 생성할 수 있도록
구성해봅시다. 여기서 주의할 점은 import 문으로 참조된 인터페이스는 intermock에서
파싱을 해내지 못하기 때문에 우선 모든 인터페이스를 병합해서 하나의 파일로 만들어 주어야 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;let mergedInterfaces = &amp;#39;&amp;#39;;

// 인터페이스가 담겨있는 파일을 모두 순회해서
// import 문이 제거된 인터페이스 파일들을 모두 병합한다.
fs.readdirSync(outputFolder).forEach(fileName =&amp;gt; {
  const rawCode = fs.readFileSync(`${outputFolder}/${fileName}`, &amp;#39;utf8&amp;#39;);

  mergedInterfaces += getRawCodeRemovedImportStatement(rawCode);
});

fs.writeFileSync(
  `${outputFolder}/mergedInterfaces.ts`,
  mergedInterfaces,
  &amp;#39;utf8&amp;#39;
);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이후 병합된 인터페이스 파일 중 원하는 인터페이스를 입력으로 전달받아, 생성된 결과를 다시
파일로 생성해줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const mocked = mock({
  files: [&amp;#39;../allInterfaces.ts&amp;#39;],
  interfaces: [&amp;#39;Admin&amp;#39;],
  language: &amp;#39;typescript&amp;#39;,
});

fs.writeFileSync(
  `mocks/${outputFileName}.js`,
  `export const mock${mocked}`,
  &amp;#39;utf8&amp;#39;
);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;em&gt;생성된 결과물은 &lt;a href=&quot;https://github.com/youthfulhps-tutorial/interface-mock-data-generator&quot;&gt;데모&lt;/a&gt;
에서 확인하실 수 있습니다.&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h3&gt;
&lt;p&gt;기능 개발의 한 사이클에서 블로커를 최소한으로 하여 클라이언트 개발 환경을
개선하기 위해 노력했던 내용들을 정리해보았습니다. 클라이언트도 API 개발과
함께 병렬적으로 진행될 수 있도록 스펙 주도 개발을 적극적으로 도입했고,
리소스가 불필요하게 낭비되는 것을 개선하고자 노력했는데요.&lt;/p&gt;
&lt;p&gt;쉽지 않은 고민과 실제 적용을 위한 팀원들에게 동의를 얻기까지
인사이트를 전달하기 위해 고민했던 시간이었습니다.
클라이언트 개발 환경을 개선할 수 있는 무언가, 그리고 멀지 않은 곳에서
반복적으로 블로커가 되는 문제들을 찾아 해결할 수 있는 개발자가 되고 싶습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[AWS를 통해 클라이언트 호스팅하기]]></title><description><![CDATA[사내에서 사용되는 클라이언트 인프라는 이미 구축되어 있는 경우가 많아
직접 호스팅해볼 기회가 없었는데, 마침 웹 채팅 기능이 담긴 새로운 도메인을
호스팅할 기회가 생겨 그 과정을 정리해볼까 합니다. S3, 빌드된 정적파일 업로드하기 S…]]></description><link>https://youthfulhps.dev/infra/hosting-cra-on-aws/</link><guid isPermaLink="false">https://youthfulhps.dev/infra/hosting-cra-on-aws/</guid><pubDate>Tue, 10 Aug 2021 10:06:19 GMT</pubDate><content:encoded>&lt;p&gt;사내에서 사용되는 클라이언트 인프라는 이미 구축되어 있는 경우가 많아
직접 호스팅해볼 기회가 없었는데, 마침 웹 채팅 기능이 담긴 새로운 도메인을
호스팅할 기회가 생겨 그 과정을 정리해볼까 합니다.&lt;/p&gt;
&lt;h2 id=&quot;s3-빌드된-정적파일-업로드하기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#s3-%EB%B9%8C%EB%93%9C%EB%90%9C-%EC%A0%95%EC%A0%81%ED%8C%8C%EC%9D%BC-%EC%97%85%EB%A1%9C%EB%93%9C%ED%95%98%EA%B8%B0&quot; aria-label=&quot;s3 빌드된 정적파일 업로드하기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;S3, 빌드된 정적파일 업로드하기&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.aws.amazon.com/ko_kr/AmazonS3/latest/userguide/Welcome.html&quot;&gt;S3&lt;/a&gt;는 클라우드 스토리지 서비스입니다.
우선, S3의 컨테이너인 버킷을 생성하고 프로젝트의 빌드된 파일을 업로드합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 824px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 60.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAABdklEQVQoz52SC0/DMAyE+///HEggmAaUrXv23SVNmyZpj0vG0MaQGFj65LpVzxfHUVY12BYNhGyRpimKooCUEkKIC6SQNxEtFkvM5i94fp5hvdkG4bYlFD1H3kgUxzEeHh9xd3ePp9kc8SJBkiRBfLkvsdgVWGUVu4sr1z8RedU8L+hMQuseyrtrFZRSaFX3Rdf9Rh/+ibxqskxwaBpgmjA6dzPWOjj7mVkPw0CHVE3LCorFMI7Q7sjwlR0M3xt3pLcWnbHMjv2nCyy/RTWPtzlIrOsD1rzxU16VNTZ8TmqB11Lg7ZNM9YGy0/BxEvPhXUYdHVZ06Odg2dmxizUGg9YwdK0HA9EbSNJqE8ZyinN3PvzRI0WhNMuQZTlqzjFQNzAUdTyq7zqNR0ZiWevQaLhyGAT7vkdV1djvU+x2+7DcXtwLjRT8zjROITvO89ohZ+iv+p3L/foWI8tz7pIM7v4TYYbK7xl3z++j7+DCOtgg+lc05/4BmXWhFeUgF7MAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;create bucket&quot;
        title=&quot;create bucket&quot;
        src=&quot;/static/620b4edcaf86e2ab6372c1f3b61285a5/c1c45/create-bucket.png&quot;
        srcset=&quot;/static/620b4edcaf86e2ab6372c1f3b61285a5/5a46d/create-bucket.png 300w,
/static/620b4edcaf86e2ab6372c1f3b61285a5/0a47e/create-bucket.png 600w,
/static/620b4edcaf86e2ab6372c1f3b61285a5/c1c45/create-bucket.png 824w&quot;
        sizes=&quot;(max-width: 824px) 100vw, 824px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;하단으로 이동하면, &lt;code class=&quot;language-text&quot;&gt;이 버킷의 퍼블릭 엑세스 차단 설정&lt;/code&gt; 에서 &lt;code class=&quot;language-text&quot;&gt;모든 퍼블릭 엑세스 차단&lt;/code&gt; 을 해제해줍니다. 프로젝트의 빌드된 정적파일이기 때문에 접근을 열어두어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 791px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 75.66666666666666%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAAsTAAALEwEAmpwYAAACRUlEQVQ4y41Ti46iQBDk/z9uVwVUEOTlY1EREBQEtK6rMd5mc5csSdNMz0xNdRVjbLc7mKaF6dSUbGPl+bAsG2EUo23vuF6vGnUt+XZ750bixrm6RlWN0TYtDM8P8DmZYTqzYdkLTAhszfExMXU8k0OmMwufUp+Zc/3mweZihQ/LwcR2sFi6cFwPRVHCIDI/iqJAWV6Q5wUul4tEpVGWpc6f81xzKXOsZWWFtKglKjTSSXfv0Pc9DL7CMILvr5EkG23p8XjoZCcxDA88n0/JAwap318b//VwncGFx+MJQRAqYCTaETyOE1DfOElEzwhRHCPZbHA4HAT0Ph7wLUhCAfliCzQhEhACeN4aazkgEObM/jrAmiHfsRyqbUvUakil3zSu6zoYRKZ+PJ2sdru9siTYdrfDfv+lY7JN04My/F/LfBSQLVv2HK67guO4WEqMv5E1jpfi5GIpzH1lmkgXZNT3g2pKZgxiKSBps2VqyKCjWXbG+XxW5wu6KmMenEs3mdTZbiP/HU2sBZwY6jI15MbVylMGkQIn6jxrYSi6iSGUgzWaxzHXke1Xmgq7vxIYT3ndhSX//p9Rf7sht6bB7da86uOYmdG07dtp415JS95SHXQcR1lQs/l88WZIJqy5rvvWmUxZp6HUs5EDFHBoG1TbGK5s5uIgGDfT1VxvRyGS5CoLdeQ4y7Lx1pTjDeM6giog+74+AG+TYpPEr825Xj8uPMlmjk+nTA1h7Xg86uafD9s2+lfvV9GCTvF6/bwFv4n+lf8AA8hr+iNzS1oAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;public access&quot;
        title=&quot;public access&quot;
        src=&quot;/static/9995d00893a4bffb95957b68f54202a7/cc8d6/public-access.png&quot;
        srcset=&quot;/static/9995d00893a4bffb95957b68f54202a7/5a46d/public-access.png 300w,
/static/9995d00893a4bffb95957b68f54202a7/0a47e/public-access.png 600w,
/static/9995d00893a4bffb95957b68f54202a7/cc8d6/public-access.png 791w&quot;
        sizes=&quot;(max-width: 791px) 100vw, 791px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;다른 설정을 변경하지 않고, 이제 버킷 생성을 눌러주면 버킷 생성이 완료되고, 속성을 변경시켜주러 갑니다.
방금 생성한 버킷을 클릭하고, &lt;code class=&quot;language-text&quot;&gt;속성 탭 / 정적 웹 사이트 호스팅&lt;/code&gt; 을 편집해줍니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 9%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAACCAYAAABYBvyLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAARUlEQVQI153KwQnAMAxD0ey/YzpACr0kOKaWrDSdoPTw+CBUaj3U2ikzUx9DV386XQAUEZ/tv7urmE2R+Q7bDQqkMvOXBWRfnSmU3P/YAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;edit static hosting&quot;
        title=&quot;edit static hosting&quot;
        src=&quot;/static/289c96476e4d198474f0cc8564e23f8e/c1b63/edit-static-hosting.png&quot;
        srcset=&quot;/static/289c96476e4d198474f0cc8564e23f8e/5a46d/edit-static-hosting.png 300w,
/static/289c96476e4d198474f0cc8564e23f8e/0a47e/edit-static-hosting.png 600w,
/static/289c96476e4d198474f0cc8564e23f8e/c1b63/edit-static-hosting.png 1200w,
/static/289c96476e4d198474f0cc8564e23f8e/0f586/edit-static-hosting.png 1498w&quot;
        sizes=&quot;(max-width: 1200px) 100vw, 1200px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;정적 웹 사이트 호스팅&lt;/code&gt; 을 활성화 시켜주고, 기본 페이지와 에러 발생 시 반환되는 페이지 또한 설정해주어야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 806px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 103%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAACaUlEQVQ4y5WU6a6bMBCFef8X65+qarMpOwmXLcGYHcx6OmOIenVFclNLX8AmDMc+M2M4IsZNJiiKAkVZoiTiOMb9HiAIBDzPRxhK5FmGNE2RpdlLjMVqjSWxPxyw3e6w2+1xPB6xWCxhXiwk6RjoXQzP9UiFB9+/aVzXhW07sCwLLs1jCsjqsjcxgiDA+WzCcVxcr6QoSTAMA7quJ1o0TYO6ZmoNz19hhDIiNTYcUspXz7tBRjGECDVhlOASZrBC2lJR0Uc6NG2L9glGRSYkybh/VsCj73utcg5+9gqDHWZTJDnJX5gLoscw8c0wRJJBULBX45naOQzOQ5sMEUIgorPjg2XpTTfRdv8V1Mgqhav1Qbl3wtm8UNp4SLMcQVYiSEvIvHo7mN5yT6khpSQiUkhQlZRlBTYrVw3CQiEuFd4ZWqEsa3hJAT7Le5LDj1K4YQxHRHCJx9wj9Hog9bN7nOLGz+ie13wyN6tqMqVqsfUj/Fhu8XO1w+/tCRvzA4uDidXJonsbf/YmlscLNhdbr/GztSOwdkP8su5YEBuKEVWU2Pzj5jXOlLjXIMItV4gaQNY9QkZ1n+jHdboGNBeK/zNoBK3HquVKkeSyo7uNosTmjpNSTfI59v0jkWcS+pnL/LJFLrMZNaVMVVU6mFJKl9kzWk4ndvYToynkLncYbg7s9mTX+EUuwS881A7fKeRqUaqeusxzZf0E388GjKldOe6ojlsZnyFvXU3tamxdU/ui9aJudX7ydTYgd5o7BeIzZIN4nqQj3IEe81R3bs7VAn6cQ1AljUf3dcvTi7o1vdjqvy23I/18jf8F0+5X+ZxLE7EAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;edit static hosting 2&quot;
        title=&quot;edit static hosting 2&quot;
        src=&quot;/static/77e67c3b8aa57255a65adbd49d21bb56/764be/edit-static-hosting-2.png&quot;
        srcset=&quot;/static/77e67c3b8aa57255a65adbd49d21bb56/5a46d/edit-static-hosting-2.png 300w,
/static/77e67c3b8aa57255a65adbd49d21bb56/0a47e/edit-static-hosting-2.png 600w,
/static/77e67c3b8aa57255a65adbd49d21bb56/764be/edit-static-hosting-2.png 806w&quot;
        sizes=&quot;(max-width: 806px) 100vw, 806px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;변경 사항 저장&lt;/code&gt; 이 완료되었다면, 이제 객체를 업로드만 해주면 됩니다. 프로젝트를 빌드하면 생성되는 모든 파일을
그대로 드래그 &amp;#x26; 드랍 해줍니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 904px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 69.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABu0lEQVQ4y51T7Y7TMBD0g99j8Aj8Pt4AJCQe4UAg8VHR5tN27MRxnKTN3s6mEbmqghOVRp54vePZXVcdSkPHypJvW+q6TtAyb1vm/wGFZO+9iDS+Jd24negfvFow+/SBDo9vyX77TGFI5Fg0hLCChfu+Fy4J3b+h7PEX6cN3qsuS6lqT1ivAjTF0OmXC77m+B6V1TY1rxFnD5Tr3EtZyf517lTsRrOqasiynaRwppUSjrKOs4zhRZB7iQJExDCtijDff64p8VVY1/Tz8pqyo6HjMpETgR27oKbP0tWgoN47dcxXOCwy7traRl4EqUBkAUeUbQ6Y8Uec0OT4QeAgYhMMQ+ki9uIk0zbPw1fkovOLeYmBFsfZfBN2Xj6TfPZB7/4YSl7glANPE32nfivQijlKx1/fx2oZIKnT8xpyhzjdyK5wIIMaYN369YGZMV5zPZ4lDFO7QDtXzLb4LPGkvm/iHYFpICKGnoqx4P0niwImIpatrzc8qzwuJ4zwcq/1Nl8tFOLBxOMPNGMI+BkzTLC8BfLksoqFw4N5vWRZZcQgNxwDgbB+7/UFYIWE7dIttX2t+CcZKwt/OIv4MVPM2tko0l0AAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;upload object&quot;
        title=&quot;upload object&quot;
        src=&quot;/static/8b261d97370ca079c3657ebd471dda16/d9217/upload-object.png&quot;
        srcset=&quot;/static/8b261d97370ca079c3657ebd471dda16/5a46d/upload-object.png 300w,
/static/8b261d97370ca079c3657ebd471dda16/0a47e/upload-object.png 600w,
/static/8b261d97370ca079c3657ebd471dda16/d9217/upload-object.png 904w&quot;
        sizes=&quot;(max-width: 904px) 100vw, 904px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;업로드가 모두 완료되었다면, 이전에 편집했던 &lt;code class=&quot;language-text&quot;&gt;속성 탭 / 정적 웹 사이트 호스팅&lt;/code&gt; 에서 버킷이 호스팅된 URL로 접속해보세요.
index.html 문서의 내용이 랜더링된다면 버킷 생성 과정은 마무리됩니다.&lt;/p&gt;
&lt;h2 id=&quot;cloudfront-전세계에-s3-컨텐츠-제공하기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#cloudfront-%EC%A0%84%EC%84%B8%EA%B3%84%EC%97%90-s3-%EC%BB%A8%ED%85%90%EC%B8%A0-%EC%A0%9C%EA%B3%B5%ED%95%98%EA%B8%B0&quot; aria-label=&quot;cloudfront 전세계에 s3 컨텐츠 제공하기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;CloudFront, 전세계에 S3 컨텐츠 제공하기&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/cloudfront/?nc=sn&amp;#x26;loc=1&quot;&gt;CloudFront&lt;/a&gt;는 컨텐츠 전송 네트워크로서
S3에 담겨있는 컨텐츠들을 미리 각각에 분산시키고 컨텐츠에 접근하고자 하는 클라이언트에게 빠르게 제공합니다.
또한, 캐싱과 HTTPS 프로토콜을 적용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;우선, CloudFront에서 새로운 &lt;a href=&quot;https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/GettingStarted.SimpleDistribution.html&quot;&gt;Distributions&lt;/a&gt;을 생성합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 794px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 94.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAABzUlEQVQ4y6VUXXObMBDk//+7uGmavPQhjg1EiC8BFkh4c3dIJGVwx2k1s3OIEXt7tyeSV1XjrBsUjcHvvIaqDcqyhNYanTFo2xamNXcjeXr6hcfHnzgcfggeHg54fn5ZiFbCe0GESimod4U0TQmZxDzPl4zm+0i0LpFlGeZ5hvde4JzHOI7fwjRNuFwuSJqG+lcUROIw+5nghTwiJrkHTJzUdYMzlZrl77B2pCxWMg3DAk50vV4xE65/AS8+m/T9gIb61ZoODfWA9+M4BYxwrJg+8DtqdwnrmsbmnKJQBdIsh2476UfsC0dr7afS0IrbCocBZVULdFXBkEJ+11HkkpfnHpaItyp3CY2U2ctmCirkwNfDIX41a6tyJaxYGd0MVmEMl+s+3eUYMO9gl5B71FFZpuvWXvnN6MQEPJ8uxJslV9Q3NiUjQ3jA304ndER+sVZGyIbIh7drl3CgmdNlJWXzx5x5cXeSGLFVdNNlHmL+sygaG1b1L+sPwlxpvB6PyOi2HN/O0M3iehwZxsAIt0fe9cuejWQP4hLCU9GgousXFxsQjREjNrdDjHHx2a1ur4TeTaKIS+fm84H/Kpn7VoWbUpI5PIdbB+9BJPwA05LKxOeSUKsAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;create distributions&quot;
        title=&quot;create distributions&quot;
        src=&quot;/static/9b995a10faa6df7cc43a8efeb37b21ca/7de01/create-distribution.png&quot;
        srcset=&quot;/static/9b995a10faa6df7cc43a8efeb37b21ca/5a46d/create-distribution.png 300w,
/static/9b995a10faa6df7cc43a8efeb37b21ca/0a47e/create-distribution.png 600w,
/static/9b995a10faa6df7cc43a8efeb37b21ca/7de01/create-distribution.png 794w&quot;
        sizes=&quot;(max-width: 794px) 100vw, 794px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Origin Domain&lt;/code&gt; 은 어떤 S3 객체를 분산시킬 것인지 선택합니다. 직전에 생성한 S3 버킷 이름 검색 후 선택해주세요.
버킷을 선택하면 자동으로 버킷 엔드포인트가 Name 에 적용되는데, Region 이 빠져있다면, Region을 추가해주어야 합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;txt&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;example.com.s3.amazonaws.com (x)
example.com.s3-website.us-east-1.amazonaws.com (O)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하단으로 내려가면 여러 세팅을 설정할 수 있습니다. 일반적으로 우선 &lt;code class=&quot;language-text&quot;&gt;Viewer Protocol Policy&lt;/code&gt; 설정을 변경합니다.
컨텐츠를 요청한 클라이언트가 HTTP 접속을 시도한다면 보안상의 이유로 강제로 HTTPS로 리다이렉션될 수 있도록 합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 770px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 21.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAUklEQVQY06XOwQrAIAwDUP//Iyc4Wle7gcrm0UwEdx/NJTk94mI8QMxY6b1/vfafuJIzeIBEhJTUhE1Qy40Q9gEyVE+01mwPr/pg8x4iMjEr+AIQpTr30xSJYQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;viewer protocol&quot;
        title=&quot;viewer protocol&quot;
        src=&quot;/static/7041c7f5fc3a8008ac925efa363d65d5/f4b77/viewer-protocol.png&quot;
        srcset=&quot;/static/7041c7f5fc3a8008ac925efa363d65d5/5a46d/viewer-protocol.png 300w,
/static/7041c7f5fc3a8008ac925efa363d65d5/0a47e/viewer-protocol.png 600w,
/static/7041c7f5fc3a8008ac925efa363d65d5/f4b77/viewer-protocol.png 770w&quot;
        sizes=&quot;(max-width: 770px) 100vw, 770px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;다음은 Default root object을 index.html로 설정합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 792px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 12.666666666666668%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAa0lEQVQI112O2wrAIAxD/f/vnOCmjqngg7fMdlPEwiFpHtIKrQ2UUjDWdj2RUkKtdVI2OCsFrTXQDB0jDilxac2FVO69Rwih6wd51zPC//njHGKMXLbChdbeIMsf9ZCu54V9n1nO7MeXo/AFyNTqYUOlsjAAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;default root object&quot;
        title=&quot;default root object&quot;
        src=&quot;/static/9f774ed9de4ec2aebf21267ee9ba48f4/9a86a/default-root-object.png&quot;
        srcset=&quot;/static/9f774ed9de4ec2aebf21267ee9ba48f4/5a46d/default-root-object.png 300w,
/static/9f774ed9de4ec2aebf21267ee9ba48f4/0a47e/default-root-object.png 600w,
/static/9f774ed9de4ec2aebf21267ee9ba48f4/9a86a/default-root-object.png 792w&quot;
        sizes=&quot;(max-width: 792px) 100vw, 792px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;여기까지만 진행한다면, CloudFront에서 제공하는 기본 URL을 사용해 배포되게 됩니다.
만약, &lt;code class=&quot;language-text&quot;&gt;Alternative Domain Names (CName)&lt;/code&gt; 을 사용하고자 한다면,
&lt;code class=&quot;language-text&quot;&gt;SSL Certicifate / Custom SSL Certicifate&lt;/code&gt; 를 선택해 인증서를 넣어주세요.
미리 생성해둔 인증서가 없다면 새롭게 생성해야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 784px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 31.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA1klEQVQY031Qia6DMAzj/z9zA9qyHkAPxumXdK/VNGmLZJmkJbXdaK3Rth26roOQkrjP3AsBN45Iy4KYEhIhxpj5ui5wFX6vJtCl272FNhbHceA8L8JZwbOCfX+BF32iPNBM8wypFAwtfDw0WLHWhnoDay3BQc0RNq34VWVpw7aUGjAMAwTZlFLl73VdK57M2/bfb3W+0YxxkJOq0PsA6xwMqZmmCT4EeO9rbjk7Zsry1S85S3bGrhz9y3HUhTYsEKOHcDN653FyJnTI/BWkaKclRfG75T9ylNJzfFq41AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;acm&quot;
        title=&quot;acm&quot;
        src=&quot;/static/3df95d492ff958049fe61edc6268a7fb/4971b/acm.png&quot;
        srcset=&quot;/static/3df95d492ff958049fe61edc6268a7fb/5a46d/acm.png 300w,
/static/3df95d492ff958049fe61edc6268a7fb/0a47e/acm.png 600w,
/static/3df95d492ff958049fe61edc6268a7fb/4971b/acm.png 784w&quot;
        sizes=&quot;(max-width: 784px) 100vw, 784px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이후, 컨텐츠를 Edge Location으로 전파시키는 데 시간이 소요됩니다.
Enabled 상태가 되면 CloudFront distributions 생성도 완료가 됩니다&lt;/p&gt;
&lt;h2 id=&quot;route53-도메인-입히기&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#route53-%EB%8F%84%EB%A9%94%EC%9D%B8-%EC%9E%85%ED%9E%88%EA%B8%B0&quot; aria-label=&quot;route53 도메인 입히기 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Route53, 도메인 입히기&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://aws.amazon.com/ko/route53/&quot;&gt;Route53&lt;/a&gt;는 AWS에서 제공하는 &lt;a href=&quot;https://aws.amazon.com/ko/route53/what-is-dns/&quot;&gt;DNS&lt;/a&gt; 서비스 입니다.&lt;/p&gt;
&lt;p&gt;우선, 레코드를 생성합니다. 레코드 이름은 사용하고 있는 호스팅 영역이 있다면 도메인 앞에 붙을 값만 설정해주면 됩니다.
레코드 유형은 &lt;code class=&quot;language-text&quot;&gt;A&lt;/code&gt; 로, 트래픽 라우팅 대상은 &lt;code class=&quot;language-text&quot;&gt;별칭 선택 / CloudFront 배포에 대한 별칭&lt;/code&gt; 으로 직전 생성한 CloudFront를 선택합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1074px; &quot;
    &gt;
      &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 42.33333333333334%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABAElEQVQoz5VRi2rDMAz0/3/iRjtGC2ne8fuV5CZ5DaRZNpjgcGTJpztFNE2L2+2Ouu1gQ0ROCekfiDGVN4PxqKWDMMZAaw2OZV2xHnAWZzXrAyapIJRSGCaFmOeXpnme0XYdmmGCsRbWOmga7kOAMRZVVaFqeii6pxEYbUTdjxCaiooUeprAzZmINjuBcktk7MK6b0K+U9rg7XLF+/UDn7SucZLox7Gc4tUK/rS6BQuo6qZYbLseD/ru+gFSaQjvPVlymJ8kG9WyLEVZjPHH3jKth1fCuWPlNIDzlDOElBIP+tPp2cTIVAhExEqOhHv1Z07EvrjscHz4K8Aqfdkfn1+pIXGov9yueQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;create record&quot;
        title=&quot;create record&quot;
        src=&quot;/static/e0ba3ba55cf98c68ea130daa27f8b537/18539/create-record.png&quot;
        srcset=&quot;/static/e0ba3ba55cf98c68ea130daa27f8b537/5a46d/create-record.png 300w,
/static/e0ba3ba55cf98c68ea130daa27f8b537/0a47e/create-record.png 600w,
/static/e0ba3ba55cf98c68ea130daa27f8b537/18539/create-record.png 1074w&quot;
        sizes=&quot;(max-width: 1074px) 100vw, 1074px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;최종적으로, 레코드 이름으로 설정한 값을 도메인으로 CloudFront와 연결되어 호스팅된 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;h2 id=&quot;마치면서&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C&quot; aria-label=&quot;마치면서 permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;마치면서&lt;/h2&gt;
&lt;p&gt;간단하게라도 필수적인 과정을 까먹지 않게 정리해봤습니다. 사실, ‘인프라 공부해야지’, ‘직접 구축해봐야지’ 하면서 막상 손데기 힘든 게 사실인데 클라이언트를 개발에서 그치지 않고 직접 배포해보면 조금 더 시아가 넓어지는 듯한 경험을 해본 작업이었습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[about]]></title><description><![CDATA[유병호 (youthfulhps)]]></description><link>https://youthfulhps.dev/resume-en/</link><guid isPermaLink="false">https://youthfulhps.dev/resume-en/</guid><pubDate>Sun, 27 Jan 2019 16:21:13 GMT</pubDate><content:encoded>&lt;h1 id=&quot;유병호-youthfulhps&quot; style=&quot;position:relative;&quot;&gt;&lt;a href=&quot;#%EC%9C%A0%EB%B3%91%ED%98%B8-youthfulhps&quot; aria-label=&quot;유병호 youthfulhps permalink&quot; class=&quot;anchor before&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;유병호 (youthfulhps)&lt;/h1&gt;
&lt;div align=&quot;center&quot;&gt;
&lt;/div&gt;</content:encoded></item></channel></rss>