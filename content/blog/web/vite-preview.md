---
title: Vite preview
date: 2023-03-20 13:03:35
category: web
thumbnail: { thumbnailSrc }
draft: true
---

> '이렇게나 빠른 Vite를 사용하지 않을 이유가 있나요?'

웹 개발을 하면서 가장 익숙하고 자주 접한 번들러를 꼽자면 단연 웹팩일텐데요. 아무래도 많은 프로젝트나 스타터
보일러 플레이트에서 번들러로 웹팩을 사용하고 있어, 비교적 복잡한 설정과 상대적으로 느린 개발 모드 속도에도
자연스럽게 알고 있어야 하는 번들러로 입지를 굳혀 왔습니다.

하지만, 개발 경험을 최대한 끌어올리기 위한 많은 번들러들이 등장하기 시작했는데, Rust 프로그래밍 언어의 특성을
살려 작성된 번들러 (e.g. Turbopack)부터, Native ESM을 사용하여 극적으로 개발 속도를 끌어올린 번들러
(e.g. Vite)까지 웹팩보다 10-100배 빠른 번들링 속도를 언급하며 관심을 모으고 있습니다.

실무에서도 웹팩 외 주목을 받고 있는 번들러를 적용해보고 있는데요. 그 시작으로 최근 팀 내 스쿼드별로 중복 개발의
우려가 있는 유틸성 함수나 비즈니스 로직의 단위를 일치시키고 효율성을 끌어올리고자 팀내 라이브러리를 구축하고 있고,
Vite를 통해 해당 프로젝트를 번들링하고 있습니다. 프러덕션 레벨에서 웹팩 외 타 번들러를 처음 사용하는 만큼,
번들러에 대해 다시 이해해보고, Vite에 대해 찍먹해보는 글을 적어보려 합니다.

## 번들링 작업은 왜 필요할까

애당초 정적인 웹 페이지의 간단한 동적인 요소를 구현하고자 탄생한 자바스크립트는 표준 모듈 시스템을 가지고 있지
않았는데요. 점점 스크립트의 크기가 커지고, 자바스크립트 런타임의 등장과 함께 언어의 역할 범위가 넓어짐에 따라
`CommonJS`, `AMD` 그리고 `import`, `export`을 사용하는 `ESModules` 와 같은 표준 모듈 시스템이
등장하게 되었어요. 이후 런타임 뿐만 아니라, 브라우저와 같은 네이티브 레벨에서도 자바스크립트 모듈 시스템을
해석할 수 있게 되었습니다.

하지만 모듈 시스템을 해석할 수 있는 능력이 있더라도, 웹 페이지를 구성하는 수많은 모듈들을 각각 요청해서 받아와야
하는 이슈가 남아있었습니다. 모듈 갯수와 비례하게 요청 횟수 또한 늘어난다는 것인데, 비동기적인 대기로 인한 병목과
모듈 응답 순서 또한 보장받을 수 없는 문제들이 있었습니다.

번들러는 모듈 시스템 기반으로 개발되었던 프로젝트의 모듈들을 빌드 과정에서 하나의 파일로 번들링해서 브라우저에게
전달하면 요청 횟수를 최소화할 수 있지 않을까 라는 목적으로 등장하게 되었습니다.

## 개발서버에서의 번들링

번들링을 통해 네이티브에서 원하는 모듈을 불러오기 위한 요청 횟수를 극적으로 줄여 모듈의 병목 이슈를 해결할 수
있었는데요. 하지만 번들링은 일종의 우회적인 방법으로 자바스크립트의 모듈 시스템을 풀이한 방식이라는 점은 여전히
짚고 넘어가야 합니다.

개발서버에서 런타임에 제품을 올리기 위해 빌드를 할때면, 번들러에서 열심히 번들링하고 결과물을 로드하는데까지
적게는 수십초가 걸립니다.

```shell
~$ yarn dev
$ webpack serve...
<i> [webpack-dev-server] Project is running at:
<i> [webpack-dev-server] Loopback: http://localhost:3000/, http://127.0.0.1:3000/
<i> [webpack-dev-server] Content not from webpack is served from '.../public' directory
<i> [webpack-dev-server] 404s will fallback to '/index.html'
<i> [webpack-dev-middleware] wait until bundle finished: /
...
webpack 5.75.0 compiled successfully in 18337 ms
```

코드를 수정하고 다시 빌드할때도 HMR 도움을 받지만, 몇초는 기다려야 하는 것이 사실인데요. Vite는 번들링이
개발 경험에 마이너스가 되는 요소라는 점을 해결 문제로 인식합니다.

## Native ESM

Vite는 다시금 네이티브에서 ES 모듈을 해석할 수 있다는 점에 집중하는데요. Evan You 님은 기존 네이티브가
각각의 모듈을 요청하는 방식에 문제가 없었나 싶은 생각이 들 정도로, 네이티브에서 모듈을 처리하는 방식이
개발 속도를 극적으로 빠르게 끌어올려 줄 수 있다고 설명합니다.

굳이 번들링하지 않아도 네이티브가 자바스크립트 파일을 파싱하고, 임포트 구문을 만나면 HTTP를 통해 원하는
모듈에 대한 요청을 보낼 수 있고, 이 과정이 개발 서버에서 상당히 가벼운 처리로 네이티브 영역에서 수행되기
때문에 서버를 시작할 때 많은 준비가 필요 없다고 말하는데요.

여기서, 잠시 Vite에서 제공하는 스크립트를 통해 생성된 프로젝트의 `index.html` 파일을 보면 스크립트
태그를 통해 메인 모듈을 가져오고 있습니다.

```shell
~$ yarn create vite
```

```html
<div id="app"></div>
<script type="module" src="./main.js"></script>
```

여기서 `index.html` 파일이 `public` 에 위치하지 않은 것도 의도적으로 추가 번들링 없이 진입점으로 사용할 수
있도록 하기 위함이라고 합니다.

## 부분적인 번들링

Vite가 번들링을 아예 배제하는 것은 아닙니다. 공식 문서에서 알 수 있듯 ESM 말고도 기존 번들러에서 제공하는 기능을
대부분 지원하고 있으며, 만약 프로젝트가 큰 의존성 모듈을 가지고 있다면, 요청 수를 줄이기 위해 esbuild를 통해
pre-bunling을 진행합니다.

또한, 프러덕션을 위한 빌드시에는 번들링 과정을 거칩니다. 프러덕션 레벨에서는 여전히 번들되지 않은 ESM을 가져오는 것이
중첩된 모듈 불러오기로 인한 네트워크 통신이 발생하는 것이 여전히 비효율적입니다. 번들링 단계에서 트리쉐이킹, 청크 분할
등 더 나은 캐싱을 위해 번들링을 사용하는 것이 좋다고 설명합니다.

## 왜 vite는 빠른가?

## 결국 빌드에는 번들링을 한다는 점
