{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/memoization/","result":{"data":{"site":{"siteMetadata":{"title":"Youthfulhps.dev","author":"youthfulhps","siteUrl":"https://youthfulhps.dev","comment":{"disqusShortName":"youthfulhps","utterances":"youthfulhps/youthfulhps.github.io"},"sponsor":{"buyMeACoffeeId":"youthfulhps"}}},"markdownRemark":{"id":"ae68fd58-2491-5f97-98e8-25442b98f1a3","excerpt":"보통 어플리케이션에서 최적화를 위해 메모이제이션 기법을 통해 이전에 계산한 값을 메모리에\n저장해두고, 동일하게 다시 사용할 수 있는 곳에서 재사용하여 반복적으로 발생하는 계산의\n리소스를 줄이는 기법을 사용하곤 합니다. 리엑트에서도 메모이제이션을 쉽게 구현할 수 있도록 도와주는 API들이 존재하는데요.\n리엑트 공식문서에서 우리가 잘 알고 있는 useMemo\n에 대해 다음과 같이 설명하고 있습니다. “생성(create)” 함수와 그것의 의존성 값의 배열을 전달하세요. useMemo…","html":"<p>보통 어플리케이션에서 최적화를 위해 메모이제이션 기법을 통해 이전에 계산한 값을 메모리에\n저장해두고, 동일하게 다시 사용할 수 있는 곳에서 재사용하여 반복적으로 발생하는 계산의\n리소스를 줄이는 기법을 사용하곤 합니다.</p>\n<p>리엑트에서도 메모이제이션을 쉽게 구현할 수 있도록 도와주는 API들이 존재하는데요.\n리엑트 공식문서에서 우리가 잘 알고 있는 <a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usememo\">useMemo</a>\n에 대해 다음과 같이 설명하고 있습니다.</p>\n<p><em>“생성(create)” 함수와 그것의 의존성 값의 배열을 전달하세요. useMemo는 의존성이\n변경되었을 때에만 메모이제이션된 값만 다시 계산 할 것입니다. 이 최적화는 모든 렌더링 시의\n고비용 계산을 방지하게 해 줍니다.</em></p>\n<p>사실, useMemo를 포함하여 useCallback과 React.memo에 대한 의론적인 배움을 얻고\n사용해왔지만 최근 다시금 공식 문서를 읽었을 때, 문서에서 말하는 고비용의 기준은 무엇인지,\n사용할 수는 있지만 보장되어 있지 않다는 문구의 의미는 무엇인지 등등, 역시 명확한 기준을 제공하지\n않는 리엑트의 모습을 보면서 내가 적절하게 잘 이해하고 적재적소에 사용하며, 실질적인 성능 최적화를\n이루고 있는 건가에 대한 의구심이 들었습니다.</p>\n<p>이 글은 갑자기 낯설게 느껴지는 리엑트 메모이제이션에 대한 찝찝함을 이겨내고자 조금 더 깊게\n알아보고, 가능하면 최적화에 대한 스스로의 기준도 정해보려 합니다. 비슷한 고민을 하시는 분들에게\n도움이 될 수 있으면 좋겠습니다.</p>\n<h2 id=\"usememo-메모이제이션된-값을-반환한다\" style=\"position:relative;\"><a href=\"#usememo-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EB%90%9C-%EA%B0%92%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%9C%EB%8B%A4\" aria-label=\"usememo 메모이제이션된 값을 반환한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMemo, 메모이제이션된 값을 반환한다</h2>\n<p>우선 우리가 잘 알고 있는 리엑트의 메모이제이션을 위한 API를 살펴봅시다. 그 첫 번째로 useMemo는\n값을 메모이제이션합니다. 같은 말로, 메모이제이션된 값을 반환합니다.</p>\n<p>리엑트에서 사용되는 훅들은 <a href=\"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js#L2599\">HookDispatcher</a>\n라는 이름으로 Disaptcher 인터페이스를 갖는 객체로 래핑되어 내부에서 공유되는데,\n여기서 useMemo를 찾아볼 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> HooksDispatcher<span class=\"token operator\">...</span><span class=\"token operator\">:</span> Dispatcher <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  useMemo<span class=\"token operator\">:</span> updateMemo<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><em>onMount, onRerender, onUpdate에 따라 사용되는 HooksDispatcher 객체가 각각 구현되어 있어\n변수명에 (…)을 표기하였습니다.</em></p>\n<p>여기서 useMemo는 updateMemo 라는 함수로 그 구현체가 정의되고 있는데요. 우리가 이해하고 있는\nuseMemo의 역할을 코드로 확인해봅시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">updateMemo</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">nextCreate</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span>\n  deps<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>mixed<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> nextDeps <span class=\"token operator\">=</span> deps <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">:</span> deps<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> prevState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prevState <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextDeps <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> prevDeps<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>mixed<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">=</span> prevState<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">areHookInputsEqual</span><span class=\"token punctuation\">(</span>nextDeps<span class=\"token punctuation\">,</span> prevDeps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> prevState<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> nextValue <span class=\"token operator\">=</span> <span class=\"token function\">nextCreate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>nextValue<span class=\"token punctuation\">,</span> nextDeps<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> nextValue<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>먼저 updateMemo()의 파라미터 nextCreate, deps는 우리가 사용하는 useMemo에서\n메모이제이션할 값을 연산하기 위한 콜백 함수, 그리고 특정값이 변할 때만 새롭게 메모이제이션\n될 수 있도록 전달하는 deps와 대응됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">updateMemo</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">nextCreate</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span>\n  deps<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>mixed<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>함수 내부에서는 로직 전개를 위해 활용될 세 가지의 변수를 가지고 있는데, 여기서 hook\n에는 어떤 값이 할당될까요?</p>\n<p>위에서 봤던 리엑트의 Dispatcher 객체와 마찬가지로, 훅은 <a href=\"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js#L159\">Hook</a>\n이라는 인터페이스를 가진 객체로 되는데, updateWorkInProgressHook()은\n훅으로 관리하고자 하는 값에 대해 직전 랜더링 환경에서 대응되는 훅 객체를 반환하고,\n대응되는 훅 객체가 없다면 새로운 훅 객체를 생성하여 반환합니다.</p>\n<p>nextDeps는 파라미터로 전달받은 deps를, prevState는 직전 랜더링 환경에서 메모이제이션되어\n있던 값을 참조합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Hook</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  memoizedState<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  baseState<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  baseQueue<span class=\"token operator\">:</span> Update<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">any</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  queue<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  next<span class=\"token operator\">:</span> Hook <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> nextDeps <span class=\"token operator\">=</span> deps <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">:</span> deps<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> prevState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span></code></pre></div>\n<p>결국, useMemo는 직전 훅 객체에 메모이제이션된 값과 전달된 deps가 null이\n아니라면, deps로 전달받은 값들이 변경되지 않았음을 검증하는 단계를 거쳐\n메모제이션된 값을 반환합니다.\n<em><a href=\"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js#L343\">areHookInputsEqual()</a>은 여기서!</em></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prevState <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextDeps <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 여기서 prevState는 [value, deps]의 형태</span>\n      <span class=\"token keyword\">const</span> prevDeps<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>mixed<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">=</span> prevState<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">areHookInputsEqual</span><span class=\"token punctuation\">(</span>nextDeps<span class=\"token punctuation\">,</span> prevDeps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> prevState<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">...</span></code></pre></div>\n<p>분기 검증에 실패했다면, 값을 얻기 위한 콜백 함수인 nextCreate()를 통해 값을 구하고,\n현재 새로운 훅 객체의 memoizedState에 deps와 함께 할당합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">const</span> nextValue <span class=\"token operator\">=</span> <span class=\"token function\">nextCreate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>nextValue<span class=\"token punctuation\">,</span> nextDeps<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> nextValue<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>useMemo의 구현체 코드를 보니 콜백함수와 deps를 전달하면, deps가 참조하고 있는 값이 변경되지 않는 한\n메모이제이션된 값을 다시 사용하는 기능을 잘 이해하고 있음을 확인할 수 있었습니다. :)</p>\n<h2 id=\"usecallback-메모이제이션된-콜백을-반환한다\" style=\"position:relative;\"><a href=\"#usecallback-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EB%90%9C-%EC%BD%9C%EB%B0%B1%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%9C%EB%8B%A4\" aria-label=\"usecallback 메모이제이션된 콜백을 반환한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useCallback, 메모이제이션된 콜백을 반환한다</h2>\n<p>useCallback은 인자값으로 전달받은 콜백 함수를 메모이제이션합니다.\n예상할 수 있듯, useCallback의 구현체는 useMemo 구현체와 매우 유사하기 때문에 특별히 다른 부분만 짚고 넘어가겠습니다.</p>\n<p>useCallback는 updateCallback 이라는 함수로 그 구현체가 정의되어 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> HooksDispatcher<span class=\"token operator\">...</span><span class=\"token operator\">:</span> Dispatcher <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  useCallback<span class=\"token operator\">:</span> updateCallback<span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>updateCallback은 updateMemo와 달리, 파라미터로 전달받은 callback 자체를\n메모이제이션하는 것을 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">updateCallback</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>callback<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> deps<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>mixed<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> nextDeps <span class=\"token operator\">=</span> deps <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">:</span> deps<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> prevState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prevState <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextDeps <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> prevDeps<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>mixed<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">=</span> prevState<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">areHookInputsEqual</span><span class=\"token punctuation\">(</span>nextDeps<span class=\"token punctuation\">,</span> prevDeps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> prevState<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// callback 자체를 메모이제이션한다.</span>\n  hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>callback<span class=\"token punctuation\">,</span> nextDeps<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> callback<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>우리가 잘 이해하고 있는 것 처럼, useMemo는 콜백 함수의 연산 반환값을, useCallback은\n콜백 자체를 메모이제이션하는 기능 차이를 확인할 수 있었습니다.</p>\n<h2 id=\"reactmemo-마지막-랜더링된-결과를-재사용한다\" style=\"position:relative;\"><a href=\"#reactmemo-%EB%A7%88%EC%A7%80%EB%A7%89-%EB%9E%9C%EB%8D%94%EB%A7%81%EB%90%9C-%EA%B2%B0%EA%B3%BC%EB%A5%BC-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4\" aria-label=\"reactmemo 마지막 랜더링된 결과를 재사용한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React.memo, 마지막 랜더링된 결과를 재사용한다</h2>\n<p>React.memo는 고차 컴포넌트로서 감싼 컴포넌트 랜더링 결과를 메모이징하고, 동일한 props로\n동일한 결과를 랜더링하는 경우에 대하여 다시 랜더링하지 않고, 다시 마지막으로 랜더링된 결과를\n재사용합니다.</p>\n<p>공식문서에 첨언된 내용에는, React.memo가 props 변화에만 영향을 준다고 설명합니다. 즉,\n컴포넌트 리랜더링이 발생하는 케이스들 중에서 부모 컴포넌트로부터 전달받은 props의 변화로 인해\n발생하는 리랜더링 최적화를 담당합니다.</p>\n<p><a href=\"https://github.com/facebook/react/blob/main/packages/react/src/ReactMemo.js\">React.memo</a>의 구현체를 살펴보면, 엄청난 일이 벌어질 것 같은 예상과는 달리 명확한 단일의 역할만을 담당하고\n있는 고차 컴포넌트의 면모를 잘 보여줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Symbol.for('react.memo');</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span><span class=\"token constant\">REACT_MEMO_TYPE</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'shared/ReactSymbols'</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">...</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">memo</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Props<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  type<span class=\"token operator\">:</span> React$ElementType<span class=\"token punctuation\">,</span>\n  compare<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>oldProps<span class=\"token operator\">:</span> Props<span class=\"token punctuation\">,</span> newProps<span class=\"token operator\">:</span> Props<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">const</span> elementType <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    $$<span class=\"token keyword\">typeof</span><span class=\"token operator\">:</span> <span class=\"token constant\">REACT_MEMO_TYPE</span><span class=\"token punctuation\">,</span>\n    type<span class=\"token punctuation\">,</span>\n    compare<span class=\"token operator\">:</span> compare <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">:</span> compare<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">return</span> elementType<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>개인적으로 생각하는 주목할 점은, React.memo로 감싼 컴포넌트가 react.memo 심볼을\n요소 유형 태그로 할당받게 된다는 점입니다.</p>\n<p>컴포넌트 재조정을 위한 작업을 생성하는 리엑트 리콘실러에서 beginWork() 라는 함수에서는\n위에서 언급한 요소의 유형 태그를 통해 어떤 방식으로 업데이트를 진행할 지 결정합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">beginWork</span><span class=\"token punctuation\">(</span>\n  current<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  workInProgress<span class=\"token operator\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  renderLanes<span class=\"token operator\">:</span> Lanes<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>workInProgress<span class=\"token punctuation\">.</span>tag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token keyword\">case</span> MemoComponent<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>\n      resolvedProps <span class=\"token operator\">=</span> <span class=\"token function\">resolveDefaultProps</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">,</span> resolvedProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">updateMemoComponent</span><span class=\"token punctuation\">(</span>\n        current<span class=\"token punctuation\">,</span>\n        workInProgress<span class=\"token punctuation\">,</span>\n        type<span class=\"token punctuation\">,</span>\n        resolvedProps<span class=\"token punctuation\">,</span>\n        renderLanes<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">...</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서, React.memo에서 할당된 ‘react.memo’ 심볼 유형 태그를 가진 컴포넌트는\nMemoComponent로 구분되어 업데이트 작업이 진행되는데, 우리가 흔히 사용하는 함수형\n컴포넌트와 다르게 업데이트 과정이 진행될 것이라고 짐작할 수 있습니다.</p>\n<p><em>beginWork()를 간추려 첨부했지만, 엄청난 일은 여기서 일어나고 있었구나 싶을 정도로\n요소 유형별 각기 다른 업데이트 방식으로 분류됩니다. 모두 살펴보기엔 일이 커지니 (사실, 무섭습니다.)\n메모 컴포넌트가 어떻게 업데이트되는 지 살펴봅시다.</em></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">updateMemoComponent</span><span class=\"token punctuation\">(</span>\n  current<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  workInProgress<span class=\"token operator\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  Component<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  nextProps<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  renderLanes<span class=\"token operator\">:</span> Lanes<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">|</span> Fiber <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">const</span> currentChild <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">.</span>child<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Fiber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> hasScheduledUpdateOrContext <span class=\"token operator\">=</span> <span class=\"token function\">checkScheduledUpdateOrContext</span><span class=\"token punctuation\">(</span>\n    current<span class=\"token punctuation\">,</span>\n    renderLanes<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hasScheduledUpdateOrContext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> prevProps <span class=\"token operator\">=</span> currentChild<span class=\"token punctuation\">.</span>memoizedProps<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Default to shallow comparison</span>\n    <span class=\"token keyword\">let</span> compare <span class=\"token operator\">=</span> Component<span class=\"token punctuation\">.</span>compare<span class=\"token punctuation\">;</span>\n    compare <span class=\"token operator\">=</span> compare <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> compare <span class=\"token operator\">:</span> shallowEqual<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compare</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> current<span class=\"token punctuation\">.</span>ref <span class=\"token operator\">===</span> workInProgress<span class=\"token punctuation\">.</span>ref<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">bailoutOnAlreadyFinishedWork</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> workInProgress<span class=\"token punctuation\">,</span> renderLanes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  workInProgress<span class=\"token punctuation\">.</span>flags <span class=\"token operator\">|=</span> PerformedWork<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> newChild <span class=\"token operator\">=</span> <span class=\"token function\">createWorkInProgress</span><span class=\"token punctuation\">(</span>currentChild<span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  newChild<span class=\"token punctuation\">.</span>ref <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>ref<span class=\"token punctuation\">;</span>\n  newChild<span class=\"token punctuation\">.</span>return <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">;</span>\n  workInProgress<span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> newChild<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> newChild<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>  </code></pre></div>\n<p>React.memo가 전달받는 컴포넌트와 props 비교 기준이 되는 compare은 이곳에서 사용되는데요.\n만약 compare을 전달하지 않는다면, shallowEqual 즉, 얕은 비교를 통해 이전 props와\n새로운 props를 비교하고, 이 둘이 같지 않다고 판단되면 새롭게 자식트리가 조정됩니다.</p>\n<p>반면, 동일하다고 판단되면 bailoutOnAlreadyFinishedWork()에 의해서 이전에 사용된 자식트리가\n클론되어 재사용됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">bailoutOnAlreadyFinishedWork</span><span class=\"token punctuation\">(</span>\n  current<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  workInProgress<span class=\"token operator\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  renderLanes<span class=\"token operator\">:</span> Lanes<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token comment\">// This fiber doesn't have work, but its subtree does. Clone the child</span>\n  <span class=\"token comment\">// fibers and continue.</span>\n  <span class=\"token function\">cloneChildFibers</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> workInProgress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> workInProgress<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>복잡하고 험난했지만, 이전 props와 새로운 props가 동일하다면 마지막 랜더링된 결과를\n재사용하기 위해 React.memo로 감싸주면 되겠구나 이해할 수 있었습니다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p><a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usecallback\">https://ko.reactjs.org/docs/hooks-reference.html#usecallback</a></p>\n<p><a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usememo\">https://ko.reactjs.org/docs/hooks-reference.html#usememo</a></p>\n<p><a href=\"https://ko.reactjs.org/docs/react-api.html#reactmemo\">https://ko.reactjs.org/docs/react-api.html#reactmemo</a></p>","frontmatter":{"title":"비로소 알게된 리엑트 메모이제이션","date":"September 21, 2022"}}},"pageContext":{"slug":"/react/memoization/","previous":{"fields":{"slug":"/typescript/typescript-essentials-you-should-know/"},"frontmatter":{"title":"타입스크립트, 글로 배웠습니다만"}},"next":null}},"staticQueryHashes":["2486386679","3128451518"]}