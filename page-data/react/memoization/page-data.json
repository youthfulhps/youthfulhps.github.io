{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/memoization/","result":{"data":{"site":{"siteMetadata":{"title":"Youthfulhps.dev","description":"Blog posted front-end, troubleshooting!","author":"youthfulhps","siteUrl":"https://youthfulhps.dev","comment":{"disqusShortName":"youthfulhps","utterances":"youthfulhps/youthfulhps.github.io"},"sponsor":{"buyMeACoffeeId":"youthfulhps"}}},"markdownRemark":{"id":"ae68fd58-2491-5f97-98e8-25442b98f1a3","excerpt":"보통 어플리케이션에서 최적화를 위해 메모이제이션 기법을 통해 이전에 계산한 값을 메모리에\n저장해두고, 동일하게 다시 사용할 수 있는 곳에서 재사용하여 반복적으로 발생하는 계산의\n리소스를 줄이는 기법을 사용하곤 합니다. 리엑트에서도 메모이제이션을 쉽게 구현할 수 있도록 도와주는 API들이 존재하는데요.\n리엑트 공식문서에서 우리가 잘 알고 있는 useMemo\n에 대해 다음과 같이 설명하고 있습니다. “생성(create)” 함수와 그것의 의존성 값의 배열을 전달하세요. useMemo…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 978px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACxklEQVQoz12RW0iTYRiA/9x56jZ3UNvmfndorenm3FzGlgckSjsoakVWooJoSTchkXQgKqIyosBICoUONxGkFJVFZURQhKbdmEGSQhJ0E9RtF0/fnDd28cDLx/c+70ly+aNYXEEi66LU1zVTsqGWgrVlmBweMs15aAxmFLosFFq9QIsyhUaLQq0hYwn1MiJWqZE8gfVYCkNUhyJ0NDRTVF6LUxQxO9egz7Fjyi0gXpYkVBxFm20SQj2qlHxJmhanSceSxe5Fl5PPWqdMeXEEuzdM6s0gRAqdkVDJeiLhGIUFPsxWhxAtC9Xa/0iLJaNI1ButaLLNSBkZKEXbqQSVRofeYMLnCxIsdNNdt5m6REL8UaEUicoV3aVQo0iNbFntJccmi/EcuBwyzQE3DqsNVaYJpxzEmuemsSzK9Y49bE9WkZ3rxWRzimTtSqlqeYfmfA8mqwuDRaa9vYfe+h0EZR82d4icXA+SlEl15RYG+06Q2FCDUxzQYfej0hnEFGmpclmYQsqyusU1XWTozRSHYiT9AdxOL75QBbFwnPNHj/Hy+WvGX3/g6dgbJt9P091+QBSSkNR6gQ5JdCupRKwU+C0G/BYjniwtRYVBSmUPriwdJWUbGTp1nNtHDvFi5DFvxt8xO7vA3PxPJqa+0tbWhV2/itWZSvJ1Ao1EnloUqdz0jJq6VzTUXKapaivbt/VRnriCt2gf4VAlVy8PsPj9F3NzP5j9ssjM5++CeQYGx4hXPKIqcpiKwF6CsQeEI8NIu0ubKC3ahcNXS+v+bvovXaP/6ihbN7Zyof8mv//8ZWZmgY+Ts0xPf2Xy0zc6Ow/hNso0JntpTbawN9ZCfeIi2+JHkbpKAzREw8g2O8cPHubJ3XsMnzvDjRN9vH82ztTbCZ7ef8jI0G1ejY5xtruHpFhPi8dHbzxKf+0mBvbs5M7JPm6dOc0/P+Z1358vUm4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"A person who searches for values in complex records\"\n        title=\"A person who searches for values in complex records\"\n        src=\"/static/a74f6a6ddb4b017b1700cbe4d3036caf/914c7/thumbnail.png\"\n        srcset=\"/static/a74f6a6ddb4b017b1700cbe4d3036caf/5a46d/thumbnail.png 300w,\n/static/a74f6a6ddb4b017b1700cbe4d3036caf/0a47e/thumbnail.png 600w,\n/static/a74f6a6ddb4b017b1700cbe4d3036caf/914c7/thumbnail.png 978w\"\n        sizes=\"(max-width: 978px) 100vw, 978px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>보통 어플리케이션에서 최적화를 위해 메모이제이션 기법을 통해 이전에 계산한 값을 메모리에\n저장해두고, 동일하게 다시 사용할 수 있는 곳에서 재사용하여 반복적으로 발생하는 계산의\n리소스를 줄이는 기법을 사용하곤 합니다.</p>\n<p>리엑트에서도 메모이제이션을 쉽게 구현할 수 있도록 도와주는 API들이 존재하는데요.\n리엑트 공식문서에서 우리가 잘 알고 있는 <a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usememo\">useMemo</a>\n에 대해 다음과 같이 설명하고 있습니다.</p>\n<p><em>“생성(create)” 함수와 그것의 의존성 값의 배열을 전달하세요. useMemo는 의존성이\n변경되었을 때에만 메모이제이션된 값만 다시 계산 할 것입니다. 이 최적화는 모든 렌더링 시의\n고비용 계산을 방지하게 해 줍니다.</em></p>\n<p>사실, useMemo를 포함하여 useCallback과 React.memo에 대한 의론적인 배움을 얻고\n사용해왔지만 최근 다시금 공식 문서를 읽었을 때, 문서에서 말하는 고비용의 기준은 무엇인지,\n사용할 수는 있지만 보장되어 있지 않다는 문구의 의미는 무엇인지 등등, 역시 명확한 기준을 제공하지\n않는 리엑트의 모습을 보면서 내가 적절하게 잘 이해하고 적재적소에 사용하며, 실질적인 성능 최적화를\n이루고 있는 건가에 대한 의구심이 들었습니다.</p>\n<p>이 글은 갑자기 낯설게 느껴지는 리엑트 메모이제이션에 대한 찝찝함을 이겨내고자 셀프 코칭해보며\n조금 더 깊게 알아보고, 가능하면 최적화에 대한 스스로의 기준도 정해보려 합니다. 비슷한 고민을\n하시는 분들에게 도움이 될 수 있으면 좋겠습니다.</p>\n<h2 id=\"usememo-메모이제이션된-값을-반환한다\" style=\"position:relative;\"><a href=\"#usememo-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EB%90%9C-%EA%B0%92%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%9C%EB%8B%A4\" aria-label=\"usememo 메모이제이션된 값을 반환한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMemo, 메모이제이션된 값을 반환한다</h2>\n<p>우선 우리가 잘 알고 있는 리엑트의 메모이제이션을 위한 API를 살펴봅시다. 그 첫 번째로 useMemo는\n값을 메모이제이션합니다. 같은 말로, 메모이제이션된 값을 반환합니다.</p>\n<p>리엑트에서 사용되는 훅들은 <a href=\"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js#L2599\">HookDispatcher</a>\n라는 이름으로 Disaptcher 인터페이스를 갖는 객체로 래핑되어 내부에서 공유되는데,\n여기서 useMemo를 찾아볼 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">const HooksDispatcher...: Dispatcher = {\n  ...\n  useMemo: updateMemo,\n}</code>\n        </deckgo-highlight-code>\n<p><em>onMount, onRerender, onUpdate에 따라 사용되는 HooksDispatcher 객체가 각각 구현되어 있어\n변수명에 (…)을 표기하였습니다.</em></p>\n<p>여기서 useMemo는 updateMemo 라는 함수로 그 구현체가 정의되고 있는데요. 우리가 이해하고 있는\nuseMemo의 역할을 코드로 확인해봅시다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function updateMemo&lt;T&gt;(\n  nextCreate: () =&gt; T,\n  deps: Array&lt;mixed&gt; | void | null\n): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps: Array&lt;mixed&gt; | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n\n  return nextValue;\n}</code>\n        </deckgo-highlight-code>\n<p>먼저 updateMemo()의 파라미터 nextCreate, deps는 우리가 사용하는 useMemo에서\n메모이제이션할 값을 연산하기 위한 콜백 함수, 그리고 특정값이 변할 때만 새롭게 메모이제이션\n될 수 있도록 전달하는 deps와 대응됩니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function updateMemo&lt;T&gt;(\n  nextCreate: () =&gt; T,\n  deps: Array&lt;mixed&gt; | void | null,\n): T {\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>함수 내부에서는 로직 전개를 위해 활용될 세 가지의 변수를 가지고 있는데, 여기서 hook\n에는 어떤 값이 할당될까요?</p>\n<p>위에서 봤던 리엑트의 Dispatcher 객체와 마찬가지로, 훅은 <a href=\"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js#L159\">Hook</a>\n이라는 인터페이스를 가진 객체로 되는데, updateWorkInProgressHook()은\n훅으로 관리하고자 하는 값에 대해 직전 랜더링 환경에서 대응되는 훅 객체를 반환하고,\n대응되는 훅 객체가 없다면 새로운 훅 객체를 생성하여 반환합니다.</p>\n<p>nextDeps는 파라미터로 전달받은 deps를, prevState는 직전 랜더링 환경에서 메모이제이션되어\n있던 값을 참조합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">export type Hook = {\n  memoizedState: any;\n  baseState: any;\n  baseQueue: Update&lt;any, any&gt; | null;\n  queue: any;\n  next: Hook | null;\n};</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">  ...\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  ...</code>\n        </deckgo-highlight-code>\n<p>결국, useMemo는 직전 훅 객체에 메모이제이션된 값과 전달된 deps가 null이\n아니라면, deps로 전달받은 값들이 변경되지 않았음을 검증하는 단계를 거쳐\n메모제이션된 값을 반환합니다.\n<em><a href=\"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js#L343\">areHookInputsEqual()</a>은 여기서!</em></p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">  ...\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      // 여기서 prevState는 [value, deps]의 형태\n      const prevDeps: Array&lt;mixed&gt; | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n  ...</code>\n        </deckgo-highlight-code>\n<p>분기 검증에 실패했다면, 값을 얻기 위한 콜백 함수인 nextCreate()를 통해 값을 구하고,\n현재 새로운 훅 객체의 memoizedState에 deps와 함께 할당합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">  ...\n  const nextValue = nextCreate();\n  hook.memoizedState = [nextValue, nextDeps];\n\n  return nextValue;\n}</code>\n        </deckgo-highlight-code>\n<p>useMemo의 구현체 코드를 보니 콜백함수와 deps를 전달하면, deps가 참조하고 있는 값이 변경되지 않는 한\n메모이제이션된 값을 다시 사용하는 기능을 잘 이해하고 있음을 확인할 수 있었습니다. :)</p>\n<h2 id=\"usecallback-메모이제이션된-콜백을-반환한다\" style=\"position:relative;\"><a href=\"#usecallback-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EB%90%9C-%EC%BD%9C%EB%B0%B1%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%9C%EB%8B%A4\" aria-label=\"usecallback 메모이제이션된 콜백을 반환한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useCallback, 메모이제이션된 콜백을 반환한다</h2>\n<p>useCallback은 인자값으로 전달받은 콜백 함수를 메모이제이션합니다.\n예상할 수 있듯, useCallback의 구현체는 useMemo 구현체와 매우 유사하기 때문에 특별히 다른 부분만 짚고 넘어가겠습니다.</p>\n<p>useCallback는 updateCallback 이라는 함수로 그 구현체가 정의되어 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">const HooksDispatcher...: Dispatcher = {\n  ...\n  useCallback: updateCallback,\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>updateCallback은 updateMemo와 달리, 파라미터로 전달받은 callback 자체를\n메모이제이션하는 것을 확인할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function updateCallback&lt;T&gt;(callback: T, deps: Array&lt;mixed&gt; | void | null): T {\n  const hook = updateWorkInProgressHook();\n  const nextDeps = deps === undefined ? null : deps;\n  const prevState = hook.memoizedState;\n  if (prevState !== null) {\n    if (nextDeps !== null) {\n      const prevDeps: Array&lt;mixed&gt; | null = prevState[1];\n      if (areHookInputsEqual(nextDeps, prevDeps)) {\n        return prevState[0];\n      }\n    }\n  }\n\n  // callback 자체를 메모이제이션한다.\n  hook.memoizedState = [callback, nextDeps];\n  return callback;\n}</code>\n        </deckgo-highlight-code>\n<p>우리가 잘 이해하고 있는 것 처럼, useMemo는 콜백 함수의 연산 반환값을, useCallback은\n콜백 자체를 메모이제이션하는 기능 차이를 확인할 수 있었습니다.</p>\n<h2 id=\"reactmemo-랜더링된-결과를-재사용한다\" style=\"position:relative;\"><a href=\"#reactmemo-%EB%9E%9C%EB%8D%94%EB%A7%81%EB%90%9C-%EA%B2%B0%EA%B3%BC%EB%A5%BC-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4\" aria-label=\"reactmemo 랜더링된 결과를 재사용한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React.memo, 랜더링된 결과를 재사용한다</h2>\n<p>React.memo는 고차 컴포넌트로서 감싼 컴포넌트 랜더링 결과를 메모이징하고, 동일한 props로\n동일한 결과를 랜더링하는 경우에 대하여 다시 랜더링하지 않고, 다시 마지막으로 랜더링된 결과를\n재사용합니다.</p>\n<p>공식문서에 첨언된 내용에는, React.memo가 props 변화에만 영향을 준다고 설명합니다. 즉,\n컴포넌트 리랜더링이 발생하는 케이스들 중에서 부모 컴포넌트로부터 전달받은 props의 변화로 인해\n발생하는 리랜더링 최적화를 담당합니다.</p>\n<p><a href=\"https://github.com/facebook/react/blob/main/packages/react/src/ReactMemo.js\">React.memo</a>의 구현체를 살펴보면, 엄청난 일이 벌어질 것 같은 예상과는 달리 명확한 단일의 역할만을 담당하고\n있는 고차 컴포넌트의 면모를 잘 보여줍니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// Symbol.for(&#39;react.memo&#39;);\nimport {REACT_MEMO_TYPE} from &#39;shared/ReactSymbols&#39;;\n...\n\nexport function memo&lt;Props&gt;(\n  type: React$ElementType,\n  compare?: (oldProps: Props, newProps: Props) =&gt; boolean,\n) {\n  ...\n  const elementType = {\n    $$typeof: REACT_MEMO_TYPE,\n    type,\n    compare: compare === undefined ? null : compare,\n  };\n  ...\n  return elementType;\n}</code>\n        </deckgo-highlight-code>\n<p>개인적으로 생각하는 주목할 점은, React.memo로 감싼 컴포넌트가 react.memo 심볼을\n요소 유형 태그로 할당받게 된다는 점입니다.</p>\n<p>컴포넌트 재조정을 위한 작업을 생성하는 리엑트 리콘실러에서 beginWork() 라는 함수에서는\n위에서 언급한 요소의 유형 태그를 통해 어떤 방식으로 업데이트를 진행할 지 결정합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  ...\n  switch (workInProgress.tag) {\n    ...\n    case MemoComponent: {\n      ...\n      resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderLanes,\n      );\n    }\n    ...\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>여기서, React.memo에서 할당된 ‘react.memo’ 심볼 유형 태그를 가진 컴포넌트는\nMemoComponent로 구분되어 업데이트 작업이 진행되는데, 우리가 흔히 사용하는 함수형\n컴포넌트와 다르게 업데이트 과정이 진행될 것이라고 짐작할 수 있습니다.</p>\n<p><em>beginWork()를 간추려 첨부했지만, 엄청난 일은 여기서 일어나고 있었구나 싶을 정도로\n요소 유형별 각기 다른 업데이트 방식으로 분류됩니다. 모두 살펴보기엔 일이 커지니 (사실, 무섭습니다.)\n메모 컴포넌트가 어떻게 업데이트되는 지 살펴봅시다.</em></p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function updateMemoComponent(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  Component: any,\n  nextProps: any,\n  renderLanes: Lanes,\n): null | Fiber {\n  ...\n  const currentChild = ((current.child: any): Fiber);\n  const hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(\n    current,\n    renderLanes,\n  );\n  if (!hasScheduledUpdateOrContext) {\n    const prevProps = currentChild.memoizedProps;\n    // Default to shallow comparison\n    let compare = Component.compare;\n    compare = compare !== null ? compare : shallowEqual;\n    if (compare(prevProps, nextProps) &amp;&amp; current.ref === workInProgress.ref) {\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n    }\n  }\n\n  workInProgress.flags |= PerformedWork;\n  const newChild = createWorkInProgress(currentChild, nextProps);\n  newChild.ref = workInProgress.ref;\n  newChild.return = workInProgress;\n  workInProgress.child = newChild;\n  return newChild;\n}</code>\n        </deckgo-highlight-code>\n<p>React.memo가 전달받는 컴포넌트와 props 비교 기준이 되는 compare은 이곳에서 사용되는데요.\n만약 compare을 전달하지 않는다면, shallowEqual 즉, 얕은 비교를 통해 이전 props와\n새로운 props를 비교하고, 이 둘이 같지 않다고 판단되면 새롭게 자식트리가 조정됩니다.</p>\n<p>반면, 동일하다고 판단되면 bailoutOnAlreadyFinishedWork()에 의해서 이전에 사용된 자식트리가\n클론되어 재사용됩니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function bailoutOnAlreadyFinishedWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderLanes: Lanes,\n): Fiber | null {\n  ...\n  // This fiber doesn&#39;t have work, but its subtree does. Clone the child\n  // fibers and continue.\n  cloneChildFibers(current, workInProgress);\n  return workInProgress.child;\n}</code>\n        </deckgo-highlight-code>\n<p>복잡하고 험난했지만, 이전 props와 새로운 props가 동일하다면 마지막 랜더링된 결과를\n재사용하기 위해 React.memo로 감싸주면 되겠구나 이해할 수 있었습니다.</p>\n<h2 id=\"usecallback-참조-동일성에-최적화된-컴포넌트에-유효하다\" style=\"position:relative;\"><a href=\"#usecallback-%EC%B0%B8%EC%A1%B0-%EB%8F%99%EC%9D%BC%EC%84%B1%EC%97%90-%EC%B5%9C%EC%A0%81%ED%99%94%EB%90%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90-%EC%9C%A0%ED%9A%A8%ED%95%98%EB%8B%A4\" aria-label=\"usecallback 참조 동일성에 최적화된 컴포넌트에 유효하다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useCallback, 참조 동일성에 최적화된 컴포넌트에 유효하다</h2>\n<p>리엑트는 props의 변경 여부를 얕은 비교를 통해 판단합니다. 자바스크립트에서 원시 타입 값은\n참조값이 다르더라도 값이 같다면 일치 연산자(strict equality operator)에 의해 참이\n판단되지만, 객체, 배열, 함수와 같은 객체는 같은 참조값이 아니라면, 즉 서로 다른 메모리에\n할당되어 있다면 거짓으로 판단됩니다.</p>\n<p>가령 부모 컴포넌트의 상태가 변경되면, 내부에 선언되어 있는 함수들은 모두 새로운 메모리에\n작성됩니다. 결국 자식 컴포넌트 입장에서 이전 onClick의 참조값과 새로운 onClick의 참조값이\n변경되었으니, 자식 컴포넌트도 리랜더링이 발생합니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const ChildA = ({ onClick }) =&gt; {\n  return &lt;button onClick={onClick}&gt;ChildA&lt;/button&gt;;\n};\n\nconst ChildB = ({ onClick }) =&gt; {\n  return &lt;button onClick={onClick}&gt;ChildB&lt;/button&gt;;\n};\n\nfunction Parent() {\n  const [isGood, setIsGood] = useState(false);\n  const handleChildAClick = () =&gt; {\n    setIsGood(!isGood);\n  };\n\n  const handleChildBClick = () =&gt; {\n    console.log(&#39;ChildB clicked!&#39;);\n  };\n\n  return (\n    &lt;&gt;\n      &lt;ChildA onClick={handleChildAClick} /&gt;\n      &lt;ChildB onClick={handleChildBClick} /&gt;\n    &lt;/&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p>여기서, ChildA에 전달되는 클릭 핸들러는 isGood 상태에 의존적인 핸들러로 useCallback을\n사용해도 의존된 값이 항상 변경되니 무용지물입니다.\n하지만, ChildB는 부모 컴포넌트의 상태에 독립적인 핸들러를 전달받음에도 ChildA의 버튼이\n클릭되면 새롭게 생성되는 ChildB 클릭 핸들러로 인해 리랜더링이 발생하는 것은 억울합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 643px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 24.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABE0lEQVQY052O30rCYADF90ZdRE8R9AI9S2/QTV11UUgQZhiYjyBo0FykQW3TZFaIuk+Xc81tftt+fbouuu7A4fy5OBzNjyFa5yyCmGWc46rsS3AjEH7ESuVQ5ST4pDO0WSQg45RUdRvkeb5VKSWmaaIFTpNg2CKfGvDVRYou4aS79cyfwOsU3jNYjVqwdBiNxliWjSsEm7lMjUqZYts22nH1hNO7M0qNMpXHOpV2jYpRo6z0+lcLX+dKv6U5eGDmuljmC+9DhyxLi6dZxlu/j6aPJxhTF30qaM88dDEvOCvY/sN7VzD4Dpl7C55fe/SdD4IwIlU3Y/XQsnto/ANHjTX7NzEH1YS9S8luSbJznnB4YfEDsl9sDG6rQH4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Rerendering chart of childB component\"\n        title=\"Rerendering chart of childB component\"\n        src=\"/static/d6bf574a3af106c463ddcadd467ea2ec/b5bda/childB-rerendering-chart.png\"\n        srcset=\"/static/d6bf574a3af106c463ddcadd467ea2ec/5a46d/childB-rerendering-chart.png 300w,\n/static/d6bf574a3af106c463ddcadd467ea2ec/0a47e/childB-rerendering-chart.png 600w,\n/static/d6bf574a3af106c463ddcadd467ea2ec/b5bda/childB-rerendering-chart.png 643w\"\n        sizes=\"(max-width: 643px) 100vw, 643px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>그럼, ChildB에게 전달되는 핸들러를 useCallback으로 감싸주면 리랜더링을 방지할 수 있을 것 같지만,\n기대와는 다르게 마찬가지로 리랜더링이 발생합니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const handleChildBClick = useCallback(() =&gt; {\n  console.log(&#39;ChildB clicked!&#39;);\n}, []);</code>\n        </deckgo-highlight-code>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 24%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABCUlEQVQY052Oy0rDUBRF81X2Kxz5KzoWf0CRNjrUDn0MBTEgorOK6UxMtDbF2EfS9N3c3tw8lrfBzhy5YZ294RwO2xAKkrRgsZTECUQSlimMdR7PVqh0vdeIKa5zTyggVxlK321UFEXpSaIweu4D/dYT824DObSJek36vq1zExG8sArtEhk8M/EfiUcOwzDgzXHxfZ9EKdb/cj2yLMfYNffYPzvg8OaYqnVCzaphWibVO83GNTXrlKPbKpeNKybTMe+uQ8drI4TY9Cyn0Qp82mEXL+rTGQ3wfun8wWfUY7CYMJ3NeXU+8L6+WcSifJXluqFuafAPmXbK9oVk51pSOZds1VMqdaVJ+QHZp2rQp/rpiwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Rerendering chart of childB component with useCallback\"\n        title=\"Rerendering chart of childB component with useCallback\"\n        src=\"/static/70bd67b3e24d84747e8eb1a2103ebf5c/a6d36/childB-rerendering-chart-with-useCallback.png\"\n        srcset=\"/static/70bd67b3e24d84747e8eb1a2103ebf5c/5a46d/childB-rerendering-chart-with-useCallback.png 300w,\n/static/70bd67b3e24d84747e8eb1a2103ebf5c/0a47e/childB-rerendering-chart-with-useCallback.png 600w,\n/static/70bd67b3e24d84747e8eb1a2103ebf5c/a6d36/childB-rerendering-chart-with-useCallback.png 650w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>useCallback은 참조 동일성에 최적화된 컴포넌트에 유효합니다. 즉, 부모 컴포넌트의 상태에 독립적인 콜백을\nuseCallback으로 감싸고, 전달받는 자식 컴포넌트 또한 React.memo로 감싸서 props를 얕은 비교하는\n과정을 통해 직전 자식 트리를 재사용하는 과정이 포함할 수 있도록 해야 합니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const ChildB = memo(({ onClick }) =&gt; {\n  return &lt;button onClick={onClick}&gt;ChildB&lt;/button&gt;;\n});</code>\n        </deckgo-highlight-code>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 664px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 23.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA7klEQVQY032Qz0rDQBCH81SCj6DP4CN58ahoRE9SUPDoXa8egqYJNQbEHGJDa9J2083++dxsclARB76Z2Z0fw48JjAEhYVFvEa7/2MKngmUHzUb52dphZU30dEcpQEuNdpo+rLWePrpOEST3h1TRCTo7w7yGVHFInYbY/Nz/6Sz0mOyUdXyEertmPq+YTlOKoqDfZVzyOHfB5OGGZplD64bi3dUR8ZvCa5Alq1VDmsTM0gTZCkavPgf8eA71L75rmo3geZYTJS+UiwbpTtUq6wl6m/4G4y3+Q5th/fGjYu+q5eBWsj9R7Fwodi8HvgDsKnfUBZx89wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Rerendering chart of childB component with useCallback and memo\"\n        title=\"Rerendering chart of childB component with useCallback and memo\"\n        src=\"/static/d7911b2f9b50d1bec5cd11a36004542f/31493/childB-rerendering-chart-with-useCallback-and-memo.png\"\n        srcset=\"/static/d7911b2f9b50d1bec5cd11a36004542f/5a46d/childB-rerendering-chart-with-useCallback-and-memo.png 300w,\n/static/d7911b2f9b50d1bec5cd11a36004542f/0a47e/childB-rerendering-chart-with-useCallback-and-memo.png 600w,\n/static/d7911b2f9b50d1bec5cd11a36004542f/31493/childB-rerendering-chart-with-useCallback-and-memo.png 664w\"\n        sizes=\"(max-width: 664px) 100vw, 664px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<h2 id=\"메모이제이션-어떻게-잘-사용할-수-있을까\" style=\"position:relative;\"><a href=\"#%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%98-%EC%82%AC%EC%9A%A9%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C\" aria-label=\"메모이제이션 어떻게 잘 사용할 수 있을까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>메모이제이션, 어떻게 잘 사용할 수 있을까</h2>\n<p>리엑트 메모이제이션에 대해 조금 더 깊게 이해해보기 위해 구현체도 살펴보고, 예제도 간단하게\n구현해보았습니다.</p>\n<p>개념이 명확해지고 어느정도 자신감을 얻었지만 가능하면 최적화에 대한 스스로의 기준도 정해보겠다던\n목표에는 아직 닿지 못한 것 같아 최적화에 대해 먼저 고민하고 정리해주신 레퍼런스들을 읽고\n추합해보면서 개인적인 첨언도 정리해볼까 합니다.</p>\n<h3 id=\"최적화를-위한-코드도-비용이다\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A0%81%ED%99%94%EB%A5%BC-%EC%9C%84%ED%95%9C-%EC%BD%94%EB%93%9C%EB%8F%84-%EB%B9%84%EC%9A%A9%EC%9D%B4%EB%8B%A4\" aria-label=\"최적화를 위한 코드도 비용이다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적화를 위한 코드도 비용이다</h3>\n<p>자주 간과하기 쉬운 주제인 것 같습니다. 가령, 위 단락의 예시에서 ChildA에게 전달하는 핸들러에도\nuseCallback으로 감싸주었다고 생각해봅시다. 그렇다면, 잦은 변경이 발생하는 isGood 상태값에\n의존적인 콜백은 결국 모든 랜더링 과정에서 새롭게 작성될 겁니다.</p>\n<p>결론적으로는 useCallback을 사용하나, 사용하지 않으나 같은 과정이 유발되는데, 여기서 useCallback의\n사용으로 인해 늘어난 코드만큼 비용 또한 늘어났다는 것을 기억해야 합니다.</p>\n<p><a href=\"https://www.rinae.dev/posts/review-when-to-usememo-and-usecallback#%EB%8D%94-%EB%A7%8E%EC%9D%80-%ED%95%A8%EC%88%98-%ED%98%B8%EC%B6%9C-%EB%8D%94-%EB%A7%8E%EC%9D%80-%EC%BD%94%EB%93%9C%EB%8A%94-%EA%B2%B0%EA%B5%AD-%EB%8D%94-%EB%A7%8E%EC%9D%80-%EB%B9%84%EC%9A%A9%EC%9D%84-%EC%B4%88%EB%9E%98%ED%95%9C%EB%8B%A4\">‘When to useMemo and useCallback’ 를 읽고</a></p>\n<h3 id=\"최적화-코드를-이슈-원인으로-열어두자\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A0%81%ED%99%94-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%9D%B4%EC%8A%88-%EC%9B%90%EC%9D%B8%EC%9C%BC%EB%A1%9C-%EC%97%B4%EC%96%B4%EB%91%90%EC%9E%90\" aria-label=\"최적화 코드를 이슈 원인으로 열어두자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적화 코드를 이슈 원인으로 열어두자</h3>\n<p>특정 이슈를 만났을 때, ‘로직의 문제’ 로만 국한되어 접근을 한 경우가 자주 있었습니다.\n아직 부족한 실력탓에 여러 번 삽질 끝에서야 메모이제이션된 값이 적절하게 업데이트되지 않았음을\n깨닫습니다.</p>\n<p>내가 과거에 작성한 최적화 코드라면, 아마 어설프고 우연한 사용으로 디버깅에 고생할 현재는 생각하지 않고 열심히\n뿌듯해 했을텐데요. 우연히 적용한 최적화가 아니라, 최적화를 하겠다고 스스로 약속을 하고\n습관이 될 때까지 항상 상기하는 것이 중요하지 않을까 싶은 대목입니다.</p>\n<h3 id=\"의존된-참조값이-많음을-의심하자\" style=\"position:relative;\"><a href=\"#%EC%9D%98%EC%A1%B4%EB%90%9C-%EC%B0%B8%EC%A1%B0%EA%B0%92%EC%9D%B4-%EB%A7%8E%EC%9D%8C%EC%9D%84-%EC%9D%98%EC%8B%AC%ED%95%98%EC%9E%90\" aria-label=\"의존된 참조값이 많음을 의심하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>의존된 참조값이 많음을 의심하자</h3>\n<p>하단 레퍼런스에서는, 범위 내의 소수들을 모두 구하고 랜더링하는 작업을 진행합니다. 이런 경우 우리가 흔히\n생각하는 ‘고비용 계산’의 정말 좋은 예시라고 생각합니다. 더불어 인터렉션에 의해 체이닝된 메서드들의 계산을\n요구한다면 메모이제이션된 값을 사용할 수 있을 지 충분한 고려가 필요합니다.</p>\n<p>하지만 ‘고비용 계산’의 기준이 쉽게 와닿지 않는다면, 메모이제이션한 값 혹은 콜백이 의존한 외부 값들의\n정량적인 양으로 최적화에 대한 의심을 해볼 수 있을 겁니다.\n의존한 값이 많으면, 의존한 값이 변경됨에 따른 이펙트들에 의해 영향을 받을 가능성이 높고, 위의 예시처럼\n의존된 값의 잦은 변경으로 인해 최적화 하나 마나가 될 수 있는 케이스를 유발할 수 있게 됩니다.</p>\n<p><a href=\"https://medium.com/@yujso66/%EB%B2%88%EC%97%AD-usememo-%EA%B7%B8%EB%A6%AC%EA%B3%A0-usecallback-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-844620cd41a1\">[번역] useMemo 그리고 useCallback 이해하기</a></p>\n<h3 id=\"상단-컴포넌트일수록-효과적이다\" style=\"position:relative;\"><a href=\"#%EC%83%81%EB%8B%A8-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%9D%BC%EC%88%98%EB%A1%9D-%ED%9A%A8%EA%B3%BC%EC%A0%81%EC%9D%B4%EB%8B%A4\" aria-label=\"상단 컴포넌트일수록 효과적이다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상단 컴포넌트일수록 효과적이다</h3>\n<p>자식 컴포넌트의 리랜더링에 대한 큰 책임은 부모 컴포넌트가 가집니다. 때문에, 책임이 큰 상단 컴포넌트일수록\n최적화에 예민하게 접근해야 합니다.</p>\n<p>개인적으로 여러 컴포넌트에 상태 의존성 주입이 필요한 경우 Context API를 사용하곤 하는데, 일반적으로\n컨텍스트가 가진 상태에 의존적인 많은 하위 트리를 지닙니다. 즉, 컨텍스트의 상태 변화는 많은 리랜더링을\n발생시킨다는 것을 명심하고 useMemo, useCallback을 적극적으로 사용해야 합니다.</p>\n<deckgo-highlight-code language=\"jsx\"  >\n          <code slot=\"code\">...\nconst contextState = useMemo(\n  () =&gt; ({\n    isGood,\n    setIsGood,\n  }),\n  [isGood]\n);\n\nreturn &lt;CountContext.Provider value={contextState} /&gt;;</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://yceffort.kr/2022/04/best-practice-useCallback-useMemo#usememo%EC%99%80-usecallback%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%98%EB%8A%94-%EA%B2%BD%EC%9A%B0\">리액트의 useCallback useMemo, 정확하게 사용하고 있을까</a></p>\n<h3 id=\"lint와-꼭-함께-사용하자\" style=\"position:relative;\"><a href=\"#lint%EC%99%80-%EA%BC%AD-%ED%95%A8%EA%BB%98-%EC%82%AC%EC%9A%A9%ED%95%98%EC%9E%90\" aria-label=\"lint와 꼭 함께 사용하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>lint와 꼭 함께 사용하자</h3>\n<p>리엑트 메모이제이션 API를 사용할 때, deps에 의존성을 가진 참조값을 추가하지 않는 경우도 종종 발생합니다.\n이러한 점검을 린팅 도구에게 맡겨 휴먼 에러를 최소화할 수 있습니다.</p>\n<p><a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usecallback\">hooks-reference#useCallback</a></p>\n<p><a href=\"https://www.npmjs.com/package/eslint-plugin-react-hooks\">eslint-plugin-react-hooks</a></p>\n<h2 id=\"마치면서\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C\" aria-label=\"마치면서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치면서</h2>\n<p>리엑트 메모이제이션을 위한 API들이 어떻게 구현되어 있는 지, 그리고 적절한 사용 기준을 정리해보았는데요.\n아무렴 궁극적인 목표는 습관성(?) 최적화입니다. 기능 개발을 하면서 당연하게 사용되는 메모이제이션 API,\n그리고 소수점 초단위의 성능 향상을 고려할 줄 아는 개발을 꿈꿉니다.</p>\n<p>잘못된 부분이 있다면, 이슈를 통해 자유로운 지적 부탁드리며, 긴 글 읽어주셔서 감사합니다!</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p><a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usecallback\">https://ko.reactjs.org/docs/hooks-reference.html#usecallback</a></p>\n<p><a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usememo\">https://ko.reactjs.org/docs/hooks-reference.html#usememo</a></p>\n<p><a href=\"https://ko.reactjs.org/docs/react-api.html#reactmemo\">https://ko.reactjs.org/docs/react-api.html#reactmemo</a></p>","frontmatter":{"title":"리엑트 메모이제이션 셀프 코칭","description":"리엑트 최적화, 적절하게 잘하고 계시나요?","date":"September 21, 2022"}}},"pageContext":{"slug":"/react/memoization/","previous":{"fields":{"slug":"/typescript/typescript-essentials-you-should-know/"},"frontmatter":{"title":"타입스크립트, 글로 배웠습니다만"}},"next":{"fields":{"slug":"/javascript/regular-expression/"},"frontmatter":{"title":"효율적인 문자열 검색을 위한 정규 표현식"}}}},"staticQueryHashes":["3128451518"]}