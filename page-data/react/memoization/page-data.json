{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/memoization/","result":{"data":{"site":{"siteMetadata":{"title":"Youthfulhps.dev","author":"youthfulhps","siteUrl":"https://youthfulhps.dev","comment":{"disqusShortName":"youthfulhps","utterances":"youthfulhps/youthfulhps.github.io"},"sponsor":{"buyMeACoffeeId":"youthfulhps"}}},"markdownRemark":{"id":"ae68fd58-2491-5f97-98e8-25442b98f1a3","excerpt":"보통 어플리케이션에서 최적화를 위해 메모이제이션 기법을 통해 이전에 계산한 값을 메모리에\n저장해두고, 동일하게 다시 사용할 수 있는 곳에서 재사용하여 반복적으로 발생하는 계산의\n리소스를 줄이는 기법을 사용하곤 합니다. 리엑트에서도 메모이제이션을 쉽게 구현할 수 있도록 도와주는 API들이 존재하는데요.\n리엑트 공식문서에서 우리가 잘 알고 있는 useMemo\n에 대해 다음과 같이 설명하고 있습니다. “생성(create)” 함수와 그것의 의존성 값의 배열을 전달하세요. useMemo…","html":"<p>보통 어플리케이션에서 최적화를 위해 메모이제이션 기법을 통해 이전에 계산한 값을 메모리에\n저장해두고, 동일하게 다시 사용할 수 있는 곳에서 재사용하여 반복적으로 발생하는 계산의\n리소스를 줄이는 기법을 사용하곤 합니다.</p>\n<p>리엑트에서도 메모이제이션을 쉽게 구현할 수 있도록 도와주는 API들이 존재하는데요.\n리엑트 공식문서에서 우리가 잘 알고 있는 <a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usememo\">useMemo</a>\n에 대해 다음과 같이 설명하고 있습니다.</p>\n<p><em>“생성(create)” 함수와 그것의 의존성 값의 배열을 전달하세요. useMemo는 의존성이\n변경되었을 때에만 메모이제이션된 값만 다시 계산 할 것입니다. 이 최적화는 모든 렌더링 시의\n고비용 계산을 방지하게 해 줍니다.</em></p>\n<p>사실, useMemo를 포함하여 useCallback과 React.memo에 대한 의론적인 배움을 얻고\n사용해왔지만 최근 다시금 공식 문서를 읽었을 때, 문서에서 말하는 고비용의 기준은 무엇인지,\n사용할 수는 있지만 보장되어 있지 않다는 문구의 의미는 무엇인지 등등, 역시 명확한 기준을 제공하지\n않는 리엑트의 모습을 보면서 내가 적절하게 잘 이해하고 적재적소에 사용하며, 실질적인 성능 최적화를\n이루고 있는 건가에 대한 의구심이 들었습니다.</p>\n<p>이 글은 갑자기 낯설게 느껴지는 리엑트 메모이제이션에 대한 찝찝함을 이겨내고자 조금 더 깊게\n알아보고, 가능하면 최적화에 대한 스스로의 기준도 정해보려 합니다. 비슷한 고민을 하시는 분들에게\n도움이 될 수 있으면 좋겠습니다.</p>\n<h2 id=\"usememo-메모이제이션된-값을-반환한다\" style=\"position:relative;\"><a href=\"#usememo-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EB%90%9C-%EA%B0%92%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%9C%EB%8B%A4\" aria-label=\"usememo 메모이제이션된 값을 반환한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useMemo, 메모이제이션된 값을 반환한다</h2>\n<p>우선 우리가 잘 알고 있는 리엑트의 메모이제이션을 위한 API를 살펴봅시다. 그 첫 번째로 useMemo는\n값을 메모이제이션합니다. 같은 말로, 메모이제이션된 값을 반환합니다.</p>\n<p>리엑트에서 사용되는 훅들은 <a href=\"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js#L2599\">HookDispatcher</a>\n라는 이름으로 Disaptcher 인터페이스를 갖는 객체로 래핑되어 내부에서 공유되는데,\n여기서 useMemo를 찾아볼 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> HooksDispatcher<span class=\"token operator\">...</span><span class=\"token operator\">:</span> Dispatcher <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  useMemo<span class=\"token operator\">:</span> updateMemo<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p><em>onMount, onRerender, onUpdate에 따라 사용되는 HooksDispatcher 객체가 각각 구현되어 있어\n변수명에 (…)을 표기하였습니다.</em></p>\n<p>여기서 useMemo는 updateMemo 라는 함수로 그 구현체가 정의되고 있는데요. 우리가 이해하고 있는\nuseMemo의 역할을 코드로 확인해봅시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">updateMemo</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">nextCreate</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span>\n  deps<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>mixed<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> nextDeps <span class=\"token operator\">=</span> deps <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">:</span> deps<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> prevState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prevState <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextDeps <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> prevDeps<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>mixed<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">=</span> prevState<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">areHookInputsEqual</span><span class=\"token punctuation\">(</span>nextDeps<span class=\"token punctuation\">,</span> prevDeps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> prevState<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> nextValue <span class=\"token operator\">=</span> <span class=\"token function\">nextCreate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>nextValue<span class=\"token punctuation\">,</span> nextDeps<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> nextValue<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>먼저 updateMemo()의 파라미터 nextCreate, deps는 우리가 사용하는 useMemo에서\n메모이제이션할 값을 연산하기 위한 콜백 함수, 그리고 특정값이 변할 때만 새롭게 메모이제이션\n될 수 있도록 전달하는 deps와 대응됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">updateMemo</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  <span class=\"token function-variable function\">nextCreate</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span>\n  deps<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>mixed<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>함수 내부에서는 로직 전개를 위해 활용될 세 가지의 변수를 가지고 있는데, 여기서 hook\n에는 어떤 값이 할당될까요?</p>\n<p>위에서 봤던 리엑트의 Dispatcher 객체와 마찬가지로, 훅은 <a href=\"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js#L159\">Hook</a>\n이라는 인터페이스를 가진 객체로 되는데, updateWorkInProgressHook()은\n훅으로 관리하고자 하는 값에 대해 직전 랜더링 환경에서 대응되는 훅 객체를 반환하고,\n대응되는 훅 객체가 없다면 새로운 훅 객체를 생성하여 반환합니다.</p>\n<p>nextDeps는 파라미터로 전달받은 deps를, prevState는 직전 랜더링 환경에서 메모이제이션되어\n있던 값을 참조합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">type</span> <span class=\"token class-name\">Hook</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  memoizedState<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  baseState<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  baseQueue<span class=\"token operator\">:</span> Update<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span> <span class=\"token builtin\">any</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  queue<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  next<span class=\"token operator\">:</span> Hook <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> nextDeps <span class=\"token operator\">=</span> deps <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">:</span> deps<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> prevState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span></code></pre></div>\n<p>결국, useMemo는 직전 훅 객체에 메모이제이션된 값과 전달된 deps가 null이\n아니라면, deps로 전달받은 값들이 변경되지 않았음을 검증하는 단계를 거쳐\n메모제이션된 값을 반환합니다.\n<em><a href=\"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberHooks.new.js#L343\">areHookInputsEqual()</a>은 여기서!</em></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prevState <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextDeps <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 여기서 prevState는 [value, deps]의 형태</span>\n      <span class=\"token keyword\">const</span> prevDeps<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>mixed<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">=</span> prevState<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">areHookInputsEqual</span><span class=\"token punctuation\">(</span>nextDeps<span class=\"token punctuation\">,</span> prevDeps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> prevState<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">...</span></code></pre></div>\n<p>분기 검증에 실패했다면, 값을 얻기 위한 콜백 함수인 nextCreate()를 통해 값을 구하고,\n현재 새로운 훅 객체의 memoizedState에 deps와 함께 할당합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">const</span> nextValue <span class=\"token operator\">=</span> <span class=\"token function\">nextCreate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>nextValue<span class=\"token punctuation\">,</span> nextDeps<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">return</span> nextValue<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>useMemo의 구현체 코드를 보니 콜백함수와 deps를 전달하면, deps가 참조하고 있는 값이 변경되지 않는 한\n메모이제이션된 값을 다시 사용하는 기능을 잘 이해하고 있음을 확인할 수 있었습니다. :)</p>\n<h2 id=\"usecallback-메모이제이션된-콜백을-반환한다\" style=\"position:relative;\"><a href=\"#usecallback-%EB%A9%94%EB%AA%A8%EC%9D%B4%EC%A0%9C%EC%9D%B4%EC%85%98%EB%90%9C-%EC%BD%9C%EB%B0%B1%EC%9D%84-%EB%B0%98%ED%99%98%ED%95%9C%EB%8B%A4\" aria-label=\"usecallback 메모이제이션된 콜백을 반환한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useCallback, 메모이제이션된 콜백을 반환한다</h2>\n<p>useCallback은 인자값으로 전달받은 콜백 함수를 메모이제이션합니다.\n예상할 수 있듯, useCallback의 구현체는 useMemo 구현체와 매우 유사하기 때문에 특별히 다른 부분만 짚고 넘어가겠습니다.</p>\n<p>useCallback는 updateCallback 이라는 함수로 그 구현체가 정의되어 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">const</span> HooksDispatcher<span class=\"token operator\">...</span><span class=\"token operator\">:</span> Dispatcher <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  useCallback<span class=\"token operator\">:</span> updateCallback<span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>updateCallback은 updateMemo와 달리, 파라미터로 전달받은 callback 자체를\n메모이제이션하는 것을 확인할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">updateCallback</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span><span class=\"token constant\">T</span><span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>callback<span class=\"token operator\">:</span> <span class=\"token constant\">T</span><span class=\"token punctuation\">,</span> deps<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>mixed<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token constant\">T</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> hook <span class=\"token operator\">=</span> <span class=\"token function\">updateWorkInProgressHook</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> nextDeps <span class=\"token operator\">=</span> deps <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">:</span> deps<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> prevState <span class=\"token operator\">=</span> hook<span class=\"token punctuation\">.</span>memoizedState<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>prevState <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>nextDeps <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> prevDeps<span class=\"token operator\">:</span> <span class=\"token builtin\">Array</span><span class=\"token operator\">&lt;</span>mixed<span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">=</span> prevState<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">areHookInputsEqual</span><span class=\"token punctuation\">(</span>nextDeps<span class=\"token punctuation\">,</span> prevDeps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> prevState<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token comment\">// callback 자체를 메모이제이션한다.</span>\n  hook<span class=\"token punctuation\">.</span>memoizedState <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span>callback<span class=\"token punctuation\">,</span> nextDeps<span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> callback<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>우리가 잘 이해하고 있는 것 처럼, useMemo는 콜백 함수의 연산 반환값을, useCallback은\n콜백 자체를 메모이제이션하는 기능 차이를 확인할 수 있었습니다.</p>\n<h2 id=\"reactmemo-마지막-랜더링된-결과를-재사용한다\" style=\"position:relative;\"><a href=\"#reactmemo-%EB%A7%88%EC%A7%80%EB%A7%89-%EB%9E%9C%EB%8D%94%EB%A7%81%EB%90%9C-%EA%B2%B0%EA%B3%BC%EB%A5%BC-%EC%9E%AC%EC%82%AC%EC%9A%A9%ED%95%9C%EB%8B%A4\" aria-label=\"reactmemo 마지막 랜더링된 결과를 재사용한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>React.memo, 마지막 랜더링된 결과를 재사용한다</h2>\n<p>React.memo는 고차 컴포넌트로서 감싼 컴포넌트 랜더링 결과를 메모이징하고, 동일한 props로\n동일한 결과를 랜더링하는 경우에 대하여 다시 랜더링하지 않고, 다시 마지막으로 랜더링된 결과를\n재사용합니다.</p>\n<p>공식문서에 첨언된 내용에는, React.memo가 props 변화에만 영향을 준다고 설명합니다. 즉,\n컴포넌트 리랜더링이 발생하는 케이스들 중에서 부모 컴포넌트로부터 전달받은 props의 변화로 인해\n발생하는 리랜더링 최적화를 담당합니다.</p>\n<p><a href=\"https://github.com/facebook/react/blob/main/packages/react/src/ReactMemo.js\">React.memo</a>의 구현체를 살펴보면, 엄청난 일이 벌어질 것 같은 예상과는 달리 명확한 단일의 역할만을 담당하고\n있는 고차 컴포넌트의 면모를 잘 보여줍니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token comment\">// Symbol.for('react.memo');</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span><span class=\"token constant\">REACT_MEMO_TYPE</span><span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'shared/ReactSymbols'</span><span class=\"token punctuation\">;</span>\n<span class=\"token operator\">...</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">function</span> <span class=\"token generic-function\"><span class=\"token function\">memo</span><span class=\"token generic class-name\"><span class=\"token operator\">&lt;</span>Props<span class=\"token operator\">></span></span></span><span class=\"token punctuation\">(</span>\n  type<span class=\"token operator\">:</span> React$ElementType<span class=\"token punctuation\">,</span>\n  compare<span class=\"token operator\">?</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">(</span>oldProps<span class=\"token operator\">:</span> Props<span class=\"token punctuation\">,</span> newProps<span class=\"token operator\">:</span> Props<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token builtin\">boolean</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">const</span> elementType <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n    $$<span class=\"token keyword\">typeof</span><span class=\"token operator\">:</span> <span class=\"token constant\">REACT_MEMO_TYPE</span><span class=\"token punctuation\">,</span>\n    type<span class=\"token punctuation\">,</span>\n    compare<span class=\"token operator\">:</span> compare <span class=\"token operator\">===</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">?</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">:</span> compare<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">return</span> elementType<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>개인적으로 생각하는 주목할 점은, React.memo로 감싼 컴포넌트가 react.memo 심볼을\n요소 유형 태그로 할당받게 된다는 점입니다.</p>\n<p>컴포넌트 재조정을 위한 작업을 생성하는 리엑트 리콘실러에서 beginWork() 라는 함수에서는\n위에서 언급한 요소의 유형 태그를 통해 어떤 방식으로 업데이트를 진행할 지 결정합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">beginWork</span><span class=\"token punctuation\">(</span>\n  current<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  workInProgress<span class=\"token operator\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  renderLanes<span class=\"token operator\">:</span> Lanes<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">switch</span> <span class=\"token punctuation\">(</span>workInProgress<span class=\"token punctuation\">.</span>tag<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token keyword\">case</span> MemoComponent<span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token operator\">...</span>\n      resolvedProps <span class=\"token operator\">=</span> <span class=\"token function\">resolveDefaultProps</span><span class=\"token punctuation\">(</span>type<span class=\"token punctuation\">.</span>type<span class=\"token punctuation\">,</span> resolvedProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">updateMemoComponent</span><span class=\"token punctuation\">(</span>\n        current<span class=\"token punctuation\">,</span>\n        workInProgress<span class=\"token punctuation\">,</span>\n        type<span class=\"token punctuation\">,</span>\n        resolvedProps<span class=\"token punctuation\">,</span>\n        renderLanes<span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token operator\">...</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서, React.memo에서 할당된 ‘react.memo’ 심볼 유형 태그를 가진 컴포넌트는\nMemoComponent로 구분되어 업데이트 작업이 진행되는데, 우리가 흔히 사용하는 함수형\n컴포넌트와 다르게 업데이트 과정이 진행될 것이라고 짐작할 수 있습니다.</p>\n<p><em>beginWork()를 간추려 첨부했지만, 엄청난 일은 여기서 일어나고 있었구나 싶을 정도로\n요소 유형별 각기 다른 업데이트 방식으로 분류됩니다. 모두 살펴보기엔 일이 커지니 (사실, 무섭습니다.)\n메모 컴포넌트가 어떻게 업데이트되는 지 살펴봅시다.</em></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">updateMemoComponent</span><span class=\"token punctuation\">(</span>\n  current<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  workInProgress<span class=\"token operator\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  Component<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  nextProps<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">,</span>\n  renderLanes<span class=\"token operator\">:</span> Lanes<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">|</span> Fiber <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">const</span> currentChild <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">.</span>child<span class=\"token operator\">:</span> <span class=\"token builtin\">any</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Fiber<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> hasScheduledUpdateOrContext <span class=\"token operator\">=</span> <span class=\"token function\">checkScheduledUpdateOrContext</span><span class=\"token punctuation\">(</span>\n    current<span class=\"token punctuation\">,</span>\n    renderLanes<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hasScheduledUpdateOrContext<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> prevProps <span class=\"token operator\">=</span> currentChild<span class=\"token punctuation\">.</span>memoizedProps<span class=\"token punctuation\">;</span>\n    <span class=\"token comment\">// Default to shallow comparison</span>\n    <span class=\"token keyword\">let</span> compare <span class=\"token operator\">=</span> Component<span class=\"token punctuation\">.</span>compare<span class=\"token punctuation\">;</span>\n    compare <span class=\"token operator\">=</span> compare <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">?</span> compare <span class=\"token operator\">:</span> shallowEqual<span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token function\">compare</span><span class=\"token punctuation\">(</span>prevProps<span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> current<span class=\"token punctuation\">.</span>ref <span class=\"token operator\">===</span> workInProgress<span class=\"token punctuation\">.</span>ref<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">bailoutOnAlreadyFinishedWork</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> workInProgress<span class=\"token punctuation\">,</span> renderLanes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  workInProgress<span class=\"token punctuation\">.</span>flags <span class=\"token operator\">|=</span> PerformedWork<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> newChild <span class=\"token operator\">=</span> <span class=\"token function\">createWorkInProgress</span><span class=\"token punctuation\">(</span>currentChild<span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  newChild<span class=\"token punctuation\">.</span>ref <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">.</span>ref<span class=\"token punctuation\">;</span>\n  newChild<span class=\"token punctuation\">.</span>return <span class=\"token operator\">=</span> workInProgress<span class=\"token punctuation\">;</span>\n  workInProgress<span class=\"token punctuation\">.</span>child <span class=\"token operator\">=</span> newChild<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> newChild<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>  </code></pre></div>\n<p>React.memo가 전달받는 컴포넌트와 props 비교 기준이 되는 compare은 이곳에서 사용되는데요.\n만약 compare을 전달하지 않는다면, shallowEqual 즉, 얕은 비교를 통해 이전 props와\n새로운 props를 비교하고, 이 둘이 같지 않다고 판단되면 새롭게 자식트리가 조정됩니다.</p>\n<p>반면, 동일하다고 판단되면 bailoutOnAlreadyFinishedWork()에 의해서 이전에 사용된 자식트리가\n클론되어 재사용됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">function</span> <span class=\"token function\">bailoutOnAlreadyFinishedWork</span><span class=\"token punctuation\">(</span>\n  current<span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">,</span>\n  workInProgress<span class=\"token operator\">:</span> Fiber<span class=\"token punctuation\">,</span>\n  renderLanes<span class=\"token operator\">:</span> Lanes<span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Fiber <span class=\"token operator\">|</span> <span class=\"token keyword\">null</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token comment\">// This fiber doesn't have work, but its subtree does. Clone the child</span>\n  <span class=\"token comment\">// fibers and continue.</span>\n  <span class=\"token function\">cloneChildFibers</span><span class=\"token punctuation\">(</span>current<span class=\"token punctuation\">,</span> workInProgress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> workInProgress<span class=\"token punctuation\">.</span>child<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>복잡하고 험난했지만, 이전 props와 새로운 props가 동일하다면 마지막 랜더링된 결과를\n재사용하기 위해 React.memo로 감싸주면 되겠구나 이해할 수 있었습니다.</p>\n<h2 id=\"usecallback-참조-동일성에-최적화된-컴포넌트에-유효하다\" style=\"position:relative;\"><a href=\"#usecallback-%EC%B0%B8%EC%A1%B0-%EB%8F%99%EC%9D%BC%EC%84%B1%EC%97%90-%EC%B5%9C%EC%A0%81%ED%99%94%EB%90%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8%EC%97%90-%EC%9C%A0%ED%9A%A8%ED%95%98%EB%8B%A4\" aria-label=\"usecallback 참조 동일성에 최적화된 컴포넌트에 유효하다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useCallback, 참조 동일성에 최적화된 컴포넌트에 유효하다</h2>\n<p>리엑트는 props의 변경 여부를 얕은 비교를 통해 판단합니다. 자바스크립트에서 원시 타입 값은\n참조값이 다르더라도 값이 같다면 일치 연산자(strict equality operator)에 의해 참이\n판단되지만, 객체, 배열, 함수와 같은 객체는 같은 참조값이 아니라면, 즉 서로 다른 메모리에\n할당되어 있다면 거짓으로 판단됩니다.</p>\n<p>가령 부모 컴포넌트의 상태가 변경되면, 내부에 선언되어 있는 함수들은 모두 새로운 메모리에\n작성됩니다. 결국 자식 컴포넌트 입장에서 이전 onClick의 참조값과 새로운 onClick의 참조값이\n변경되었으니, 자식 컴포넌트도 리랜더링이 발생합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ChildA</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span> onClick <span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>onClick<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>ChildA<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">ChildB</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span>onClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>onClick<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>ChildB<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">Parent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> <span class=\"token punctuation\">[</span>isGood<span class=\"token punctuation\">,</span> setIsGood<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> <span class=\"token function\">useState</span><span class=\"token punctuation\">(</span><span class=\"token boolean\">false</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> \n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleChildAClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">setIsGood</span><span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isGood<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">const</span> <span class=\"token function-variable function\">handleChildBClick</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ChildB clicked!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>ChildA onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>handleChildAClick<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n      <span class=\"token operator\">&lt;</span>ChildB onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>handleChildBClick<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n    <span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span><span class=\"token operator\">></span>\n  <span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>여기서, ChildA에 전달되는 클릭 핸들러는 isGood 상태에 의존적인 핸들러로 useCallback을\n사용해도 의존된 값이 항상 변경되니 무용지물입니다.\n하지만, ChildB는 부모 컴포넌트의 상태에 독립적인 핸들러를 전달받음에도 ChildA의 버튼이\n클릭되면 새롭게 생성되는 ChildB 클릭 핸들러로 인해 리랜더링이 발생하는 것은 억울합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 643px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 24.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABE0lEQVQY052O30rCYADF90ZdRE8R9AI9S2/QTV11UUgQZhiYjyBo0FykQW3TZFaIuk+Xc81tftt+fbouuu7A4fy5OBzNjyFa5yyCmGWc46rsS3AjEH7ESuVQ5ST4pDO0WSQg45RUdRvkeb5VKSWmaaIFTpNg2CKfGvDVRYou4aS79cyfwOsU3jNYjVqwdBiNxliWjSsEm7lMjUqZYts22nH1hNO7M0qNMpXHOpV2jYpRo6z0+lcLX+dKv6U5eGDmuljmC+9DhyxLi6dZxlu/j6aPJxhTF30qaM88dDEvOCvY/sN7VzD4Dpl7C55fe/SdD4IwIlU3Y/XQsnto/ANHjTX7NzEH1YS9S8luSbJznnB4YfEDsl9sDG6rQH4AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Rerendering chart of childB component\"\n        title=\"Rerendering chart of childB component\"\n        src=\"/static/d6bf574a3af106c463ddcadd467ea2ec/b5bda/childB-rerendering-chart.png\"\n        srcset=\"/static/d6bf574a3af106c463ddcadd467ea2ec/5a46d/childB-rerendering-chart.png 300w,\n/static/d6bf574a3af106c463ddcadd467ea2ec/0a47e/childB-rerendering-chart.png 600w,\n/static/d6bf574a3af106c463ddcadd467ea2ec/b5bda/childB-rerendering-chart.png 643w\"\n        sizes=\"(max-width: 643px) 100vw, 643px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<!-- 결국 요점은, 객체인 함수를 자식 컴포넌트에게 props로 콜백으로 전달되는 함수가 매번 새롭게\n생성되는 것을 막기 위해 useCallback으로 핸들러를 감싸준다고 해서 최적화가 이루어지는 것이 아니고,\n이를 참조의 동일성에 최적화된 자식 컴포넌트, 즉 React.memo로 감싸져 있는 컴포넌트에 전달할 때\n유효한 최적화가 이루어집니다. -->\n<p>그럼, ChildB에게 전달되는 핸들러를 useCallback으로 감싸주면 리랜더링을 방지할 수 있을 것 같지만,\n기대와는 다르게 마찬가지로 리랜더링이 발생합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> handleChildBClick <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'ChildB clicked!'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 650px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 24%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAABCUlEQVQY052Oy0rDUBRF81X2Kxz5KzoWf0CRNjrUDn0MBTEgorOK6UxMtDbF2EfS9N3c3tw8lrfBzhy5YZ294RwO2xAKkrRgsZTECUQSlimMdR7PVqh0vdeIKa5zTyggVxlK321UFEXpSaIweu4D/dYT824DObSJek36vq1zExG8sArtEhk8M/EfiUcOwzDgzXHxfZ9EKdb/cj2yLMfYNffYPzvg8OaYqnVCzaphWibVO83GNTXrlKPbKpeNKybTMe+uQ8drI4TY9Cyn0Qp82mEXL+rTGQ3wfun8wWfUY7CYMJ3NeXU+8L6+WcSifJXluqFuafAPmXbK9oVk51pSOZds1VMqdaVJ+QHZp2rQp/rpiwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Rerendering chart of childB component with useCallback\"\n        title=\"Rerendering chart of childB component with useCallback\"\n        src=\"/static/70bd67b3e24d84747e8eb1a2103ebf5c/a6d36/childB-rerendering-chart-with-useCallback.png\"\n        srcset=\"/static/70bd67b3e24d84747e8eb1a2103ebf5c/5a46d/childB-rerendering-chart-with-useCallback.png 300w,\n/static/70bd67b3e24d84747e8eb1a2103ebf5c/0a47e/childB-rerendering-chart-with-useCallback.png 600w,\n/static/70bd67b3e24d84747e8eb1a2103ebf5c/a6d36/childB-rerendering-chart-with-useCallback.png 650w\"\n        sizes=\"(max-width: 650px) 100vw, 650px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>useCallback은 참조 동일성에 최적화된 컴포넌트에 유효합니다. 즉, 부모 컴포넌트의 상태에 독립적인 콜백을\nuseCallback으로 감싸고, 전달받는 자식 컴포넌트 또한 React.memo로 감싸서 props를 얕은 비교하는\n과정을 통해 직전 자식 트리를 재사용하는 과정이 포함할 수 있도록 해야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> ChildB <span class=\"token operator\">=</span> <span class=\"token function\">memo</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token punctuation\">{</span>onClick<span class=\"token punctuation\">}</span></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">&lt;</span>button onClick<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>onClick<span class=\"token punctuation\">}</span><span class=\"token operator\">></span>ChildB<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>button<span class=\"token operator\">></span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span></code></pre></div>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 664px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 23.333333333333332%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA7klEQVQY032Qz0rDQBCH81SCj6DP4CN58ahoRE9SUPDoXa8egqYJNQbEHGJDa9J2083++dxsclARB76Z2Z0fw48JjAEhYVFvEa7/2MKngmUHzUb52dphZU30dEcpQEuNdpo+rLWePrpOEST3h1TRCTo7w7yGVHFInYbY/Nz/6Sz0mOyUdXyEertmPq+YTlOKoqDfZVzyOHfB5OGGZplD64bi3dUR8ZvCa5Alq1VDmsTM0gTZCkavPgf8eA71L75rmo3geZYTJS+UiwbpTtUq6wl6m/4G4y3+Q5th/fGjYu+q5eBWsj9R7Fwodi8HvgDsKnfUBZx89wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Rerendering chart of childB component with useCallback and memo\"\n        title=\"Rerendering chart of childB component with useCallback and memo\"\n        src=\"/static/d7911b2f9b50d1bec5cd11a36004542f/31493/childB-rerendering-chart-with-useCallback-and-memo.png\"\n        srcset=\"/static/d7911b2f9b50d1bec5cd11a36004542f/5a46d/childB-rerendering-chart-with-useCallback-and-memo.png 300w,\n/static/d7911b2f9b50d1bec5cd11a36004542f/0a47e/childB-rerendering-chart-with-useCallback-and-memo.png 600w,\n/static/d7911b2f9b50d1bec5cd11a36004542f/31493/childB-rerendering-chart-with-useCallback-and-memo.png 664w\"\n        sizes=\"(max-width: 664px) 100vw, 664px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p><a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usecallback\">https://ko.reactjs.org/docs/hooks-reference.html#usecallback</a></p>\n<p><a href=\"https://ko.reactjs.org/docs/hooks-reference.html#usememo\">https://ko.reactjs.org/docs/hooks-reference.html#usememo</a></p>\n<p><a href=\"https://ko.reactjs.org/docs/react-api.html#reactmemo\">https://ko.reactjs.org/docs/react-api.html#reactmemo</a></p>","frontmatter":{"title":"비로소 알게된 리엑트 메모이제이션","date":"September 21, 2022"}}},"pageContext":{"slug":"/react/memoization/","previous":{"fields":{"slug":"/typescript/typescript-essentials-you-should-know/"},"frontmatter":{"title":"타입스크립트, 글로 배웠습니다만"}},"next":null}},"staticQueryHashes":["2486386679","3128451518"]}