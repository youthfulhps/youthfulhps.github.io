{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/react-concurrent-mode/","result":{"data":{"site":{"siteMetadata":{"title":"Youthfulhps.dev","author":"youthfulhps","siteUrl":"https://youthfulhps.dev","comment":{"disqusShortName":"youthfulhps","utterances":"youthfulhps/youthfulhps.github.io"},"sponsor":{"buyMeACoffeeId":"youthfulhps"}}},"markdownRemark":{"id":"1a7a8d38-2649-5237-a986-e685724a0d89","excerpt":"리엑트팀에서 Async Rendering\n을 시작으로 5년이 지나 드디어 react18에서 동시성 기능이 정식으로 출시되었습니다. 기능적으로 많은 성능 향상을 이루었는데, ‘Automatic batching for fewer renders’,\n‘SSR support for Suspense’, ‘Fixes for Suspense behavior quirks’와 같이\n코드 수정없이 내부적으로 성능 향상을 이루었고, 동시성을 제공하는 startTransition,\nuseDeferredValue…","html":"<p>리엑트팀에서 <a href=\"https://ko.reactjs.org/blog/2018/03/27/update-on-async-rendering.html\">Async Rendering</a>\n을 시작으로 5년이 지나 드디어 react18에서 동시성 기능이 정식으로 출시되었습니다.</p>\n<p>기능적으로 많은 성능 향상을 이루었는데, ‘Automatic batching for fewer renders’,\n‘SSR support for Suspense’, ‘Fixes for Suspense behavior quirks’와 같이\n코드 수정없이 내부적으로 성능 향상을 이루었고, 동시성을 제공하는 startTransition,\nuseDeferredValue, <SuspenseList>, ‘Streaming SSR with selective hydration’과\n같은 기능들이 추가되었습니다.</p>\n<p>리엑트는 동시성 랜더링 메커니즘을 담아내기 위해 협력적 멀티태스킹,\n우선순위 기반 랜더링, 스케쥴링, 중단 등과 같은 기능을 담아냈습니다.\n무엇이길래 리엑트팀이 5년동안 붙잡았을까 라는?</p>\n<h2 id=\"concurrent-vs-parallelism\" style=\"position:relative;\"><a href=\"#concurrent-vs-parallelism\" aria-label=\"concurrent vs parallelism permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Concurrent vs Parallelism</h2>\n<p>동시성을 설명할 때, 서로 관련있는 병렬성과 함께 설명하곤 합니다.\n하지만, 이 둘은 뚜렷한 차이를 가지고 있으며\nGo 언어의 창시자의 <a href=\"https://go.dev/blog/waza-talk\">Concurrency is not parallelism</a>\n발표 서문에는 다음과 같이 동시성과 병렬성을 비교합니다.</p>\n<p><em>’<strong>동시성은 독립적으로 실행되는 프로세스들의 조합이다.</strong>’\n‘병렬성은 연관된 복수의 연산들을 동시에 실행하는 것이다.’\n’<strong>동시성은 여러 일을 한꺼번에 다루는 문제에 관한 것이다.</strong>’\n‘병렬성은 여러 일을 한꺼번에 실행하는 방법에 관한 것이다.’</em></p>\n<p>아주 멜랑꼴리한데 발표에서 언급한 문구를 빌려 정리하자면,\n<strong>동시성은 프로세서가 하나만 있는 경우, 병렬 처리를 가능케 하지만 병렬처리는 아닙니다.</strong>\n즉, 하나의 스레드로 작업을 순차적으로 처리하지만,\n마치 여러 개의 스레드가 사용되고 있는 것처럼 보이게 하는 것이고,\n동시성은 싱글 코어에서도 동작하지만, 병렬성은 두 개 이상의 코어가 필요합니다.</p>\n<p>병렬성은 예를 들어 GPU를 통해 이미지를 랜더링할 때 R, G, B를 연산하는\n텍스크를 각각의 코어가 작업하는 것과 같이 최소 한 가지 논리적 통제를\n멀티 코어에서 병렬적으로 진행합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 864px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDklEQVQoz4WT246EIAyGff+n27kxJl55tc66oiConPynJetmouI0aYDSfm1TKLZtAwuvOd0ld/fuUxwNVxJjzPoc7UUy/BmXZUFd13h8PdA0DUIICeacg7U2+WitUVUVyrJE3/f5Cj0FGSmhpgliFJC0N4vFRGcGsu7VruuKYRj+k5yAgZ0ocyRloDQyAbWNmKlqDnwH7mfv/Q1wnhGMISBBjSLgiNkRkOxHIFfIeg+kinzXoRM9WvENIQR+tcMoFcHOQEPJsy1zJq0UPLXXti20mfB8/sD6SJWqFLgHM5AHw5oF8pR1aneC0bQSnCvglYN42nt7LDwovmP4CfjpDd69uct3+OmXXP2Ku5/yAo1jYOU3Q/GkAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Parallel task processing\"\n        title=\"Parallel task processing\"\n        src=\"/static/e2d146e61c5b9a19bb4476de300b308a/9cab2/parallelism-process.png\"\n        srcset=\"/static/e2d146e61c5b9a19bb4476de300b308a/5a46d/parallelism-process.png 300w,\n/static/e2d146e61c5b9a19bb4476de300b308a/0a47e/parallelism-process.png 600w,\n/static/e2d146e61c5b9a19bb4476de300b308a/9cab2/parallelism-process.png 864w\"\n        sizes=\"(max-width: 864px) 100vw, 864px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>반면 동시성은 최소 두 개의 논리적 통제 흐름을 가지고 있으며,\n잘개 쪼개진 두 개 이상의 작업을 지속적으로 컨텍스트 스위칭하여\n마치 동시에 이루어지는 것처럼 보이도록 합니다.\n강의를 듣다가 내용 정리를 위해 일시정지하고 메모하는 것과 같은 작업 처리 방식입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 864px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABPklEQVQoz4WT226DMAyGef/n603RuotWEy3jsJxIQgj/bG8w2rHVkhUl2J9/O6SY5xlsvP7li+3Fbs/ZiseDPcs5i+/FPsKL7cb7gNPphMPhgMvlgmmaBDSOI2KMEmOtRVmWOB5LdF33C74qnCjJKQVDCf1HD60VhhBlvwVyaU9x71WFwXv5FkKQ4mvLE6mIziFTMgOUUwTUsDGTai8wTlzMtg3O5xcoimnbFk3TCHQFcluREieCGkvuNAUr+DGLii2QpxOcpYI9qcrSHeevM/xSOCNQtUSVm77DrbvKfFo7ioo7IPmgepzfXuks7c8wpQRnDBLJvtU3WFJQ1zXGlEmJEeAyQ75rc62gqXhM6e6m11tmc9SuJqispGoYBmgaPoN44Cn9qDHfsXu/UvHsH3xs6dlZ8eyV7L2K/17KJ+0UX3E77Ee7AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Concurrent task processing\"\n        title=\"Concurrent task processing\"\n        src=\"/static/1c01ef1b6acac66076081b5b3e947f91/9cab2/concurrent-process.png\"\n        srcset=\"/static/1c01ef1b6acac66076081b5b3e947f91/5a46d/concurrent-process.png 300w,\n/static/1c01ef1b6acac66076081b5b3e947f91/0a47e/concurrent-process.png 600w,\n/static/1c01ef1b6acac66076081b5b3e947f91/9cab2/concurrent-process.png 864w\"\n        sizes=\"(max-width: 864px) 100vw, 864px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<h2 id=\"동시성을-통해-해결하려는-문제\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1%EC%9D%84-%ED%86%B5%ED%95%B4-%ED%95%B4%EA%B2%B0%ED%95%98%EB%A0%A4%EB%8A%94-%EB%AC%B8%EC%A0%9C\" aria-label=\"동시성을 통해 해결하려는 문제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동시성을 통해 해결하려는 문제</h2>\n<p>브라우저는 HTML을 파싱하고, 자바스크립트를 실행하며 랜더트리를 구축하고\n그려내는 작업까지 단일 스레드로서 한번에 하나의 작업만을\n수행합니다.</p>\n<p>때문에 가령 메인 스레드가 자바스크립트 엔진에게 실행권을 위임하여\n자바스크립트 파싱을 시작했다면 그 작업을 멈출 수 없으며,\n작업이 완료될 때까지 이후의 작업을 전개할 수 없습니다.\n리엑트 랜더링 연산 과정도 동일한 절차를 거치게 되며,\n이 때 매우 무거운 랜더링 연산 과정이 시작되면 이후의 작업들이 다소\n긴 시간 동안 대기 상태가 되는 블로킹 랜더링이 발생합니다.</p>\n<p>재조정(reconciliation)을 위한 리엑트의 비교 알고리즘은 매우 최적화되어 있어\n블로킹되는 이슈가 자주 발생하지 않아 공감하기 어려울 수 있지만,\n<a href=\"https://ajaxlab.github.io/deview2021/blocking\">deview2021/blocking</a>\n데모처럼 입력값에 대한 픽셀 박스를 랜더링하는 연산이 무거워짐에 따라\nkeypress 이벤트에 대한 처리가 지연되고 있음을 경고 플래그를 통해 확인할 수 있습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACTElEQVQoz1WS23KbSBRF+f9fmoepzFQsc2ua5tJgkGSQZMeWsaILICTFKyeZB0+6atepPnVYvXvTDr/Xx6c+Pv7r9APD3y7nKOfsGSZTMsUF4xcPrlc+v/tzOT8EcP3Bn5K5y3RjXD4xti+MqxeG+Ya+/capXnM+X5lkaJLh/+sXy3k/XdHlmrho0PaRuGyJpKp8iapXRL9UrchXW7oJtmd4PV55PXxqK4zN7kInfWecPng/9Lztj2x3Pbv9QCe1k97++8j7buRtd6L7LvvxQj9cOA03TqeJYTxzPN0YDrIfrgyXG875fKTe5CxEZZMxLxZslnPaxSPZfIG1lqJJabOM2l+wrmMaW5DZmqrOycuKuqgwjym95O507wd0HFBmCfe5S5TG5KnBVQWRiglmLjry8TOfJA7JIoU/M6TGJzIeQRBjZE7fx/T7HuftuCe3OUWuSNMU1yTUekaqE4zVqDBk7ibYoJCc70n9hCBKSJTBxgIzmlhgkefRTyNOf3zDpBqbKAqps9yQFx5rk2MzceBrSqXJvsYkdyEq0b8PKHVJVoX49h6jNbrwOQ57nN1hhxLQv6VHbP+RTDwygSV+SWUzwmSGTnzcICDNxZmdiduEWJXYIsIkC9RDLJF5TIejPJv9HiUAJZYDHRD5dyJNII6zuzsBu3wJ/8I3LkqFeDNFEn0ltZHkJ449ObDyJaJQXsBBrnw6UMsffWoanpcp63VD0T5hmw2r+ZJNW1K/VMwXDzRVzUPxjVW7Zfv8KnVFu1ny3HV0r2tu1ws/Add8Hro2DvjMAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Example of blocking rendering\"\n        title=\"Example of blocking rendering\"\n        src=\"/static/219e96397b3d85a667ab72d28b32c3da/c1b63/blocking-rendering-example.png\"\n        srcset=\"/static/219e96397b3d85a667ab72d28b32c3da/5a46d/blocking-rendering-example.png 300w,\n/static/219e96397b3d85a667ab72d28b32c3da/0a47e/blocking-rendering-example.png 600w,\n/static/219e96397b3d85a667ab72d28b32c3da/c1b63/blocking-rendering-example.png 1200w,\n/static/219e96397b3d85a667ab72d28b32c3da/d8817/blocking-rendering-example.png 1238w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 43.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABzUlEQVQoz23QS4sTQRiF4fxOF4JLde9/EAZxp6ILN64CLkRBRAQhDmOc3Bwm104l6e50Ll3VnaruzJhbv1YnIyPRxUdxPoqHU1Xw/IDJdI7r+ojBCCGG9hziemN6jthP3+60SdFSkZiEdOiSCIGx+4XTR41cIsdB9vsUlosAIwU68khjHx32iIMGy3SB8r7ZS+9YTKqocZnp2UvC3idk8YRp8Snh60fMn9xh9uwewYv7jF89oJDEEhPNSOJ85ui5TxS4LBOD9k6JB18w00vMpEHcKWL8EovmG8aNz4SV56j3D9Fv7xJ8eMzk44kF7VMSbZ+hNWmSEkuNmmmurjcoC0t/xEJGxHNFIGwOxkxFl2FzhN9uMqifIqpfcc4rOJW6BdMMk2TkZ7rcEUUZSu5YXmfMpjtmE5tVhgwzRuKQXZHRa25x2nBxDrUytEou7dLoACY5uLTg1Y44sqg6gPPZdj+R3Sm5xRus99kfbui3Vwy6a5q1X1z82NCphnRr4VHDG1CpPw1zcLcHpW3tDTb77A1tu9baghsuq2t+llcWXtOqr/8PRseg+hfst4/B1QE0JkNri5ocvWkob8H8H/cNw539u1tQdP4Cvx/AvOVv0WaXBF6Q6ToAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Delay in processing tasks for keypress\"\n        title=\"Delay in processing tasks for keypress\"\n        src=\"/static/815e3dae1953dd73e6539b5104895244/c1b63/blocking-rendering-performance.png\"\n        srcset=\"/static/815e3dae1953dd73e6539b5104895244/5a46d/blocking-rendering-performance.png 300w,\n/static/815e3dae1953dd73e6539b5104895244/0a47e/blocking-rendering-performance.png 600w,\n/static/815e3dae1953dd73e6539b5104895244/c1b63/blocking-rendering-performance.png 1200w,\n/static/815e3dae1953dd73e6539b5104895244/2eb79/blocking-rendering-performance.png 1256w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>경고 플래그 중 하나의 예시로 keypress 이벤트를 처리하는 데 143.41ms이 소요 되었는데\n<a href=\"https://web.dev/rail/?utm_source=devtools#goals-and-guidelines\">RAIL</a>\n모델을 기반으로 생각한다면, 사용자는 입력 이벤트에 대해 100ms 이상 소요되는 것을\n동작과 응답 사이의 연결이 지연되고 있음을 인식하게 되며, 이는 사용자 경험의 감점으로\n이어질 수 있습니다.</p>\n<h2 id=\"동시성-구현을-위한-메커니즘-양보\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%8B%9C%EC%84%B1-%EA%B5%AC%ED%98%84%EC%9D%84-%EC%9C%84%ED%95%9C-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98-%EC%96%91%EB%B3%B4\" aria-label=\"동시성 구현을 위한 메커니즘 양보 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동시성 구현을 위한 메커니즘; 양보</h2>\n<p>브라우저는 랜더링 엔진에게 메인 스레드 점유를 위임하게 되면,\n랜더링 과정 중 발생한 사용자 입력에 대해 즉시 처리할 수 없게 됩니다.\n리엑트는 이러한 근본적인 원인을 해결하고자 <strong>모든 랜더링을 인터럽트 가능하도록 하여\n우선순위가 높은 작업이 텍스크 스택에 들어오면 진행중이던 작업을 중단하고 메인 스레드에게\n점유를 양보(yield)할 수 있는 메커니즘을 구현하게 됩니다.</strong></p>\n<p>(텍스크를 잘개 쪼개는 것에 대한 구현체는 어디있을까?)</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 1200px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA1UlEQVQoz42S6wqDMAyF+/5PuMl+uckG1mpbe/F6ZgtK0VY9UAJJ+DhJSrDTPM9bDF9Yj9XWSO5AwlpMYZ7Ekk7TNCHLMjyeT+R5vvUMDUNb/lDVNRhjGMfx3GHXdej7Hv0wwLQtaPFBxWqfm5a6tALSSAghoJQ6uCd7d67JWuuBWkiU3xyMNzDaeNexcQ8jhw6llNBawy5OVcNRvF+gbszF7QqMHeTyKE5ufK44uOA46wt1CnSurLF+X/u+lMjZThyQUgpjzSUoCUx9ozuwJDC1gjvQP0YgZVDyZo+xAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"When the user&#39;s input comes in, rendering is interrupted\"\n        title=\"When the user&#39;s input comes in, rendering is interrupted\"\n        src=\"/static/e2ceddd26691f38b0dec421c08a40c58/c1b63/interruption-and-yield.png\"\n        srcset=\"/static/e2ceddd26691f38b0dec421c08a40c58/5a46d/interruption-and-yield.png 300w,\n/static/e2ceddd26691f38b0dec421c08a40c58/0a47e/interruption-and-yield.png 600w,\n/static/e2ceddd26691f38b0dec421c08a40c58/c1b63/interruption-and-yield.png 1200w,\n/static/e2ceddd26691f38b0dec421c08a40c58/d61c2/interruption-and-yield.png 1800w,\n/static/e2ceddd26691f38b0dec421c08a40c58/97a96/interruption-and-yield.png 2400w,\n/static/e2ceddd26691f38b0dec421c08a40c58/5fe07/interruption-and-yield.png 3422w\"\n        sizes=\"(max-width: 1200px) 100vw, 1200px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>페이스북팀은 <strong>메인 스레드를 점유하여 랜더링 연산을 전개하고 있는 과정에서\n사용자의 입력에 대한 처리가 대기 중임을 확인하고 메인 스레드 점유를\n양보해야 하는 지에 대해 판단을 할 수 있어야 했고, 이에 대한 메커니즘을\n담은 구현체인 <a href=\"https://wicg.github.io/is-input-pending/\">isInputPending</a>\n브라우저 API를 기여하게 됩니다.</strong></p>\n<p>실제로 리엑트의 <a href=\"https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js\">Scheduler</a>(스케쥴러) 패키지 코드에는\n호스트 환경에 의존적인 API를 사용 가능한지에 대한 플래그들이 존재하고,\n어떠한 기준으로 메인 스레드에게 점유를 양보할 것인지에 대한 전개가 담겨있습니다.</p>\n<h3 id=\"shouldyieldtohost\" style=\"position:relative;\"><a href=\"#shouldyieldtohost\" aria-label=\"shouldyieldtohost permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>shouldYieldToHost</h3>\n<p>양보가 필요한 상황인지를 판단하기 위한 첫 검증은 현재 작업을\n처리하기 위해 얼마만큼의 시간을 소요했는 지를 확인합니다.\n경과된 시간이 frameInterval 값보다 작다면,\n메인 스레드는 단일 프레임만큼 아주 짧은 시간동안만 차단되어 있었기 때문에\n양보하지 않습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// SchedulerFeatureFlags.js</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> frameYieldMs <span class=\"token operator\">=</span> <span class=\"token number\">5</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> frameYieldMs <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../SchedulerFeatureFlags'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">let</span> frameInterval <span class=\"token operator\">=</span> frameYieldMs<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">shouldYieldToHost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> timeElapsed <span class=\"token operator\">=</span> <span class=\"token function\">getCurrentTime</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> startTime<span class=\"token punctuation\">;</span>\n  \n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>timeElapsed <span class=\"token operator\">&lt;</span> frameInterval<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이후의 스코프에서는 메인 스레드가 무시할 수 없는 시간 동안 차단되었을 때\n보류 중인 페인트 혹은 사용자 입력 작업이 존재한다면,\n브라우저가 높은 우선 순위 작업을 수행할 수 있도록 메인 스레드에\n대한 제안 권한을 양보합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// Scheduler.js</span>\n<span class=\"token keyword\">let</span> needsPaint <span class=\"token operator\">=</span> <span class=\"token boolean\">false</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">requestPaint</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n    enableIsInputPending <span class=\"token operator\">&amp;&amp;</span>\n    navigator <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">&amp;&amp;</span>\n    navigator<span class=\"token punctuation\">.</span>scheduling <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">&amp;&amp;</span>\n    navigator<span class=\"token punctuation\">.</span>scheduling<span class=\"token punctuation\">.</span>isInputPending <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    needsPaint <span class=\"token operator\">=</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">shouldYieldToHost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>enableIsInputPending<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>needsPaint<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>한편 reconciler(리콘실러)의\n<a href=\"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1997\">commitRootImpl</a> 는 VDOM의 변경사항을\n루트 DOM에 적용하는 역할을 하는데, 여기서 requestPaint가 사용됩니다.\n즉 <strong>VDOM에서 루트 DOM으로 변경 사항이 커밋되었으니 페인트 작업이 필요하다는 것을\n스케쥴러에게 전달합니다.</strong></p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// ReactFiberWorkLoop.new.js</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> requestPaint <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./Scheduler'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">commitRootImpl</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token operator\">...</span></span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token function\">requestPaint</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>다음으로는 경과된 시간이 연속적인 입력 간격보다 짧은 지 검증합니다.\nisInputPending은 단순히 모든 사용자 이벤트를 동일하게 처리하지 않고,\n<a href=\"%5B%EC%97%B0%EC%86%8D%EC%A0%81%EC%9D%B8%20%EC%9D%B4%EB%B2%A4%ED%8A%B8(Continuous%20events)%5D(https://wicg.github.io/is-input-pending/#continuous-events)\">연속적인(continuous) 이벤트</a>(e.g. click)와 분리된(discrete) 이벤트(e.g. mouseover)를 구분지어 <strong>연속적인 이벤트에 대해 너무 자주 양보하게 되는 것을 막습니다.</strong></p>\n<p>가령 문서를 읽을 때, 시선의 흐름을 마우스 포인터의 이동으로 따라가는 것이\n일반적으로 사용자에게 성능에 대한 영향을 주지 않을 것으로 예상하기 때문에\n기본적으로 이러한 이벤트들은 isInputPending의 검증 대상에서 제외됩니다.</p>\n<p>즉 이 검증 단계에서는, 연속적인 이벤트에 대한 처리 작업을 즉시 시작하지 않을 간격을 두고,\n그 시간 동안에는 판단을 온전히 브라우저에게 맡깁니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// SchedulerFeatureFlags.js</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> continuousYieldMs <span class=\"token operator\">=</span> <span class=\"token number\">50</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> continuousYieldMs <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../SchedulerFeatureFlags'</span>\n\n<span class=\"token keyword\">const</span> continuousInputInterval <span class=\"token operator\">=</span> continuousYieldMs<span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> isInputPending <span class=\"token operator\">=</span>\n  <span class=\"token keyword\">typeof</span> navigator <span class=\"token operator\">!==</span> <span class=\"token string\">'undefined'</span> <span class=\"token operator\">&amp;&amp;</span>\n  navigator<span class=\"token punctuation\">.</span>scheduling <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span> <span class=\"token operator\">&amp;&amp;</span>\n  navigator<span class=\"token punctuation\">.</span>scheduling<span class=\"token punctuation\">.</span>isInputPending <span class=\"token operator\">!==</span> <span class=\"token keyword\">undefined</span>\n    <span class=\"token operator\">?</span> navigator<span class=\"token punctuation\">.</span>scheduling<span class=\"token punctuation\">.</span><span class=\"token function\">isInputPending</span><span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>navigator<span class=\"token punctuation\">.</span>scheduling<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">:</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">shouldYieldToHost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>timeElapsed <span class=\"token operator\">&lt;</span> continuousInputInterval<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isInputPending <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token function\">isInputPending</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>마지막으로 최대 간격 이내에 보류 중인 연속적이거나, 분리된 모든 이벤트에 대해\n양보합니다. 이후 모든 분기 처리가 담지 못한 케이스에 대해서는,\n보류 중인 입력이 없더라도 네트워크 이벤트와 같은 알지 못하는 다른 작업들이\n대기 중일 수 있다는 가정하에 무조건적으로 양보합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// SchedulerFeatureFlags.js</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">const</span> maxYieldMs <span class=\"token operator\">=</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> maxYieldMs <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'../SchedulerFeatureFlags'</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">shouldYieldToHost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n    <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>timeElapsed <span class=\"token operator\">&lt;</span> maxInterval<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// Yield if there's either a pending discrete or continuous input.</span>\n      <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>isInputPending <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">return</span> <span class=\"token function\">isInputPending</span><span class=\"token punctuation\">(</span>continuousOptions<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>초기에 분기처리 되었던 호스트 환경에 의존적인 isInputPending API를\n사용할 수 없는 경우 또한 무조건적으로 양보합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">shouldYieldToHost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>enableIsInputPending<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">return</span> <span class=\"token boolean\">true</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>지금까지 알아본 shouldYieldToHost는 스케쥴러의 <a href=\"https://github.com/facebook/react/blob/main/packages/scheduler/src/forks/Scheduler.js#L189\">workLoop</a>에서 사용됩니다. 현재 진행 중인 작업의 만료시간이 현재 시간에 비해 여유가 있는 시점에서\n우선 순위가 더 높은 작업이 보류되고 있다면, 메인 스레드에게 제어권을 양보하고, 만료 시간이\n지난 작업에 대해서는 양보하지 않고 동기적으로 바쁘게 작업을 이어나갑니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// Scheduler.js</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">workLoop</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">hasTimeRemaining<span class=\"token punctuation\">,</span> initialTime</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>\n    currentTask <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span>\n    <span class=\"token operator\">!</span><span class=\"token punctuation\">(</span>enableSchedulerDebugging <span class=\"token operator\">&amp;&amp;</span> isSchedulerPaused<span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>\n      currentTask<span class=\"token punctuation\">.</span>expirationTime <span class=\"token operator\">></span> currentTime <span class=\"token operator\">&amp;&amp;</span>\n      <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>hasTimeRemaining <span class=\"token operator\">||</span> <span class=\"token function\">shouldYieldToHost</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n    <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">break</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>추가적으로 스케쥴러가 아닌, 동시성 모드에서 컴포넌트를 재조정하는 작업이 담긴\n<a href=\"https://github.com/facebook/react/blob/main/packages/react-reconciler/src/ReactFiberWorkLoop.new.js#L1836\">workLoopConcurrent</a>\n에서도 사용되는데요. shouldYield를 통해 진행되던 재조정 작업이\n중지될 수 있음이 조건에 담겨있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token comment\">// ReactFiberWorkLoop.new.js</span>\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> shouldYield <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'./Scheduler'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">workLoopConcurrent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">while</span> <span class=\"token punctuation\">(</span>workInProgress <span class=\"token operator\">!==</span> <span class=\"token keyword\">null</span> <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span><span class=\"token function\">shouldYield</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token function\">performUnitOfWork</span><span class=\"token punctuation\">(</span>workInProgress<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이를 통해 리콘실러는 workLoopConcurrnet를 통해 현재 작업중이던 루트 혹은 레일(lane)이\n변경되면, 루트에 대기중인 작업들을 모두 제거하여 변경된 레인의 작업이 진행될 수 있도록 합니다.\n(여기서, 레인은 두 가지 이상의 논리적 통제를 다루는 컨텍스트를 의미하는 것 같습니다.\n마치 고속도로의 차선 처럼요.)</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">function</span> <span class=\"token function\">renderRootConcurrent</span><span class=\"token punctuation\">(</span><span class=\"token parameter\"><span class=\"token literal-property property\">root</span><span class=\"token operator\">:</span> FiberRoot<span class=\"token punctuation\">,</span> <span class=\"token literal-property property\">lanes</span><span class=\"token operator\">:</span> Lanes</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">const</span> prevExecutionContext <span class=\"token operator\">=</span> executionContext<span class=\"token punctuation\">;</span>\n  executionContext <span class=\"token operator\">|=</span> RenderContext<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> prevDispatcher <span class=\"token operator\">=</span> <span class=\"token function\">pushDispatcher</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>workInProgressRoot <span class=\"token operator\">!==</span> root <span class=\"token operator\">||</span> workInProgressRootRenderLanes <span class=\"token operator\">!==</span> lanes<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token operator\">...</span>\n        <span class=\"token keyword\">const</span> memoizedUpdaters <span class=\"token operator\">=</span> root<span class=\"token punctuation\">.</span>memoizedUpdaters<span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>memoizedUpdaters<span class=\"token punctuation\">.</span>size <span class=\"token operator\">></span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token function\">restorePendingUpdaters</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> workInProgressRootRenderLanes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          memoizedUpdaters<span class=\"token punctuation\">.</span><span class=\"token function\">clear</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n\n        <span class=\"token function\">movePendingFibersToMemoized</span><span class=\"token punctuation\">(</span>root<span class=\"token punctuation\">,</span> lanes<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span> \n  <span class=\"token punctuation\">}</span>\n  <span class=\"token operator\">...</span>\n\n  <span class=\"token keyword\">do</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">workLoopConcurrent</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token operator\">...</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span></code></pre></div>\n <!-- ============== Lagacy ============== -->\n<!-- 양보가 필요한 상황인지를 판단하기 위한 첫 검증은 1)현재 작업을\n처리하기 위해 얼마만큼의 시간을 소요했는 지를 확인합니다.\n만약, 경과된 시간이 frameInterval 값보다 작다면,\n메인 스레드는 단일 프레임만큼 아주 짧은 시간동안만 차단되어 있었기 때문에\n양보하지 않습니다.\n\n하지만, 메인 스레드가 무시할 수 없는 시간 동안 차단되었다면,\n브라우저가 높은 우선 순위 작업을 수행할 수 있도록 메인 스레드에\n대한 제어 권한을 양보합니다.\n\n리엑트는 동시성 랜더링 메커니즘을 담아내기 위해 협력적 멀티태스킹, 우선순위 기반 랜더링, 스케쥴링, 중단 등과 같은\n기능을 구현하였는데요. 저는 동시성이라는 키워드가 궁금했습니다.\n\n동시성 랜더링은 블로킹 랜더링을 해결하고자 합니다.\n블로킹 랜더링은 입력값에 대한 픽셀 박스를 랜더링하는 연산을\n시작하게 되면 중간에 중단할 수 없기 때문에, 연산을 점유당하고 있는\n브라우저는 추가적인 값 입력에 대해 즉시 업데이트할 수 없게 됩니다.\n\n리엑트는 동시성 모드에서의 모든 랜더링 과정은 인터럽트가 가능하도록\n만들어 근본적으로 중단(interrupting) 가능하도록 합니다.\n\n리엑트는 동시성 기능을 통해 블로킹 랜더링을 해결하고자\n모든 랜더링 과정을 인터럽트 가능하도록 하였습니다.\n그리고, 상호 작용에 있어 사용자 경험에 영향을 주는 우선 순위를 언급하고,\n입력과 호버와 같은 상호작용은 빠르게 반응하길 원하지만, 반면 클릭이나\n페이지 전환, 상호작용에 대한 부수적인 변화에는 약간의 기다림이 익숙한 것을\n통해 작업의 우선 순위를 산정합니다.\n\n우선 순위는 react18에서 새롭게 정의된 useTransition을 통해\n정의할 수 있습니다.\n\nreact 공식문서 데모에서는 input 컴포넌트의 변화 랜더링, 목록 컴포넌트 랜더링\n이 두가지 작업의 우선 순위를 구분지었다.\n\ninput 컴포넌트의 변화 랜더링은 즉각적으로 적용되어야 하는 랜더링이며,\n목록 컴포넌트 랜더링은 상대적으로 급하지 않은 랜더링이다.\n\n블로킹 랜더링은 1차선 도로이다. 컴포넌트 갱신이 많아지면 CPU의 점유율이 높아지면서\nD, E의 랜더링을 해결할 수 없다.\n\n동시성 랜더링은 2차선 도로라고 생각해보자.\n\n동시성 랜더링에서도 마찬가지로 A, B라는 작업을 진행한다고 생각해보자.\n\nA에 대한 작업을 진행하다가 메인 쓰레드에게 일정시간 양보한다. (yield)\n\n동시성 랜더링은 이전에 언급한 것처럼 하나의 컴포넌트의 랜더링을 잘개 쪼개어 작업한다.\nC의 작업이 마무리되기 전에 D에 대한 입력이 들어오면 C의 작업보다 우선순위가 높은 'D에 대한 입력'을 먼저 처리하게 된다.\n즉, 리스트 랜더링보다는 우선순위가 높은 'D에 대한 입력 처리'를 먼저 진행하게 된다.\n\n그리고, pending 상태에 있었던 낮은 순위 랜더링을 리베이스(git branch의 베이스 지점을 끌어올리는 듯한 동작)을 수행한다.\n\n두 개의 차선에서 하나는 고속 하나는 저속으로 보고 리엑트에서는 이를 lane 이라고 말한다.\n\n## 동시성 랜더링을 위한 API\n\n동시성 모드는 기능 단위로 점진적으로 채택될 수 있도록 리엑트는\n동시성 기능을 추가하였습니다. 단순히 createRoot를 사용한다고 해서\n동시성 모드가 켜지는 것이 아닌, 동시성 기능을 사용했을 때\n동시성 모드가 유효해집니다.\n\nstartTransition은 느린 차선의 lane을 만들어 주는 API 이다.\n\nstartTransition의 콜백 함수를 전달하면 수도 코드에서 확인할 수 있듯이\n낮은 우선순위를 갖게 된다.\n\nstartTransition은 바로 실행된다????\n\n이렇게 낮은 우선순위를 부여받으면 보다 중요한 CPU 사용처에 양보를 할 수 있다.\n\n대규모 화면 업데이트 중 응답성을 유지할 수 있고, 상태 전환 중에 시각적 피드백을 제공할 수 있다.\n\n[deview2021/concurrent](https://ajaxlab.github.io/deview2021/concurrent)\n를 통해 블로킹 랜더링과 비교해보자.\n\nconcurrent에서는 짧은 여러개의 스택이 반복적으로 수행되고 있는 것을 확인할 수 있다.\n\n## urgent update vs transition update\n\n그 구분은 어떻게 지어야 할까, 사용자가 오래걸릴 것이라고 예상되는 것들\n하나의 view에서 다른 view로 전환되거나, 전환되는 중간과정이 스킵되어도 문제가 없는 것 (load, refresh)\n\n## HCI 연구 결과가 실제 Ui에 통합되도록 돕는 것\n\n화면 간 전환에서 로딩 중 상태를 너무 많이 표시하면 UX 품질이 낮아짐\n빠르게 처리되기 기대하는 상호작용과 느려도 문제없는 상호작용\n동시성 모드의 목적은 HCI 연구 결과를 추상화하고 구현할 수 있는 방법을 제공하는 것이다.\n\nHCI 연구 결과 확인해보기\n\n## Reference\n\n[Inside React(동시성을 구현하는 기술)](https://tv.naver.com/v/23652451) -->","frontmatter":{"title":"react-concurrent-mode","date":"June 11, 2022"}}},"pageContext":{"slug":"/react/react-concurrent-mode/","previous":{"fields":{"slug":"/web/stale-while-ravalidate/"},"frontmatter":{"title":"stale-while-revalidate 전략은 어떻게 활용되고 있을까"}},"next":{"fields":{"slug":"/typescript/typescript-essentials-you-should-know/"},"frontmatter":{"title":"타입스크립트, 글로 배웠습니다만"}}}},"staticQueryHashes":["2486386679","3128451518"]}