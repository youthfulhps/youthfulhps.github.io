{"componentChunkName":"component---src-templates-blog-post-js","path":"/react/concurrent-feature-hooks/","result":{"data":{"site":{"siteMetadata":{"title":"Youthfulhps.dev","description":"Blog posted front-end, troubleshooting!","author":"youthfulhps","siteUrl":"https://youthfulhps.dev","thumbnail":"static/banner.png","comment":{"disqusShortName":"youthfulhps","utterances":"youthfulhps/youthfulhps.github.io"},"sponsor":{"buyMeACoffeeId":"youthfulhps"}}},"markdownRemark":{"id":"20f72477-6172-5e85-9ba1-bf997fa4c380","excerpt":"…","html":"<p>리엑트 동시성 기능을 공부하면서 어렵고 복잡한 메커니즘이지만, 결국 사용자 경험을 개선하기 위한 목표들을 추상화해서\n기술적으로 풀어낸 결과물이라고 생각하면 꽤나 여운이 남습니다.</p>\n<p>가령 현재 실행권을 가지고 있는 무거운 랜더링 연산 작업을 진행하면서도, 작업 처리 우선순위가 높은 사용자 이벤트에\n대한 처리 작업이 들어와 대기 중이라면, 진행 중인 작업을 즉시 중단하고 실행권을 우선순위가 높은 작업에게 양보해서\n우선적으로 처리될 수 있게 하는 동작처럼요.</p>\n<p>간단해 보이지만 무거운 랜더링 연산 작업을 잘 개 쪼개고, 쪼개진 작업을 처리하고 우선순위가 높은 작업이 대기 중인지\n확인해야 하고, 작업을 중단할 수 있어야 하며, 실행권을 양보한 후 다시 돌려받을 수 있어야 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 978px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAADC0lEQVQozw2Sa0+aBxTHH0QuAgJy9QJIFQyC1WcoVEFQFAqlgJembKLQGRSkbex0WbF1w2pmbLM1dkvd1iVb071amtTt5dZ0/QJ7s2RLtn2LfYPfnhf/nOTk5Jz/5Qh2TYTZdoGIWovGtILaVqXdfpMxo8iKUaBoUjDV7UUcTKAwlXAZZ1mV+nZTGrmxiFy/hE0TIq8VKJnlCD2dbmI6OVOqDjSaOApdCkGdZFTrpmqTI2pUVEJj/LxRIHhhin5dgHVLG27TRbSGMEZziB61g4JOxg1pXjBZdDhsRiIdSsYHg0yHMkxP5rnsHKDcJbA81M+z8hLntfe4dXWB5fAMFb3EPH6FWDhN0D/JiMUpMZSx1dOG0KZSYepQkdWrEftHGPZOkEkVWfIFaPSpOEmGOb9V4s1ulcVQFH+njXW3lWwsieiL4uwWcWtdZDRy6i41gkyuwNXezppNRWujxvm3zznavcdKdomNXI6FSIKHxWs8Xpznm6NjHtUbVDxORl0BfA4Rlz2AQ2EmqlaTlg4JgkKFVyHwWdzDP29+5b+//iQXT6FVWRkamiAZjHBWLnE3v0AqluGLvSZ5zyBTzgDvT8zgMPnpU9qIKpVEbAaJoUyJUZDxNBvk37dv+eHxEyz6XvqsA3RqermTzfL7UZPWWk2SN4zVIPl1McyLapmzyhricIJJ/zSi3Y231ysxlJZ1ywSeXR3j799e0yjdwGbqJ+Adp/Fuje9u1nl5/xMe7hzhl0JzWT3U4nP8cdxkf73B5FyF6NwqYqSI79J1BL3RwbhrmEYszucf7hAYCKBqM0jeeKjkVhmyukmELtPc3JPkDaAVOqRf7KWZnuPSeArfaJKxUI6AeAXvSBLB1iViNrxDIVfndm2HQvYa6fkMydl5ZqIJlheuc9Bs8eXJE6k+oLG+xZaE08MTFqU3KuQXsZr76DLYMegtCI1Sne3ybZ6fnvH6p1cctg7YrG4Sj8ZZloI4+fSYe3f3OLi/z972Lq2PPubBwSF3tj/gx+9f8MvLV3x19IivJZzuH/I/p1+Du2inuHAAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"A man who keeps telling me to wait\"\n        title=\"A man who keeps telling me to wait\"\n        src=\"/static/5e4096669fde9b4abaa7cb54a6acc677/914c7/thumbnail.png\"\n        srcset=\"/static/5e4096669fde9b4abaa7cb54a6acc677/5a46d/thumbnail.png 300w,\n/static/5e4096669fde9b4abaa7cb54a6acc677/0a47e/thumbnail.png 600w,\n/static/5e4096669fde9b4abaa7cb54a6acc677/914c7/thumbnail.png 978w\"\n        sizes=\"(max-width: 978px) 100vw, 978px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<h2 id=\"우선순위\" style=\"position:relative;\"><a href=\"#%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\" aria-label=\"우선순위 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>우선순위</h2>\n<p>리엑트는 산발적으로 발생하는 작업들을 교통정리하고 스케쥴링, 중단, 양보할 수 있도록 모든 작업에 우선순위를\n부여합니다. 마우스, 키보드 입력과 같은 이산적인 사용자 상호작용에 대한 업데이트부터, 드래그처럼 연속적인\n사용자 상호작용, 네트워크 요청, setTimeout에 의해 생성된 업데이트와 같은 작업들이 모두 각각의 우선순위를\n가지게 됩니다.</p>\n<p>물론 리엑트가 지정한 작업 우선순위는 모두 사용자 경험에 대한 HCI 연구 결과가 반영되어 있습니다.\n가령 화면 간 전환에서 로딩 중 상태를 너무 많이 표시하면 UX 품질이 낮아지는 문제라든지, 빠르게 처리되기를\n기대하는 상호작용들과 느려도 문제없는 상호작용을 구분 짓고 이를 적용해서 우선순위를 할당하게 됩니다.</p>\n<p>실제 리엑트에서 우선순위를 표현하는 <a href=\"https://github.com/facebook/react/pull/18796\">Lane 모델</a>\n을 살펴보면 31개의 비트맵으로 표현된 우선순위들이 레인이라는 명칭으로 표현되고 있고, 더 작은 숫자로 표현된 레인부터\n높은 우선순위를 가지고 표현되어 있습니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// react-reconciler/src/ReactFiberLane.new.js\n\nexport type Lanes = number;\nexport type Lane = number;\nexport type LaneMap&lt;T&gt; = Array&lt;T&gt;;\n\nexport const TotalLanes = 31;\n\nexport const NoLanes: Lanes = /*                        */ 0b0000000000000000000000000000000;\nexport const NoLane: Lane = /*                          */ 0b0000000000000000000000000000000;\nexport const SyncLane: Lane = /*                        */ 0b0000000000000000000000000000001;\nexport const InputContinuousHydrationLane: Lane = /*    */ 0b0000000000000000000000000000010;\nexport const InputContinuousLane: Lane = /*             */ 0b0000000000000000000000000000100;\nexport const DefaultHydrationLane: Lane = /*            */ 0b0000000000000000000000000001000;\nexport const DefaultLane: Lane = /*                     */ 0b0000000000000000000000000010000;\nconst TransitionHydrationLane: Lane = /*                */ 0b0000000000000000000000000100000;\nconst TransitionLanes: Lanes = /*                       */ 0b0000000001111111111111111000000;\nconst TransitionLane1: Lane = /*                        */ 0b0000000000000000000000001000000;\n...\nconst RetryLanes: Lanes = /*                            */ 0b0000111110000000000000000000000;\nconst RetryLane1: Lane = /*                             */ 0b0000000010000000000000000000000;\n...\n\nexport const SomeRetryLane: Lane = RetryLane1;\nexport const SelectiveHydrationLane: Lane = /*          */ 0b0001000000000000000000000000000;\nconst NonIdleLanes: Lanes = /*                          */ 0b0001111111111111111111111111111;\nexport const IdleHydrationLane: Lane = /*               */ 0b0010000000000000000000000000000;\nexport const IdleLane: Lane = /*                        */ 0b0100000000000000000000000000000;\nexport const OffscreenLane: Lane = /*                   */ 0b1000000000000000000000000000000;</code>\n        </deckgo-highlight-code>\n<ul>\n<li><em>SyncLane, 이산적인(discrete) 사용자 상호 작용에 대한 업데이트</em></li>\n<li><em>InputContinuousLane, 연속적인(continuous) 사용자 상호 작용에 대한 업데이트</em></li>\n<li><em>DefaultLane, setTimeout, 네트워크 요청 등에 의해 생성된 업데이트</em></li>\n<li><em>TransitionLane, Suspense, useTransition, useDefferredValue에 의해 생성된 업데이트</em></li>\n</ul>\n<p>레인들 중에서 큰 비중을 차지하는 <code class=\"language-text\">TransitionLane</code>은 비교적 낮은 우선순위를 가지고 있는데요. 해당 레인들은\n이 글의 주제처럼, 긴급한 작업에 인위적으로 낮은 우선순위를 부여할 때 할당받을 수 있는 레인들입니다. 그리고\n이후 살펴볼 훅들은 긴급한 작업에 대한 업데이트에 인위적으로 낮은 우선순위를 부여할 때 사용할 수 있습니다.</p>\n<p><em>우선순위에 대해 더 자세히 알아보고 싶다면, <a href=\"https://youthfulhps.dev/react/react-concurrent-mode-01/#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98-%EC%9A%B0%EC%84%A0%EC%88%9C%EC%9C%84\">동시성 메커니즘; 우선순위</a>\n를 참고하시면 좋습니다.</em></p>\n<h2 id=\"usedeferredvalue\" style=\"position:relative;\"><a href=\"#usedeferredvalue\" aria-label=\"usedeferredvalue permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useDeferredValue</h2>\n<p><code class=\"language-text\">useDeferredValue()</code>는 일부 UI 업데이트를 연기할 수 있도록 해주는 훅입니다. 훅에 초깃값으로 전달한\n상태 값의 업데이트 우선순위를 Transition으로 낮춥니다.</p>\n<p>가령 검색창 입력값이 변경됨에 따라 쿼리를 생성해서 API 요청을 보내야 하는 경우, 사용성을 고려하여 입력창에\n입력된 값 변경이 긴급하게 업데이트되어야 합니다. 하지만, 입력값의 완성도를 고려하지 않고 모든 입력값 변경에\n요청 이펙트를 발생시키는 것은 좋지 못하다는 걸 잘 알고 있습니다. <code class=\"language-text\">useDeferredValue()</code>는 어쩌면 디바운스\n기법을 대체할 수 있는 훅일 수도 있겠습니다.</p>\n<p>다음 예제와 같이 입력으로 받은 검색어를 통해 <code class=\"language-text\">AlbumList</code> 컴포넌트에서 API 요청을 보낸다고 생각해봅시다.\n검색어가 변경될때마다 <code class=\"language-text\">AlbumList</code>에서는 새로운 요청을 보내게 됩니다.</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">import { useDeferredValue, useState, Suspense } from &#39;react&#39;;\nimport AlbumList from &#39;./AlbumList&#39;;\n\nfunction AlbumSearch() {\n  const [query, setQuery] = useState(&#39;&#39;);\n\n  return (\n    &lt;div&gt;\n      &lt;label&gt;\n        Search todo:\n        &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;\n      &lt;/label&gt;\n      &lt;AlbumList query={query} /&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default AlbumSearch;</code>\n        </deckgo-highlight-code>\n<p>이제 <code class=\"language-text\">useDeferredValue()</code>를 사용해서 검색어의 완성도를 고려할 수 있도록 <code class=\"language-text\">AlbumList</code>에\n속성값으로 전달되는 검색어 업데이트를 지연시켜 봅시다.</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">import { useDeferredValue, useState, Suspense } from &#39;react&#39;;\nimport AlbumList from &#39;./AlbumList&#39;;\n\nfunction AlbumSearch() {\n  const [query, setQuery] = useState(&#39;&#39;);\n  const deferredQuery = useDeferredValue(query);\n  const isStale = query !== deferredQuery;\n\n  return (\n    &lt;div&gt;\n      &lt;label&gt;\n        Search todo:\n        &lt;input value={query} onChange={e =&gt; setQuery(e.target.value)} /&gt;\n      &lt;/label&gt;\n      &lt;AlbumList query={deferredQuery} /&gt;\n    &lt;/div&gt;\n  );\n}\n\nexport default AlbumSearch;</code>\n        </deckgo-highlight-code>\n<p>업데이트가 지연된 검색어를 전달함으로써 해당 검색어로 인한 사이드 이펙트 발생을 미루어 조금 더 완성도 높은\n검색어에 대한 요청만 기대해 볼 수 있습니다.</p>\n<h2 id=\"usetransition\" style=\"position:relative;\"><a href=\"#usetransition\" aria-label=\"usetransition permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>useTransition</h2>\n<p><code class=\"language-text\">useTransition()</code>은 UI를 차단하지 않고 상태를 업데이트할 수 있는 훅입니다. <code class=\"language-text\">useTransition()</code>의\n<code class=\"language-text\">startTransition()</code> 함수 내부에 정의된 상태 세터 함수의 우선순위를 낮춰 상태 업데이트로 발생된 작업을\n처리할 수 있습니다.</p>\n<p>탭을 통해 컨텐츠를 전환하는 네비게이터가 있다고 생각해 봅시다. (<a href=\"https://react.dev/reference/react/useTransition#usage\">예제</a>는 리엑트 공식 문서에서 발췌했습니다.)</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">import { useState } from &#39;react&#39;;\nimport TabButton from &#39;./TabButton&#39;;\nimport About from &#39;./About&#39;;\nimport Contact from &#39;./Contact&#39;;\nimport PostsTab from &#39;./Posts&#39;;\n\nfunction Navigator() {\n  const [tab, setTab] = useState(&#39;about&#39;);\n\n  return (\n    &lt;&gt;\n      &lt;nav&gt;\n        &lt;TabButton isActive={tab === &#39;about&#39;} onClick={() =&gt; setTab(&#39;about&#39;)}&gt;\n          About\n        &lt;/TabButton&gt;\n        &lt;TabButton isActive={tab === &#39;posts&#39;} onClick={() =&gt; setTab(&#39;posts&#39;)}&gt;\n          Posts (slow)\n        &lt;/TabButton&gt;\n        &lt;TabButton\n          isActive={tab === &#39;contact&#39;}\n          onClick={() =&gt; setTab(&#39;contact&#39;)}\n        &gt;\n          Contact\n        &lt;/TabButton&gt;\n        &lt;hr /&gt;\n      &lt;/nav&gt;\n      {tab === &#39;about&#39; &amp;&amp; &lt;About /&gt;}\n      {tab === &#39;posts&#39; &amp;&amp; &lt;PostsTab /&gt;}\n      {tab === &#39;contact&#39; &amp;&amp; &lt;Contact /&gt;}\n    &lt;/&gt;\n  );\n}\n\nexport default Navigator;</code>\n        </deckgo-highlight-code>\n<p>여기서 유독 <code class=\"language-text\">Posts</code> 페이지는 랜더링 과정이 1초가 걸리는 매우 무거운 작업을 수행하도록 구현되어 있어\n포스트탭을 클릭하면 잠시 UI 인터렉션이 블로킹되고, 랜더링에 몰두하게 됩니다. 즉 우선순위가 높은 유저\n인터렉션 처리를 할 수 없게 됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 900px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAAAV0lEQVQoz9WOMQoAIQwE/f8bU9hIHqBRgiErBq675rS6halChkkigt47VBVjDMw5sefuR6RSCnLOARGBmeOwxWb2mfSUtdZQa8UuvirEy05lIbx5/qdwAe3pKYFhqmXWAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"User interaction blocked due to rendering operation\"\n        title=\"User interaction blocked due to rendering operation\"\n        src=\"/static/cf088e3313fb7da63d6f49e9e15230fa/1cfc2/use-transition.png\"\n        srcset=\"/static/cf088e3313fb7da63d6f49e9e15230fa/5a46d/use-transition.png 300w,\n/static/cf088e3313fb7da63d6f49e9e15230fa/0a47e/use-transition.png 600w,\n/static/cf088e3313fb7da63d6f49e9e15230fa/1cfc2/use-transition.png 900w\"\n        sizes=\"(max-width: 900px) 100vw, 900px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n    </span></p>\n<p>여기서 클릭을 통한 선택된 탭 전환 트리거를 <code class=\"language-text\">useTransition()</code>로 감싸주고 우선순위를 낮춰봅시다.</p>\n<deckgo-highlight-code language=\"tsx\"  >\n          <code slot=\"code\">import { ReactNode, useTransition } from &#39;react&#39;;\n\ntype TabButtonProps = {\n  children: ReactNode;\n  isActive: boolean;\n  onClick: () =&gt; void;\n};\n\nfunction TabButton({ children, isActive, onClick }: TabButtonProps) {\n  const [isPending, startTransition] = useTransition();\n  if (isActive) {\n    return &lt;b&gt;{children}&lt;/b&gt;;\n  }\n  if (isPending) {\n    return &lt;b className=&quot;pending&quot;&gt;{children}&lt;/b&gt;;\n  }\n  return (\n    &lt;button\n      onClick={() =&gt; {\n        startTransition(() =&gt; {\n          onClick();\n        });\n      }}\n    &gt;\n      {children}\n    &lt;/button&gt;\n  );\n}\n\nexport default TabButton;</code>\n        </deckgo-highlight-code>\n<p>이제 다시 포스트탭을 클릭해 보면, UI 인터렉션이 블로킹되지 않고 활성화되어 있으며 포스트 컨텐츠를\n로딩하다가 발생한 탭 전환 인터렉션에 대해 즉시 처리할 수 있게 됩니다.</p>\n<p>리엑트에서 동시성 메커니즘을 구현하기 위해 적용된 ‘양보’의 개념으로, 탭 전환에 의해 발생한 랜더링 작업을\n잘 개 쪼개서 작업을 진행하다가 우선순위가 높은 사용자의 인터렉션(이 예제에서는 다른 탭 클릭)이 들어왔을 때,\n랜더링 작업이 소유하고 있던 실행권을 우선순위가 높은 작업 처리에 양보하는 모습을 확인할 수 있습니다.\n(양보에 대한 이야기는 <a href=\"https://youthfulhps.dev/react/react-concurrent-mode-01/#%EB%8F%99%EC%8B%9C%EC%84%B1-%EB%A9%94%EC%BB%A4%EB%8B%88%EC%A6%98-%EC%96%91%EB%B3%B4\">여기</a>를 참고하시면 좋습니다!)</p>\n<h2 id=\"마치면서\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C\" aria-label=\"마치면서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치면서</h2>\n<p>결국 두 훅은 업데이트 작업의 우선순위를 인위적으로 낮추는데 사용하는데요. 리엑트 자체적으로 정한 우선순위와\n상충하는 작업 처리를 해야 하는 케이스에 대해 우선순위를 인위적으로 변경할 수 있는 기능을 제공함으로서\n작업자의 자유도를 높여주는 훅들이라 생각이 듭니다. 성능 개선과 사용자 경험 향상을 위해 더 좋은 사용 케이스들을\n살펴보고 적용해 보면 좋겠습니다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://react.dev/reference/react/useDeferredValue\">https://react.dev/reference/react/useDeferredValue</a></li>\n<li><a href=\"https://react.dev/reference/react/useTransition\">https://react.dev/reference/react/useTransition</a></li>\n<li><a href=\"https://iyu88.github.io//react/2022/11/01/react-concurrent-mode.html\">https://iyu88.github.io//react/2022/11/01/react-concurrent-mode.html</a></li>\n</ul>","frontmatter":{"title":"긴급한 작업에 낮은 우선순위를 부여하는 리엑트 훅","description":"잠시 대기!","date":"April 24, 2023"}}},"pageContext":{"slug":"/react/concurrent-feature-hooks/","previous":{"fields":{"slug":"/javascript/regular-expression/"},"frontmatter":{"title":"효율적인 문자열 검색을 위한 정규 표현식"}},"next":{"fields":{"slug":"/essay/2023-first-half-retrospect/"},"frontmatter":{"title":"2023 상반기 회고"}}}},"staticQueryHashes":["3665086019"]}