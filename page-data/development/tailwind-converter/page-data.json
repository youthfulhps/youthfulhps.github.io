{"componentChunkName":"component---src-templates-blog-post-js","path":"/development/tailwind-converter/","result":{"data":{"site":{"siteMetadata":{"title":"Youthfulhps.dev","description":"프론트엔드 주니어 개발자, 트러블슈팅에 대한 고민의 흔적을 기록으로 남기는 것을 좋아합니다.","author":"youthfulhps","siteUrl":"https://youthfulhps.dev","thumbnail":"/banner.png","comment":{"disqusShortName":"youthfulhps","utterances":"youthfulhps/youthfulhps.github.io"},"sponsor":{"buyMeACoffeeId":"youthfulhps"}}},"markdownRemark":{"id":"f50b0f0b-7bc3-56a5-ae8a-e6955611a792","excerpt":"tailwind-converter 라이브러리를 출시하게 되었다. styled-components를 통해 정의된 코드레벨의 컴포넌트 스타일을 추출하여 tailwindCSS에서 제공하는 유틸리티 클래스로 변환하고, 해당 컴포넌트의 사용처를 찾아 변환된 스타일 클래스들을 할당, 최종적으로 코드를 반환하는 도구이다. 간단한 예제에서는 그럴싸하게 동작하지만, 아직 실무에서 사용되는 복잡한 정의의 컴포넌트를 완벽하게 변환하기까지\n많은 이슈와 챌린지들을 직면하고 있다. 하지만…","html":"<p><a href=\"https://www.npmjs.com/package/@youthfulhps/tailwind-converter\">tailwind-converter</a> 라이브러리를 출시하게 되었다. <a href=\"https://www.npmjs.com/package/styled-components\">styled-components</a>를 통해 정의된 코드레벨의 컴포넌트 스타일을 추출하여 <a href=\"https://tailwindcss.com/\">tailwindCSS</a>에서 제공하는 유틸리티 클래스로 변환하고, 해당 컴포넌트의 사용처를 찾아 변환된 스타일 클래스들을 할당, 최종적으로 코드를 반환하는 도구이다.</p>\n<deckgo-highlight-code language=\"tsx\" theme=\"nord\"  >\n          <code slot=\"code\">// before\nimport React from &#39;react&#39;;\nimport styled from &#39;styled-components&#39;;\n\nconst Title = styled.h1`\n  font-size: 1.5em;\n  text-align: center;\n  color: #bf4f74;\n`;\n\nconst Wrapper = styled.section`\n  padding: 4em;\n  background: #ffefd5;\n\n  .description {\n    font-size: 1.2em;\n    color: #5a5ae6;\n  }\n`;\n\nfunction Component() {\n  return (\n    &lt;Wrapper&gt;\n      &lt;Title&gt;Hello World!&lt;/Title&gt;\n      &lt;span className=&quot;description&quot;&gt;Welcome!&lt;/span&gt;\n    &lt;/Wrapper&gt;\n  );\n}\n\nexport default Component;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"tsx\" theme=\"nord\"  >\n          <code slot=\"code\">// after\nimport React from &#39;react&#39;;\nimport styled from &#39;styled-components&#39;;\n\nconst Title = styled.h1`\n  font-size: 1.5em;\n  text-align: center;\n  color: #bf4f74;\n`;\n\nconst Wrapper = styled.section`\n  padding: 4em;\n  background: #ffefd5;\n\n  .description {\n    font-size: 1.2em;\n    color: #5a5ae6;\n  }\n`;\n\nfunction Component() {\n  return (\n    &lt;section className=&quot;p-16 bg-[#ffefd5] [&amp;&gt;.description]:text-[1.2em] [&amp;&gt;.description]:text-[#5a5ae6]&quot;&gt;\n      &lt;h1 className=&quot;text-2xl text-center text-[#bf4f74]&quot;&gt;Hello World!&lt;/h1&gt;\n      &lt;span className=&quot;description&quot;&gt;Welcome!&lt;/span&gt;\n    &lt;/section&gt;\n  );\n}\n\nexport default Component;</code>\n        </deckgo-highlight-code>\n<p>간단한 예제에서는 그럴싸하게 동작하지만, 아직 실무에서 사용되는 복잡한 정의의 컴포넌트를 완벽하게 변환하기까지\n많은 이슈와 챌린지들을 직면하고 있다. 하지만 1차적으로 목표했던 기능을 완성하였고, 라이브러리를 제작하면서 배우고 고민했던 것들을\n기록하기 위해 회고를 남긴다.</p>\n<h2 id=\"동기\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EA%B8%B0\" aria-label=\"동기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동기</h2>\n<p>사내 내부적으로 프론트엔드 파트 통합을 준비하면서 각 파트의 기술 스택 통일에 대한 필요성을 느꼈다. 다수의 제품이 <code class=\"language-text\">tailwindCSS</code>를\n사용하고 있었기 때문에, <code class=\"language-text\">styled-components</code>를 사용하고 있는 레거시 스타일 정의에 대해 리팩토링과 마이그레이션을 진행해서\n공통의 스타일 정의를 사용할 수 있는 환경을 구축해야 했다.</p>\n<p>다만 해당 작업이 지엽적이고 반복적인 작업이라 꽤 높은 피로도가 수반되는 작업이었고, QA 또한 무시할 수 없었다.\n마이그레이션하는 작업을 정리하자면 다음과 같다.</p>\n<ol>\n<li>정의된 컴포넌트의 스타일을 확인한다.</li>\n<li>스타일 속성과 값에 대응하는 <code class=\"language-text\">tailwindCSS</code>의 유틸리티 클래스를 찾는다.</li>\n<li>해당 컴포넌트의 사용처에서 열린 태그를 찾아 <code class=\"language-text\">className</code> 속성에 해당 유틸리티 클래스를 할당한다.</li>\n<li>열린 태그와 닫힌 태그를 찾아, 요소로 대체한다.</li>\n</ol>\n<p>그러다 문뜩 위처럼 작업 리스트를 위처럼 정의할 수 있다면, 이 과정을 수행하는 프로그램을 만들어 볼 수 있겠다는 생각이 들었다.\n한정된 스타일 속성들과 이에 대응되는 유틸리티 클래스가 명확했고, <code class=\"language-text\">styled</code> 태그 템플릿 리터럴 함수를 사용하는 코드 구조나\n컴포넌트 사용처의 열린 태그가 가진 <code class=\"language-text\">className</code> 속성에 할당하는 과정 또한 문법적으로 제약이 명확했기 때문이다.</p>\n<p>다만 코드란 게 다양한 스타일을 가지고 있어 모든 스타일을 대응할 수 있을 것이라고 장담할 수는 없었지만, 우선 이러한 컨셉을 증명해 보기 위해\n단순하게 정의된 기본적인 스타일 속성들에 대해 위 과정을 대신 수행하는 스크립트를 작성해 보는 것을 첫 번쨰 목표로 삼았다.</p>\n<h2 id=\"추상-구문-트리를-조작할-수-있구나\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EC%83%81-%EA%B5%AC%EB%AC%B8-%ED%8A%B8%EB%A6%AC%EB%A5%BC-%EC%A1%B0%EC%9E%91%ED%95%A0-%EC%88%98-%EC%9E%88%EA%B5%AC%EB%82%98\" aria-label=\"추상 구문 트리를 조작할 수 있구나 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추상 구문 트리를 조작할 수 있구나</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 733px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 24%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA0ElEQVR42p2Oy07DMBRE/U9tBbQoTp2HhKhjx3aaVEDSlveef+Czh7ErKhZdsTi6Z8bX0hWVH7G8KZGvN5D5PVShk88X+b8Qd2HCYi6xXNWJFbm6LjBjdyL745cymWUn6OKWF0lJco1Mbkj0hlca0mCtDLEpR1eFPXe/M3aqtMlF/f2FXh8wPH4ibF8w7N6xe/hA179iO7yl7PwBLbHtHi4c0bo9PGfsnT/Cd89pP74LpXuYZoTlkrEjl/nRTWjopp2gzROqujtTVoF0F7qQ/AexbLc0KDK77wAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"openai 채팅의 일부분\"\n        title=\"\"\n        src=\"/static/4a89866568256f698c0f46957fcdcdb0/00b70/chat-with-openai.png\"\n        srcset=\"/static/4a89866568256f698c0f46957fcdcdb0/5a46d/chat-with-openai.png 300w,\n/static/4a89866568256f698c0f46957fcdcdb0/0a47e/chat-with-openai.png 600w,\n/static/4a89866568256f698c0f46957fcdcdb0/00b70/chat-with-openai.png 733w\"\n        sizes=\"(max-width: 733px) 100vw, 733px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>처음엔 코드 파일을 스크랩해서 정규식을 통해 정의된 컴포넌트의 스타일을 추출해 보려 했으나 절대 안전한 방법이 아니라는 걸 금방 깨달았다.\n컨벤션이 정해져 있다고 한들 다양한 코드 스타일을 감당할 만한 정규식을 기대하기는 어려웠고, 더 엄격한 정규식을 사용하면 예외적인 문자열이 포함되거나, 원하는 문자열이 제외되는 경우가 많았다.</p>\n<p>결론부터 말하자면, 추상 구문 트리를 조작하는 전략을 취했다. 사실 추상 구문 트리를 조작해야겠다는 생각이 쉽게 떠오른 것은 아니었는데,\n한창 고민하며 작업하던 중 우연히 익숙하게 사용한 <code class=\"language-text\">prettier</code>의 코드 포매팅은 어떻게 문자열 덩어리에서 각기 다른 문법에 따라 읽기 좋은\n코드를 재생산 해내는지에 대한 기술적인 의문이 생겼다.</p>\n<blockquote>\n<p>추상 구문 트리는 프로그래밍 언어로 작성된 소스 코드의 추상 구문 구조의 트리이다. 이 트리의 각 노드는 소스 코드에서 발생되는 구조를 나타낸다.\n[위키 백과/추상 구문 트리] 중</p>\n</blockquote>\n<p>결국 문자열로 이루어진 코드 텍스트를 분석해 각각의 토큰들의 정보를 노드로 구성하여 관계에 따라 트리 구조로 구성한 것이 추상 구문 트리이다.\n<a href=\"https://babeljs.io/\"><code class=\"language-text\">babel</code></a>에서 자바스크립트를 컴파일 할 때나, <code class=\"language-text\">prettier</code>, <code class=\"language-text\">eslint</code>와 같은 도구들 모두 추상 구문 트리를\n기반으로 코드를 해석하고 조작한다.</p>\n<p>간단하게 예시를 살펴보자. 다음과 같은 코드를 추상 구문 트리로 생성한 결과이다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">const { parse } = require(&#39;@babel/parser&#39;);\n\nconst code = `const Title = styled.h1`\n  font-size: 1.5em;\n  text-align: center;\n  color: #bf4f74;\n``;\n\nconst ast = parse(code, {\n  sourceType: &#39;module&#39;,\n  plugins: [],\n});</code>\n        </deckgo-highlight-code>\n<details>\n  <summary><deckgo-highlight-code language=\"javascript\">\n<code slot=\"code\">console.log(JSON.stringify(ast, null, 2));</code>\n  </deckgo-highlight-code></summary>\n  <deckgo-highlight-code language=\"json\">\n<code slot=\"code\">\n{\n  \"type\": \"File\",\n  \"start\": 0,\n  \"end\": 87,\n  \"loc\": {\n    \"start\": {...},\n    \"end\": {...},\n  },\n  \"range\": [0, 87],\n  \"errors\": [],\n  \"program\": {\n    \"type\": \"Program\",\n    \"start\": 0,\n    \"end\": 87,\n    \"loc\": {\n      \"start\": {...},\n      \"end\": {...},\n    },\n    \"range\": [0, 87],\n    \"sourceType\": \"module\",\n    \"interpreter\": null,\n    \"body\": [\n      {\n        \"type\": \"VariableDeclaration\",\n        \"start\": 0,\n        \"end\": 87,\n        \"loc\": {\n          \"loc\": {\n            \"start\": {...},\n            \"end\": {...},\n          },\n        },\n        \"range\": [0, 87],\n        \"declarations\": [\n          {\n            \"type\": \"VariableDeclarator\",\n            \"start\": 6,\n            \"end\": 86,\n            \"loc\": {\n              \"start\": {...},\n              \"end\": {...},\n            },\n            \"range\": [6, 86],\n            \"id\": {\n              \"type\": \"Identifier\",\n              \"start\": 6,\n              \"end\": 11,\n              \"loc\": {\n                \"start\": {...},\n                \"end\": {...},\n              },\n              \"range\": [6, 11],\n              \"name\": \"Title\"\n            },\n            \"init\": {\n              \"type\": \"TaggedTemplateExpression\",\n              \"start\": 14,\n              \"end\": 86,\n              \"loc\": {\n                \"start\": {...},\n                \"end\": {...},\n              },\n              \"range\": [14, 86],\n              \"tag\": {\n                \"type\": \"MemberExpression\",\n                \"start\": 14,\n                \"end\": 23,\n                \"loc\": {\n                  \"start\": {...},\n                  \"end\": {...},\n                },\n                \"range\": [14, 23],\n                \"object\": {\n                  \"type\": \"Identifier\",\n                  \"start\": 14,\n                  \"end\": 20,\n                  \"loc\": {\n                    \"start\": {...},\n                    \"end\": {...},\n                  },\n                  \"range\": [14, 20],\n                  \"name\": \"styled\"\n                },\n                \"computed\": false,\n                \"property\": {\n                  \"type\": \"Identifier\",\n                  \"start\": 21,\n                  \"end\": 23,\n                  \"loc\": {\n                    \"start\": {...},\n                    \"end\": {...},\n                  },\n                  \"range\": [21, 23],\n                  \"name\": \"h1\"\n                }\n              },\n              \"quasi\": {\n                \"type\": \"TemplateLiteral\",\n                \"start\": 23,\n                \"end\": 86,\n                \"loc\": {\n                  \"start\": {...},\n                  \"end\": {...},\n                },\n                \"range\": [23, 86],\n                \"expressions\": [],\n                \"quasis\": [\n                  {\n                    \"type\": \"TemplateElement\",\n                    \"start\": 24,\n                    \"end\": 85,\n                    \"loc\": {\n                      \"start\": {...},\n                      \"end\": {...},\n                    },\n                    \"range\": [24, 85],\n                    \"value\": {\n                      \"raw\": \"\\n  font-size: 1.5em;\\n  text-align: center;\\n  color: #BF4F74;\\n\",\n                      \"cooked\": \"\\n  font-size: 1.5em;\\n  text-align: center;\\n  color: #BF4F74;\\n\"\n                    },\n                    \"tail\": true\n                  }\n                ]\n              }\n            }\n          }\n        ],\n        \"kind\": \"const\"\n      }\n    ],\n    \"directives\": []\n  },\n  \"comments\": [],\n  \"tokens\": [...]\n}\n</code>\n  </deckgo-highlight-code>\n</details>\n<p>위 결과를 보면, 추상 구문 트리를 조작하는 것이 쉽지 않을 것이란 걸 직감적으로 알 수 있다. 하지만, 가장 안전한 방법이다.\n추상 구문 트리의 조작이 유효하지 않다면, 코드 분석, 변환, 재생성 과정에서 에러가 발생하게 되는데, 이는 인위적인 조작이\n유효한지 프로그래밍적으로 판단할 수 있다는 것이다. 이는 매우 큰 장점이다.</p>\n<p><em>이하 구현 과정에서는 <code class=\"language-text\">prettier</code>에서 제공하는 API를 사용합니다. 내부적으로 <code class=\"language-text\">babel</code>에서 제공하는 <code class=\"language-text\">parser</code>, <code class=\"language-text\">generator</code>\n를 사용하고 있습니다.</em></p>\n<h2 id=\"변환기-제작-과정\" style=\"position:relative;\"><a href=\"#%EB%B3%80%ED%99%98%EA%B8%B0-%EC%A0%9C%EC%9E%91-%EA%B3%BC%EC%A0%95\" aria-label=\"변환기 제작 과정 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변환기 제작 과정</h2>\n<h3 id=\"1-선언된-컴포넌트-정보-추출하기\" style=\"position:relative;\"><a href=\"#1-%EC%84%A0%EC%96%B8%EB%90%9C-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%A0%95%EB%B3%B4-%EC%B6%94%EC%B6%9C%ED%95%98%EA%B8%B0\" aria-label=\"1 선언된 컴포넌트 정보 추출하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 선언된 컴포넌트 정보 추출하기</h3>\n<p>우선 추상 구문 트리에서 스타일된 컴포넌트에 대한 정보가 담긴 노드를 조건에 맞게 찾아내야 했다. 여기서 주의해야 할 것은 변수 선언은\n함수 선언문 혹은 <code class=\"language-text\">if-else</code>, <code class=\"language-text\">switch</code> 같은 상태문 내부에서도 선언될 수 있다는 것이다.</p>\n<p>개인적으로 스타일된 컴포넌트의 정의는 컴포넌트 파일 모듈 스코프의 최상단에 작성해 레벨이 일정했지만, 다른 스코프 내부에서 스타일된 컴포넌트를 정의해도 문제 될 것 없다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">// component variable declaration\nconst Title = styled.h1`\n  font-size: 1.5em;\n  text-align: center;\n  color: #bf4f74;\n`;\n\nfunction Component() {\n  return &lt;Title&gt;...&lt;/Title&gt;;\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">function Component() {\n  // component variable declaration\n  const Title = styled.h1`\n    font-size: 1.5em;\n    text-align: center;\n    color: #bf4f74;\n  `;\n\n  if (isOpen) {\n    // component variable declaration\n    const SubTitle = styled.h1`\n      font-size: 0.5em;\n      text-align: center;\n      color: #bf4f74;\n    `;\n\n    return &lt;SubTitle&gt;...&lt;/SubTitle&gt;;\n  }\n\n  return &lt;Title&gt;...&lt;/Title&gt;;\n}</code>\n        </deckgo-highlight-code>\n<p>즉 추상 구문 트리에서 스타일된 컴포넌트 코드 정보가 담긴 노드를 찾으려면, 트리에 존재하는 모든 노드를 레벨에 상관없이 재귀적으로 순회해 주어야 했다. 또한 노드의\n타입별로 구조가 달랐기 때문에 재귀 함수를 어떻게 짜야 될지 정말 감이 오질 않았다. 결국 팀원에게 조언을 구해 노드 객체의 프로퍼티 값이\n배열 혹은 객체인 경우 모두 재귀 호출하는 방식으로 순회를 구현하였다.</p>\n<p><em>이후 알게된 사실이지만, 노드의 재귀적인 순회는 <code class=\"language-text\">babel/traverse</code>를 사용할 수 있습니다. 견식이 짧았습니다.</em></p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">function recursion(node: unknown) {\n  if (!isObject(node) || !(&#39;type&#39; in node)) {\n    return;\n  }\n\n  // 객체를 이루는 모든 키와 값을 재귀 순회\n  Object.entries(node).forEach(([key, value]) =&gt; {\n    if (key === &#39;type&#39;) {\n      return;\n    }\n\n    if (Array.isArray(value)) {\n      value.forEach((childNode: unknown) =&gt; {\n        recursion(childNode);\n      });\n      return;\n    }\n\n    recursion(value);\n  });\n}</code>\n        </deckgo-highlight-code>\n<p>이제 모든 노드를 순회하면서, <code class=\"language-text\">styled</code>라는 이름을 가진 <code class=\"language-text\">TaggedTemplateExpression</code> 타입의 표현문이 초기 할당된 변수 선언 타입을\n가진 노드라는 주요 조건을 걸어, 조건을 충족하는 노드에서 스타일된 컴포넌트의 이름과 태그, 그리고 스타일 정의를 추출했다.</p>\n<deckgo-highlight-code language=\"ts\" theme=\"nord\"  >\n          <code slot=\"code\">const Component = styled`...`;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">if (\n  // 노드의 타입이 변수 선언인지 확인\n  node.type === &#39;VariableDeclarator&#39; &amp;&amp;\n  &#39;id&#39; in node &amp;&amp;\n  isObject(node.id) &amp;&amp;\n  &#39;type&#39; in node.id &amp;&amp;\n  &#39;name&#39; in node.id &amp;&amp;\n  // node.id.name = 스타일된 컴포넌트 이름\n  node.id.type === &#39;Identifier&#39; &amp;&amp;\n  typeof node.id.name === &#39;string&#39; &amp;&amp;\n  &#39;init&#39; in node &amp;&amp;\n  isObject(node.init) &amp;&amp;\n  &#39;type&#39; in node.init &amp;&amp;\n  // 변수 선언에 초기 할당된 노드의 타입이 TaggedTemplateExpression인지 확인\n  node.init.type === &#39;TaggedTemplateExpression&#39; &amp;&amp;\n  &#39;tag&#39; in node.init &amp;&amp;\n  isObject(node.init.tag) &amp;&amp;\n  &#39;object&#39; in node.init.tag &amp;&amp;\n  isObject(node.init.tag.object) &amp;&amp;\n  &#39;type&#39; in node.init.tag.object &amp;&amp;\n  &#39;name&#39; in node.init.tag.object &amp;&amp;\n  // styled 함수를 사용하고 있는지 확인\n  node.init.tag.object.type === &#39;Identifier&#39; &amp;&amp;\n  node.init.tag.object.name === &#39;styled&#39; &amp;&amp;\n  &#39;property&#39; in node.init.tag &amp;&amp;\n  isObject(node.init.tag.property) &amp;&amp;\n  &#39;name&#39; in node.init.tag.property &amp;&amp;\n  // node.init.tag.property.name = styled된 요소의 이름 (ex. div, span)\n  typeof node.init.tag.property.name === &#39;string&#39; &amp;&amp;\n  &#39;quasi&#39; in node.init &amp;&amp;\n  isObject(node.init.quasi) &amp;&amp;\n  &#39;type&#39; in node.init.quasi &amp;&amp;\n  // 스타일 정의가 TemplateLiteral 타입으로 파라미터 전달이 되었는지 확인\n  node.init.quasi.type === &#39;TemplateLiteral&#39; &amp;&amp;\n  &#39;quasis&#39; in node.init.quasi &amp;&amp;\n  Array.isArray(node.init.quasi.quasis) &amp;&amp;\n  &#39;type&#39; in node.init.quasi.quasis[0] &amp;&amp;\n  node.init.quasi.quasis[0].type === &#39;TemplateElement&#39; &amp;&amp;\n  &#39;value&#39; in node.init.quasi.quasis[0] &amp;&amp;\n  isObject(node.init.quasi.quasis[0].value)\n) {\n  // node.init.quasi.quasis = 스타일 정의\n  const sassScript = generateConcatenatedCSSTemplateLiteral(\n    node.init.quasi.quasis\n  );\n\n  const parsedCSS = parseSass(sassScript);\n\n  // 컴포넌트 이름과 스타일된 태그명, 스타일을 객체화\n  const componentDeclaration: ComponentDeclaration = {\n    name: node.id.name,\n    tag: node.init.tag.property.name,\n    styles: parsedCSS,\n  };\n\n  componentDeclarations.push(componentDeclaration);\n}</code>\n        </deckgo-highlight-code>\n<p>스타일 정의를 추출하는 작업은 <code class=\"language-text\">sass</code>, <code class=\"language-text\">css</code> 파서에게 맡겼다. <code class=\"language-text\">sass</code> 컴파일을 통해 <code class=\"language-text\">css</code>로 변환하고, 해당 <code class=\"language-text\">css</code>를 파싱해서\n해당 컴포넌트의 스타일 정의와 값들과 중첩되어 있는 클래스들의 스타일 또한 추출할 수 있었다.</p>\n<h3 id=\"2-추출된-스타일-정의를-유틸리티-클래스로-변환하기\" style=\"position:relative;\"><a href=\"#2-%EC%B6%94%EC%B6%9C%EB%90%9C-%EC%8A%A4%ED%83%80%EC%9D%BC-%EC%A0%95%EC%9D%98%EB%A5%BC-%EC%9C%A0%ED%8B%B8%EB%A6%AC%ED%8B%B0-%ED%81%B4%EB%9E%98%EC%8A%A4%EB%A1%9C-%EB%B3%80%ED%99%98%ED%95%98%EA%B8%B0\" aria-label=\"2 추출된 스타일 정의를 유틸리티 클래스로 변환하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 추출된 스타일 정의를 유틸리티 클래스로 변환하기</h3>\n<p>이제 컴포넌트별로 추출된 스타일을 <code class=\"language-text\">tailwindCSS</code>에 정의되어 있는 유틸리티 클래스로 변환해 주어야 한다.\n스타일 속성과 할당된 값에 대응되는 유틸리티 클래스 리스트가 필요했는데 우연히 <code class=\"language-text\">css</code> 정의를 유틸리티 클래스로 변환해 주는 <a href=\"https://tailwind-converter.netlify.app/\">웹 서비스</a>의 소스 코드에서 <code class=\"language-text\">constants</code>\n파일을 구할 수 있었다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">const TAILWINDCLASS: { [key: string]: any } = {\n  ...\n  &#39;font-size&#39;: {\n      arbitrary: &#39;text&#39;,\n      &#39;0.75rem&#39;: &#39;.text-xs&#39;,\n      &#39;0.875rem&#39;: &#39;.text-sm&#39;,\n      &#39;1rem&#39;: &#39;.text-base&#39;,\n      &#39;1.125rem&#39;: &#39;.text-lg&#39;,\n      &#39;1.25rem&#39;: &#39;.text-xl&#39;,\n      &#39;1.5rem&#39;: &#39;.text-2xl&#39;,\n      &#39;1.875rem&#39;: &#39;.text-3xl&#39;,\n      &#39;2.25rem&#39;: &#39;.text-4xl&#39;,\n      &#39;3rem&#39;: &#39;.text-5xl&#39;,\n      &#39;4rem&#39;: &#39;.text-6xl&#39;,\n  },\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>가령 <code class=\"language-text\">font-size</code>라는 스타일 속성에 할당된 값이 정의된 <code class=\"language-text\">TAILWINDCLASS</code>의 키로서 값을 가지고 있다면, <code class=\"language-text\">tailwindCSS</code>에서\n제공하는 유틸리티 클래스에 포함되어 있다고 간주하고 해당 값을 반환하고, 그 외의 값에 대해서는 임의 할당된 클래스로 생성하여 변환되도록\n구현하였다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">export function convertCss({ property, value }: CSSStyleEntity) {\n  // 속성과 값을 전처리\n  property = preprocessProperty({ property, value });\n  const processedValue = preprocessValue({ property, value });\n\n  if (!TAILWINDCLASS[property]) {\n    // 스타일 속성이 유효하지 않다면,\n    // 빈 문자열을 반환한다.\n    return &#39;&#39;;\n  }\n\n  if (!TAILWINDCLASS[property][processedValue]) {\n    // 스타일 속성에 할당된 값과 대응되는 키가 없다면,\n    // 즉 유효한 속성에 할당된 값과 대응되는 유틸리티 클래스가 없다면,\n    // 임의의 값을 전달하는 형태로 클래스를 생성하여 반환한다.\n    // ex) text-[7px]\n    return `${TAILWINDCLASS[property][&#39;arbitrary&#39;]}-[${value}]`;\n  }\n\n  // 스타일 속성에 할당된 값과 대응되는 키가 있다면,\n  // 해당 키의 값을 반환한다.\n  // ex) text-base\n  return TAILWINDCLASS[property][processedValue].slice(1);\n}</code>\n        </deckgo-highlight-code>\n<p>위 코드에서 속성과 값이 전처리되고 있는 것을 볼 수 있다. 이는 가령 <code class=\"language-text\">background</code> 속성에 색상 값이 할당되어 있는 경우\n<code class=\"language-text\">background-color</code>로 변경한다던지,</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">export function preprocessProperty({ property, value }: CSSStyleEntity) {\n  if (property === &#39;background&#39;) {\n    if (isColor(value)) {\n      return &#39;background-color&#39;;\n    }\n    return property;\n  }\n\n  return property;\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">px</code>, <code class=\"language-text\">rem</code>, <code class=\"language-text\">em</code>으로 표현되는 치수를 통일시켜 주고,</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">export function preprocessDimension(value: string) {\n  if (value === &#39;0&#39; || value === &#39;0px&#39;) {\n    return &#39;0&#39;;\n  }\n\n  return convertUnit(value, &#39;rem&#39;);\n}\n\nexport function preprocessSpacing(value: string) {\n  return convertUnit(value, &#39;rem&#39;);\n}</code>\n        </deckgo-highlight-code>\n<p>축약된 값을 할당할 수 있는 <code class=\"language-text\">padding</code>, <code class=\"language-text\">margin</code>, <code class=\"language-text\">border</code>와 같은 속성을 쪼개는 과정이 포함된다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">export function preprocessSpacingShorthand(\n  property: &#39;padding&#39; | &#39;margin&#39;,\n  value: string,\n): StyleEntity[] {\n  const values = value.split(&#39; &#39;);\n\n  const propertyX = `${property}-x`;\n  const propertyY = `${property}-y`;\n  const propertyTop = `${property}-top`;\n  const propertyRight = `${property}-right`;\n  const propertyBottom = `${property}-bottom`;\n  const propertyLeft = `${property}-left`;\n\n  switch (values.length) {\n    case 2:\n      return [\n        {\n          property: propertyY,\n          value: values[0],\n        },\n        {\n          property: propertyX,\n          value: values[1],\n        },\n      ];\n  ...\n  }\n}\n\nfunction preprocessBorderShorthand(value: string): StyleEntity[] {\n  const values = value.split(&#39; &#39;);\n\n  const borderStyle = findBorderStyle(values);\n  const borderWidth = findBorderWidth(values);\n  const borderColor = findBorderColor(values);\n\n  if (!borderStyle) {\n    return [];\n  }\n\n  const border: StyleEntity[] = [\n    {\n      property: &#39;border-style&#39;,\n      value: borderStyle,\n    },\n  ];\n\n  if (borderWidth) {\n    ...\n  }\n\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>결과적으로 다음과 같은 스타일 정의에 대한 유틸리티 클래스를 묶어 얻어낼 수 있었다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">const before = [&#39;font-size:1.5em&#39;, &#39;text-align:center&#39;, &#39;color:#bf4f74&#39;];\nconst after = &#39;text-2xl text-center text-[#bf4f74]&#39;;</code>\n        </deckgo-highlight-code>\n<h3 id=\"3-컴포넌트-사용처-조작하기\" style=\"position:relative;\"><a href=\"#3-%EC%BB%B4%ED%8F%AC%EB%84%8C%ED%8A%B8-%EC%82%AC%EC%9A%A9%EC%B2%98-%EC%A1%B0%EC%9E%91%ED%95%98%EA%B8%B0\" aria-label=\"3 컴포넌트 사용처 조작하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 컴포넌트 사용처 조작하기</h3>\n<p>이제 컴포넌트 정의와 변환된 유틸리티 클래스를 얻었으니 컴포넌트의 열린 태그를 포함하고 있는 노드를 찾아 해당 노드의 <code class=\"language-text\">className</code> 속성에 변환된 유틸리티 클래스를 할당해 주어야 한다.</p>\n<p>마찬가지로 <code class=\"language-text\">JSXElement</code> 반환문에 사용되는 컴포넌트의 열린 태그는 여러 레벨의 상태문 안에서 사용될 수 있기 때문에 추상 구문 트리의 모든 레벨과 노드를 순회해야 한다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">function Component() {\n  if (isOpen) {\n    return &lt;Title&gt;...&lt;/Title&gt;\n  }\n\n  switch(type) {\n    case &#39;primary&#39;:\n      return &lt;PrimaryTitle&gt;...&lt;/PrimaryTitle&gt;\n    ...\n  }\n\n  return &lt;SubTitle&gt;...&lt;/SubTitle&gt;\n}</code>\n        </deckgo-highlight-code>\n<p>스타일된 컴포넌트의 사용처에서 열린 태그를 찾는 조건은 다음과 같은 조건을 걸었다. 조건을 충족하는 노드를 만나면, <code class=\"language-text\">className</code> 속성에\n변환된 유틸리티 클래스 문자열을 덮어쓰는 방식으로 속성 조작을 구현했다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">if (\n  // 노드 타입이 열린 태그 타입(JSXOpeningElement)인지 확인\n  node.type === &#39;JSXOpeningElement&#39; &amp;&amp;\n  parentNode?.type === &#39;JSXElement&#39; &amp;&amp;\n  &#39;name&#39; in node &amp;&amp;\n  isObject(node.name) &amp;&amp;\n  &#39;type&#39; in node.name &amp;&amp;\n  node.name.type === &#39;JSXIdentifier&#39; &amp;&amp;\n  &#39;name&#39; in node.name &amp;&amp;\n  typeof node.name.name === &#39;string&#39; &amp;&amp;\n  &#39;attributes&#39; in node &amp;&amp;\n  Array.isArray(node.attributes) &amp;&amp;\n  &#39;selfClosing&#39; in node\n) {\n  const elementName = node.name.name;\n\n  // 추출된 컴포넌트 정보들에서 본 노드의 이름과 동일한 정보가 있는지 찾는다.\n  const targetComponentDeclarations = componentDeclarations.filter(\n    componentDeclaration =&gt; componentDeclaration.name === elementName\n  );\n\n  if (targetComponentDeclarations.length) {\n    // 만약 있다면,\n    // 해당 노드의 속성 배열에 className 존재 여부를 판단한다.\n    // 판단 여부에 따라 className의 값을 이어붙이거나, 새롭게 생성한다.\n    const { tag, styles } = targetComponentDeclarations[0];\n    const newAttributes = generateJSXOpeningElementClassNameAttribute(\n      node.attributes,\n      convertStyles(styles)\n    );\n\n    // 열린 태그의 컴포넌트 이름을 태그명으로 덮어쓴다.\n    node.name.name = tag;\n    // 열린 태그의 속성 배열을 새롭게 생성된 속성 배열로 덮어쓴다.\n    node.attributes = newAttributes;\n\n    // 만약 닫힌 태그가 있다면,\n    // 닫힌 태그의 컴포넌트 이름을 태그명으로 덮어쓴다.\n    if (!node.selfClosing) {\n      if (\n        &#39;closingElement&#39; in parentNode &amp;&amp;\n        isObject(parentNode.closingElement) &amp;&amp;\n        &#39;name&#39; in parentNode.closingElement &amp;&amp;\n        isObject(parentNode.closingElement.name) &amp;&amp;\n        &#39;name&#39; in parentNode.closingElement.name\n      ) {\n        parentNode.closingElement.name = tag;\n      }\n    }\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>결과적으로 다음과 같이 변환된다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">function Component() {\n  return (\n    &lt;Wrapper&gt;\n      &lt;Title&gt;Hello World!&lt;/Title&gt;\n    &lt;/Wrapper&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">function Component() {\n  return (\n    &lt;section className=&quot;p-16 bg-#ffefd5&quot;&gt;\n      &lt;h1 className=&quot;text-2xl text-center text-[#bf4f74]&quot;&gt;Hello World!&lt;/h1&gt;\n    &lt;/section&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"남은-과제\" style=\"position:relative;\"><a href=\"#%EB%82%A8%EC%9D%80-%EA%B3%BC%EC%A0%9C\" aria-label=\"남은 과제 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>남은 과제</h2>\n<p>단번에 모든 스타일된 컴포넌트 코드 스타일을 커버할 수 있는 변환기를 만들겠노라 목표하진 않았지만, 아직 조건부 스타일을 위한 보간 (interpolation)을 어떻게 처리해야 할 지 고민이 크다.</p>\n<deckgo-highlight-code language=\"tsx\" theme=\"nord\"  >\n          <code slot=\"code\">const Card = styled.div&lt;{ isSelected: boolean }&gt;`\n  ... border-width: ${({ isSelected }) =&gt; (isSelected ? &#39;4px&#39; : &#39;2px&#39;)}; // ?\n`;</code>\n        </deckgo-highlight-code>\n<p>보간의 경우 그대로 열린 태그의 <code class=\"language-text\">style</code> 속성에 옮겨주면 괜찮지 않을까 싶지만, 열린 태그를 반환하는 스코프 내에서 아래와 같이 참조 가능한 변수 선언인지 판단이\n필요하다. 우선 옮겨주고 에러 픽스는 작업자에게 맡겨도 되지 않을까 싶지만 에러가 담긴 코드를 뱉어 일을 두번 만들고 싶지는 않다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">// card\n&lt;div style={{\n  borderWidth: isSelected ? &#39;4px&#39; : &#39;2px&#39;\n              // &#39;isSelected&#39; is not defined\n}}&gt;</code>\n        </deckgo-highlight-code>\n<p>스타일 추출을 위해 <code class=\"language-text\">sass</code> 컴파일을 진행할 때 보간을 만나면 문법 에러를 발생시키기 때문에 현재 버전에서는 보간문을 모두 <code class=\"language-text\">unset</code> 속성으로 대체하여 변환하고 있다.</p>\n<h2 id=\"마치면서\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C\" aria-label=\"마치면서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치면서</h2>\n<p>실무에서 사용하려 제작한 스크립트를 라이브러리로 제작하면서 배운 점이 많다. 추상 구문 트리를 조작하여 코드를 전처리한다는 접근법은 이후에도 유사한 작업을 처리할 때\n유용하게 사용될 것 같다. 위에서 언급한 과제들이 남아있지만 유사한 작업을 진행 중이신 분들에게 개선된 개발자 경험에 있어 작게나마 도움이 될 수 있으면 좋겠다.</p>","frontmatter":{"title":"tailwind-converter 제작기","description":"아직은 미숙합니다.","date":"2023.09.05"}}},"pageContext":{"slug":"/development/tailwind-converter/","previous":{"fields":{"slug":"/essay/2023-first-half-retrospect/"},"frontmatter":{"title":"2023 상반기 회고"}},"next":{"fields":{"slug":"/development/git-glances-skills-retrospect/"},"frontmatter":{"title":"웹 제품을 만들기 위한 개발 환경과 기술 스택 되짚어보기"}}}},"staticQueryHashes":["3665086019"],"slicesMap":{}}