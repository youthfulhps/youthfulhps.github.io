{"componentChunkName":"component---src-templates-blog-post-tsx","path":"/javascript/do-I-know-javascript-generator/","result":{"data":{"site":{"siteMetadata":{"title":"Youthfulhps.dev","description":"프론트엔드 주니어 개발자, 트러블슈팅에 대한 고민의 흔적을 기록으로 남기는 것을 좋아합니다.","author":"youthfulhps","siteUrl":"https://youthfulhps.dev","thumbnail":"/banner.png","comment":{"disqusShortName":"youthfulhps","utterances":"youthfulhps/youthfulhps.github.io"},"sponsor":{"buyMeACoffeeId":"youthfulhps"}}},"markdownRemark":{"id":"2a72cf34-3e70-5119-a588-16451770ad99","excerpt":"리덕스 사가는 ES6에 새롭게 도입된 제네레이터 (Generator…","html":"<p>리덕스 사가는 ES6에 새롭게 도입된 제네레이터 (Generator) 문법을 사용하여 유용하게 비동기 처리를 할 수 있게 해줍니다.\n현재 운영 중인 프러덕션 또한, 리덕스에서 사이드 이펙트가 존재할 만한 비동기적인 비지니스 로직을 관리하기 위해 리덕스 사가 미들웨어를 사용하고 있는데요.</p>\n<p>늘 사용하고 있는 문법이고 동작 또한 해석이 되니 작업에 문제는 없지만, 제네레이터에 대한 이론적인 이해 정도를 스스로 질문했을 때\n한창 공부했을 때의 이론적 대답이 쉽게 나오지 않는 걸 느끼고 다시 한번 정리를 해볼 까 합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 692px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 60%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAADGElEQVR42i2Ta1NaVxSGz//oNG2n6USjTgigCEEEQbkeBM6BAwjIHWRKDtFEo9F6iTVRk0nS1sR6i2k7zrTNpeOH/r2ny7Yf1oc9s/ez3netdysTTgtqYJRE2CV1h4IWwJh00EhPMd802Ho0x8q3Oe6WE9xraaw+qFApaYy4HbQqSbp1jV47QyMXYW4mihLzO5jRA2QTXjLT4xRTfpbmcrzZWeBoqcKrxQrPNrtsrbRYv19hZ7XFxsM6C50sdYFkY2M0inGOf1jn5ZaJ0piJUS+oNP6vfCqAHnLxop1iyQhQkAdP5md5vtygXQiLSp0V06CUCTI2akMLOUnHvcy3DMJ+F0q3ptOtpTEbBs2KRssI80Iu71VVmtIsH/fwuqPxaa1OR/NSjzhpaONEE1PYbUNk5Ww2dYzoGNe//AylXYzREu+NospqKc6f0uAs7qOQDNHMqzzMBjloJjnpZphP+NlX73BYmkT1WLFb++kVJsV6iFjYg806gDInoCvYWjXJ3+0sHwXyXTZGuZjBVH1siuUN3c9jfYLpgJdh+zBmyEHQNYzVMsRCOUyrpFKaiVMtJVA6cmjPxrkQ2Idikp9SkxzpQV6qHrYDDpalnmam2JJlPdUmOTarLHYK1GpZOs0cjYouo9JplTUq+ThKNRumkw3xetrPmRbkUOzuuQZ55Bxk1T9CyXKdptfGpsRqQ2xezqhclJPM5cPMivJWIYrZNjBlKT3ZvJKXuFzFJuez0bbeYMneR/vmNXoj/dxzWzD6Pict9dhzm/uuIZ5Jk4+ZCO8Xa+xv9zg72uH9Hz9y+ekNf304QCmmQ5SMCAXZbiriRhV1swJoD/fxwGena79Bd+QmF2LXFNXVgWscBF1cFuL8vtbh8HCbk5+3+eV8j4vfnqPEYz6iES9q1EtanyKXmGBBYE1bH6b7FhlRqw9+xanEoidgdeALlmW+r+RD/CrWT0+ecH66y7u3u/8Bh71uRgM+3P5xvBNOUkE366KkZvka02PhbsBG3nOLNUc/3dvfoAuwexUzr5Xvc2Hene9zdrzD27Pdf8H/AJ+I8LWJ201+AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"thumbnail\"\n        title=\"\"\n        src=\"/static/3680d6a9d644d9a43883a52be0c08cb8/91e7e/thumbnail.png\"\n        srcset=\"/static/3680d6a9d644d9a43883a52be0c08cb8/5a46d/thumbnail.png 300w,\n/static/3680d6a9d644d9a43883a52be0c08cb8/0a47e/thumbnail.png 600w,\n/static/3680d6a9d644d9a43883a52be0c08cb8/91e7e/thumbnail.png 692w\"\n        sizes=\"(max-width: 692px) 100vw, 692px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>참고로, 이 글은 <a href=\"https://poiemaweb.com/es6-iteration-for-of\">이터레이션</a>, <a href=\"https://poiemaweb.com/es6-generator\">제네레이터</a>의 전개와 예시가 유사합니다.\n저는 바이블처럼 여기는 <a href=\"https://poiemaweb.com/\">PoiemaWeb</a> 글을 참고하여 공부하며 정리하기를 좋아합니다.</p>\n<h2 id=\"제네레이터-왜-등장했을-까\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0-%EC%99%9C-%EB%93%B1%EC%9E%A5%ED%96%88%EC%9D%84-%EA%B9%8C\" aria-label=\"제네레이터 왜 등장했을 까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제네레이터, 왜 등장했을 까?</h2>\n<p>제네레이터는 ES6에서 도입된 새로운 함수입니다. 그 역할은 이터러블을 간편하게 구현할 수 있도록 고안된 함수라고 설명합니다.</p>\n<p>그렇다면, 제네레이터를 사용하지 않고 어떻게 이터러블을 구현하는 지 알아보면, 제네레이터의 등장이 더 와닿을 수 있을 것 같은데요.</p>\n<p>여기서 먼저 짚고 넘어가고 싶은 것은, 제네레이터를 이야기 할때면 꼭 등장하지만 늘 혼동되는 이터레이션 (iteration), 이터러블 (iterable), 이터레이터 (iterator)를 먼저 알아보고, 제네레이터를 사용하지 않고 어떻게 이터러블을 구현하는 지 알아봅시다.</p>\n<h2 id=\"이터레이션-프로토콜-데이터-순회-이렇게-약속하자\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%EC%85%98-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%88%9C%ED%9A%8C-%EC%9D%B4%EB%A0%87%EA%B2%8C-%EC%95%BD%EC%86%8D%ED%95%98%EC%9E%90\" aria-label=\"이터레이션 프로토콜 데이터 순회 이렇게 약속하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이터레이션 프로토콜, 데이터 순회 이렇게 약속하자</h2>\n<p>ES6에서 도입된 이터레이션 프로토콜 (Iteration Protocol)은 데이터 컬렉션을 순회하기 위한 프로토콜입니다.\n여기서, 이터레이션 프로토콜에는 이터러블 프로토콜 그리고, 이터레이터 프로토콜이 있습니다. 용어가 벌써 혼동되기 시작하는데,\n심호흡 한번 하고 넘어가보죠.</p>\n<h2 id=\"이터러블-순회할-수-있는-데이터-공급자\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94-%EC%88%9C%ED%9A%8C%ED%95%A0-%EC%88%98-%EC%9E%88%EB%8A%94-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EA%B8%89%EC%9E%90\" aria-label=\"이터러블 순회할 수 있는 데이터 공급자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이터러블, 순회할 수 있는 데이터 공급자</h2>\n<p>이터러블 프로토콜 (Iterable Protocol)을 준수한 객체를 이터러블이라고 합니다.\n구현되었거나, 프로토타입 체인에 의한 상속을 통해 <code class=\"language-text\">Symbol.iterator</code> 메서드를 가지고 있는 객체를 말합니다.</p>\n<p>이터러블은 <code class=\"language-text\">for...of</code> 문에서 순회할 수 있고, <code class=\"language-text\">Spread</code> 문법의 대상이 될 수 있습니다. 번뜩 생각나는 대표적인 객체는 배열입니다.\n<code class=\"language-text\">for...of</code>, <code class=\"language-text\">Spread</code> 의 대상으로 배열을 사용할 수 있었던 근거가 여기 있었군요.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">const numbers = [1, 2, 3, 4, 5];\n\nconsole.log(Symbol.iterator in numbers); // true\n\nfor (let number of numbers) {\n  console.log(number);\n}</code>\n        </deckgo-highlight-code>\n<p>반면, 일반 객체는 <code class=\"language-text\">Symbol.iterator</code> 메서드를 가지고 있지 않기 때문에 이터러블이 아닙니다.\n프로토타입 체인으로부터 <code class=\"language-text\">Symbol.iterator</code>를상속받지 못했기 때문인데요. 하지만, 구현해준다면 이터러블 프로토콜을 준수한 이터러블이 될 수 있습니다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">const object = { a: 1, b: 2, c: 3 };\n\nconsole.log(Symbol.iterator in object); // false\n\nfor (const property of object) {\n  // TypeError: object is not iterable\n  console.log(property);\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"이터레이터-순회-데이터-공급자의-다음-엘리먼트에는-이렇게-접근하자\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%ED%84%B0-%EC%88%9C%ED%9A%8C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EA%B8%89%EC%9E%90%EC%9D%98-%EB%8B%A4%EC%9D%8C-%EC%97%98%EB%A6%AC%EB%A8%BC%ED%8A%B8%EC%97%90%EB%8A%94-%EC%9D%B4%EB%A0%87%EA%B2%8C-%EC%A0%91%EA%B7%BC%ED%95%98%EC%9E%90\" aria-label=\"이터레이터 순회 데이터 공급자의 다음 엘리먼트에는 이렇게 접근하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이터레이터, 순회 데이터 공급자의 다음 엘리먼트에는 이렇게 접근하자</h2>\n<p>이터레이터 프로토콜 (iterator protocol)을 준수하는 객체를 이터레이터라고 합니다.\nnext 메서드를 소유하며, 호출 시 이터러블을 순회하며 <code class=\"language-text\">value</code>,<code class=\"language-text\"> done</code> 프로퍼티를 갖는 이터레이터 result 객체를 반환하는 객체를 말합니다.</p>\n<p>이터러블은 <code class=\"language-text\">Symbol.iterator</code> 메서드를 가지고 있다고 언급했는데요. 이 메서드를 호출하면 이터레이터를 반환합니다.\n물론, 이터레이터 프로토콜을 준수한다면 next 메서드를 가지고 있습니다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">const arr = [1, 2, 3, 4, 5];\n\nconst iterator = arr[Symbol.iterator]();\n\nconsole.log(&quot;next&quot; in iterator); // true\n\nlet resultObject = iterator.next();\nconsole.log(resultObject); // {value: 1, done: false}</code>\n        </deckgo-highlight-code>\n<p>순회 데이터 컬렉션 엘리먼트들을 순회하기 위한 포인터 역할을 담당하는 메서드가 바로 <code class=\"language-text\">next</code> 입니다.\n<code class=\"language-text\">next</code> 메서드를 호출하면 이터러블을 순차적으로 순회합니다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">console.log(iterator.next()); // {value: 1, done: false}\nconsole.log(iterator.next()); // {value: 2, done: false}\n...\nconsole.log(iterator.next()); // {value: 5, done: false}\nconsole.log(iterator.next()); // {value: undefined, done: true}</code>\n        </deckgo-highlight-code>\n<h2 id=\"이터레이션-프로토콜-다양한-데이터-공급자의-약속된-순회-방식을-제공하자\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%ED%84%B0%EB%A0%88%EC%9D%B4%EC%85%98-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%8B%A4%EC%96%91%ED%95%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EA%B3%B5%EA%B8%89%EC%9E%90%EC%9D%98-%EC%95%BD%EC%86%8D%EB%90%9C-%EC%88%9C%ED%9A%8C-%EB%B0%A9%EC%8B%9D%EC%9D%84-%EC%A0%9C%EA%B3%B5%ED%95%98%EC%9E%90\" aria-label=\"이터레이션 프로토콜 다양한 데이터 공급자의 약속된 순회 방식을 제공하자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이터레이션 프로토콜, 다양한 데이터 공급자의 약속된 순회 방식을 제공하자</h2>\n<p>이터레이션 프로토콜에 속하는 이터러블 프로토콜과 이터러블 그리고, 이터레이터 프로토콜과 이터레이터를 간단하게 알아봤는데요.\n이터레이션 프로토콜이 왜 필요할까요?</p>\n<p><code class=\"language-text\">Array</code>, <code class=\"language-text\">String</code>, <code class=\"language-text\">Map</code>, <code class=\"language-text\">Set</code> 등 다양한 데이터 공급자들이 각각의 순회 방식을 갖고 있다면, 다양한 순회 방식을 지원하는\n데이터 소비자가 필요합니다. 가령, <code class=\"language-text\">Array</code>는 <code class=\"language-text\">for...of</code>로 순회할 수 있지만, <code class=\"language-text\">String</code> 은 <code class=\"language-text\">String</code> 만의 데이터 소비자가 필요하게 되는 것이죠.</p>\n<p>결국, 이터레이션 프로토콜이 하고자 하는 목적은 다양한 데이터 공급자인 소스들이 동일한 약속된 순회 방식을 갖도록 하여\n데이터 소비자에게 일정한 인터페이스를 제공하자는 것이 목적입니다.</p>\n<h2 id=\"제네레이터를-사용하지-않고-이터러블을-생성해보자\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%98%EC%A7%80-%EC%95%8A%EA%B3%A0-%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%B4%EB%B3%B4%EC%9E%90\" aria-label=\"제네레이터를 사용하지 않고 이터러블을 생성해보자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제네레이터를 사용하지 않고, 이터러블을 생성해보자</h2>\n<p>제네레이터와 관련된 프로토콜에 대한 용어 정의를 간단하게 했으니, 이제 다시 본론으로 돌아와 제네레이터를 사용하지 않고\n이터레이션 프로토콜을 준수하는 이터러블을 구현해보겠습니다.</p>\n<p>이터레이션 프로토콜인 이터러블 프로토콜을 준수하기 위해 <code class=\"language-text\">Symbol.iterator</code> 메서드를 구현하여 이터레이터를 반환해주었고,\n<code class=\"language-text\">next</code> 메서드를 구현하여 이터레이터 프로토콜을 준수해 주었습니다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">const arithmeticSequence = (function () {\n  let cur = 0;\n\n  return {\n    [Symbol.iterator]() {\n      return this;\n    },\n    next() {\n      cur += 1;\n      return { value: cur, done: cur === 5 };\n    },\n  };\n})();\n\nfor (let cur of arithmeticSequence) {\n  console.log(cur); // 1, 2, 3, 4\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"제네레이터를-사용해서-이터러블을-생성해보자\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-%EC%9D%B4%ED%84%B0%EB%9F%AC%EB%B8%94%EC%9D%84-%EC%83%9D%EC%84%B1%ED%95%B4%EB%B3%B4%EC%9E%90\" aria-label=\"제네레이터를 사용해서 이터러블을 생성해보자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제네레이터를 사용해서 이터러블을 생성해보자</h2>\n<p>위와 동일한 데이터 컬렉션을 가지는 이터러블을 제네레이터를 통해 구현해보겠습니다.\n상단의 구현방법보다 훨씬 간편하게 이터러블을 생성할 수 있습니다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">const arithmeticSequence = (function* () {\n  let cur = 0;\n\n  while (cur &lt; 4) {\n    cur += 1;\n    yield cur;\n  }\n})(); //prettier issue  =&gt; }());\n\nfor (let cur of arithmeticSequence) {\n  console.log(cur); // 1, 2, 3, 4\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"제네레이터-동작-방식과-정의\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D%EA%B3%BC-%EC%A0%95%EC%9D%98\" aria-label=\"제네레이터 동작 방식과 정의 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제네레이터, 동작 방식과 정의</h2>\n<p>제네레이터는 일반 함수와 다르게 함수의 코드 블록을 한 번에 실행하지 않고, 함수 코드 블록 실행을 잠시 멈추었다가\n필요한 시점에 재시작할 수 있습니다.</p>\n<p>일반 함수를 호출하면 return 문에서 반환하는 값을 반환받게 되는데, 제네레이터 함수를 호출하면 제네레이터를 반환받습니다.</p>\n<p>이 제네레이터는 이터러블이면서, 이터레이터인 객체입니다. 즉, 프로토콜을 입각해 생각해보면 <code class=\"language-text\">Symbol.iterator</code> 메서드를\n소유함과 동시에 <code class=\"language-text\">next</code> 메서드를 소유하는 객체를 가지고 있는 이터레이터입니다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">function* counter () {\n  for (const count of [1,2,3,4,5]) yield count;\n}\n\nlet generator = counter();\n\nconsole.log(Symbol.iterator in generator);  // true\n\nfor (const count of generator) {\n  console.log(count);\n}\n\ngenerator = counter();\n\nconsole.log(&#39;next&#39; in generator);  // true\n\nconsole.log(generator.next()); // {value: 1, done: false}\nconsole.log(generator.next()); // {value: 2, done: false}\n...\nconsole.log(generator.next()); // {value: 5, done: false};\nconsole.log(generator.next()); // {value: undefined, done: true}</code>\n        </deckgo-highlight-code>\n<h2 id=\"제네레이터-비동기-처리에-사용해보자\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EB%84%A4%EB%A0%88%EC%9D%B4%ED%84%B0-%EB%B9%84%EB%8F%99%EA%B8%B0-%EC%B2%98%EB%A6%AC%EC%97%90-%EC%82%AC%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90\" aria-label=\"제네레이터 비동기 처리에 사용해보자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제네레이터, 비동기 처리에 사용해보자</h2>\n<p>제네레이터를 사용하면 비동기 처리를 동기처럼 동작하도록 구현할 수 있습니다. 가령, 사이드 이펙트가 존재하는 API 함수에서\n데이터를 성공적으로 전달받았을 때 혹은 실패하였는 지 결과를 기다린 후에 next 메서드를 통해 연개된 동작을 재시작할 수 있습니다.</p>\n<p>ES7에서 도입된 <code class=\"language-text\">async, await</code> 를 통해 제네레이터보다 직관적으로 비동기 처리를 동기적으로 처리할 수 있게 됐지만, 참고할 만한 동작입니다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">function getUser(generator, username) {\n  fetch(`https://api.github.com/users/${username}`)\n    .then((res) =&gt; res.json())\n    .then((user) =&gt; generator.next({ userName: user.name, error: false }))\n    .catch((error) =&gt; generator.next({ userName: &quot;unknown&quot;, error: true }));\n}\n\nconst generator = (function* () {\n  let user;\n  user = yield getUser(generator, &quot;youthfulhps&quot;);\n  if (user.error) {\n    //...handle error\n    return;\n  }\n\n  console.log(user.userName);\n})();\n\ngenerator.next();</code>\n        </deckgo-highlight-code>\n<h2 id=\"마치면서\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C\" aria-label=\"마치면서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치면서</h2>\n<p>실무에서 당연하게 사용하고 있었던 리덕스 사가의 제네레이터에 대한 개념을 다시 한번 정리해서 흝어져있던\n퍼즐이 다시 맞춰지는 것 같아 기분이 좋습니다. 실무에서 경험한 것들을 정리하는 위주로 블로그를 활용했었는데\n종종 공부하는 글도 적는 습관을 들여야 할 것 같습니다 :)</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://poiemaweb.com/es6-iteration-for-of\">https://poiemaweb.com/es6-iteration-for-of</a></li>\n<li><a href=\"https://poiemaweb.com/es6-generator\">https://poiemaweb.com/es6-generator</a></li>\n</ul>","frontmatter":{"title":"나는 제네레이터를 알고 사용하는 걸까?","description":"자바스크립트의 제네레이터 문법을 되새겨봅니다.","date":"2021.11.21"}}},"pageContext":{"slug":"/javascript/do-I-know-javascript-generator/","previous":{"fields":{"slug":"/development/benefits-specification-driven-development/"},"frontmatter":{"title":"OpenAPI 스펙 주도 개발을 통해 클라이언트 개발 환경을 개선하기 위한 노력들"}},"next":{"fields":{"slug":"/nextjs/cra-to-next/"},"frontmatter":{"title":"CRA 프로젝트를 next.js로 전환해보자"}}}},"staticQueryHashes":["3665086019"],"slicesMap":{}}