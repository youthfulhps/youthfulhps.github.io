{"componentChunkName":"component---src-templates-blog-post-js","path":"/javascript/nodejs-module-system/","result":{"data":{"site":{"siteMetadata":{"title":"Youthfulhps.dev","description":"프론트엔드 주니어 개발자, 트러블슈팅에 대한 고민의 흔적을 기록으로 남기는 것을 좋아합니다.","author":"youthfulhps","siteUrl":"https://youthfulhps.dev","thumbnail":"/banner.png","comment":{"disqusShortName":"youthfulhps","utterances":"youthfulhps/youthfulhps.github.io"},"sponsor":{"buyMeACoffeeId":"youthfulhps"}}},"markdownRemark":{"id":"dabd55fb-f560-59a2-9094-30acedbcb4ab","excerpt":"…","html":"<p>최근 라이브러리를 제작하면서 <code class=\"language-text\">CommonJS</code>와 <code class=\"language-text\">ECMAScript</code> 모듈 시스템(이하 <code class=\"language-text\">ESM</code>)에 대한 모듈 시스템 포맷이 혼란스러웠던 기억이 있다. 패키지를 빌드할 때 각각의\n모듈 시스템을 사용하는 포맷으로 빌드 결과물을 만들어 주어야 했는데, 사실 <code class=\"language-text\">import</code>, <code class=\"language-text\">require</code> 등 구문 정도의 차이를 이해했을 뿐 모듈 시스템의 구조적인\n라이브러리 제작자로서 대응해 주어야 하는 작업에 대해 크게 고민해 본 적이 없었기 때문일 것이다.</p>\n<p>특히나 최신 프론트엔드 개발 환경에 익숙한 개발자라면 <code class=\"language-text\">ESM</code>을 일상적으로 사용하고 있어 가령 <code class=\"language-text\">require</code>이 번들링에 어떤 영향을 끼치는지 궁금해 하기란 사실 쉽지 않은 일이고,\n<code class=\"language-text\">node.js</code>에서 <code class=\"language-text\">ESM</code>도 공식적으로 지원하기 시작하면서 독립적으로 개발된 <code class=\"language-text\">CommonJS</code> 모듈 시스템을 청산해야 한다는 이야기도 많은 탓에 자연스럽게 멀리하게 된다.</p>\n<p>그러나 <code class=\"language-text\">node.js</code>에서 <code class=\"language-text\">CommonJS</code> 모듈 시스템 기반으로 제작되어 있는 라이브러리 생태계가 건재하고, 여전히 두 모듈 시스템이 공존하고 있기 때문에 각각의 모듈 시스템의\n이해와 현 상황을 이해할 필요가 있다. 언젠가 <code class=\"language-text\">node.js</code> 생태계에서 하나의 모듈 시스템을 사용하는 날이 오길 기대하며 현재 <code class=\"language-text\">node.js</code>가 지원하고 있는 대표적인\n모듈 시스템들을 살펴보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 984px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 47.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAACkElEQVR42iWRW08iBwBGp02Tdhe5CAwygIPcZBgYGIb7cEeWIbIoqKzsdhTTtdqgm0r70DSND33cPvYPn07S9y8nOecTvG4R956feEjE7hZ4nhqsT/oksjPMkydWt/9gnf1Jtmwzmr+yuvsXo/uFTPmG1smO0ekrKc2m1nth/P4VIeETiXqCJIMiG1PheaJx1W2iaHNWyy3bp69Yiz/Il87pT1+4sL+imw9kSmva4xc64984yl1S7W3pTXYItbTCRFdoKzKfGikeBzl+XYxRinMeFkt29zuG89/pl5vcTibMr/5Ca25Ia5e0332h3n8kdjyn3L7HHP2C8Hw+YjvVsYw01xWZx84RPw4qJNNdopEKsViLwfgnlESad7rK7PRn1JpNMn/mAJ8omxukpIXeuqPR+4zwvqHQyRxgN2QuihIfdIlZOYNWniBFqri8RTq9FaLPx/7eW0Zj2+l5TVyZOsqPFBufEOUhpYbTsbNBsHIhZvkQz8MECzXIqiAyzh2SVYfE43ViER2jdsq+y8V3335DpbkkVVgQSY9pDT9TqF4RiPYo1NYYbRthNzhk2w5zY/hYKj4+5H1M1BhyuoNWHFBSW9TbFwT3w3g9Io3OR47UGVJi6DT7H+iPtFArV5Raa4RN1Y9dj3BntbCtHvfnFjddjbiskc31CUcbFEtDAn6ZN2+8TtsmUtwkIBlkNQs51cPtz3OY6BBPtRFudQ/risRyOmO9vOTho83f1zO6eZ1wzMDrSxE7LOH3p/jhexcHBynEqIk3ZCBnBoTjHfb8zlbuEkv2Ec5qSU4bKv16lUGzzlnf5G5kUjxKEwofO5pBAmICtzuC660HUYyzLxbwBHJIcg1RKjnHHRMI64QiBv8BVMRG83PuzHsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"썸네일\"\n        title=\"\"\n        src=\"/static/72f35027b0c63e01aa9029dd3e9b0c79/0b6f4/thumbnail.png\"\n        srcset=\"/static/72f35027b0c63e01aa9029dd3e9b0c79/5a46d/thumbnail.png 300w,\n/static/72f35027b0c63e01aa9029dd3e9b0c79/0a47e/thumbnail.png 600w,\n/static/72f35027b0c63e01aa9029dd3e9b0c79/0b6f4/thumbnail.png 984w\"\n        sizes=\"(max-width: 984px) 100vw, 984px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h2 id=\"자바스크립트-구동-환경을-확장하기-위한-행보\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B5%AC%EB%8F%99-%ED%99%98%EA%B2%BD%EC%9D%84-%ED%99%95%EC%9E%A5%ED%95%98%EA%B8%B0-%EC%9C%84%ED%95%9C-%ED%96%89%EB%B3%B4\" aria-label=\"자바스크립트 구동 환경을 확장하기 위한 행보 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바스크립트 구동 환경을 확장하기 위한 행보</h2>\n<p>웹 브라우저의 동적인 조작을 구사하기 위해 탄생한 자바스크립트는 브라우저와 함께 성장과 인기를 얻게 되었다. 이에 따라 브라우저뿐만 아니라 더 다양한 환경에서\n자바스크립트를 사용하고자 원하는 목소리들도 커지게 된다.</p>\n<p>그 중 단순히 니즈만 내세우는 것이 아니라 구체적인 액션 플랜을 제안한 Kevin Dangoor는 <a href=\"https://www.blueskyonmars.com/2009/01/29/what-server-side-javascript-needs/\">What Server Side JavaScript needs</a>\n라는 제목의 글을 통해 자바스크립트가 다른 환경에서 사용되기 위해 선행되어야 하는 작업들을 나열했다.</p>\n<p>더불어 오늘날 <code class=\"language-text\">CommonJS</code>라 불리는 모듈 시스템을 제작하기 위한 그룹을 결성하고 라이브러리, 인터페이스, 패키지 매니저, 그리고 오늘의 주제인 모듈 시스템에\n대한 표준화 작업을 진행하게 된다.</p>\n<h2 id=\"commonjs\" style=\"position:relative;\"><a href=\"#commonjs\" aria-label=\"commonjs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>CommonJS</h2>\n<blockquote>\n<p>javascript, not just for browsers any more!</p>\n</blockquote>\n<p><code class=\"language-text\">CommonJS</code>는 자바스크립트를 브라우저 외에도 서버사이드를 포함한 다양한 환경에서 범용적으로 사용할 수 있도록 <a href=\"https://arstechnica.com/information-technology/2009/12/commonjs-effort-sets-javascript-on-path-for-world-domination/\">다양한 기능</a>\n들을 표준화했고, 이때 제작된 모듈 시스템은 <code class=\"language-text\">node.js</code>에서 사용되는 모듈 시스템의 근본이 된다.</p>\n<h3 id=\"모듈-불러오기\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%93%88-%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0\" aria-label=\"모듈 불러오기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모듈 불러오기</h3>\n<p>모듈 시스템의 기본적인 동작인 모듈을 불러오고, 내보내는 기능들을 코드에서 살펴보자. <code class=\"language-text\">CommonJS</code>는 <code class=\"language-text\">require</code> 함수를 통해 모듈을 불러와 사용한다.\n여기서 <code class=\"language-text\">require</code>은 동적으로 모듈을 불러와 사용하기 때문에 최상단에서만 모듈을 불러오는 제약을 가지는 <code class=\"language-text\">ESM</code>과 차이가 있다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">// import\nconst math = require(&#39;math.js&#39;);\n\nif (condition) {\n  const square = require(&#39;square.js&#39;);\n  square.area(3);\n}\n\nmath.add(1, 2);</code>\n        </deckgo-highlight-code>\n<h3 id=\"정적-바인딩\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%A0%81-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\"정적 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정적 바인딩</h3>\n<p><code class=\"language-text\">CommonJS</code>는 모듈이 정적으로 바인딩되는 것이 특징이다. 정적 바인딩이란, <code class=\"language-text\">require</code>을 통해 불러온 값의 복사본을 사용한다는 것과 같다. 이는 불러온 모듈 내에서\n내보내진 값의 변경이 발생해도 사용처에서는 변경된 값을 알 수 없다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">// lib.js\nvar counter = 3;\nfunction incCounter() {\n  counter++;\n}\nmodule.exports = {\n  counter,\n  incCounter,\n};</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">// main.js\nvar counter = require(&#39;./lib&#39;).counter;\nvar incCounter = require(&#39;./lib&#39;).incCounter;\n\n// The imported value is a (disconnected) copy of a copy\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 3\n\n// The imported value can be changed\ncounter++;\nconsole.log(counter); // 4</code>\n        </deckgo-highlight-code>\n<h3 id=\"동기적인-모듈-실행\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EA%B8%B0%EC%A0%81%EC%9D%B8-%EB%AA%A8%EB%93%88-%EC%8B%A4%ED%96%89\" aria-label=\"동기적인 모듈 실행 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동기적인 모듈 실행</h3>\n<p><code class=\"language-text\">CommonJS</code>는 모듈을 동기적으로 불러와 하나씩 순서대로 실행한다. 동적으로 모듈을 불러오는 탓에 런타임에 모듈 요청 여부를 판단할 수 있어 모듈 요청이 이루어진\n후에야 모듈 내에서 발생하는 여러 동작들을 동기적으로 완료한 후 내보내진 값을 취할 수 있게 된다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">// module1.js ~ module2.js\nconsole.log(&#39;Module1 loading...&#39;);\n\nsetTimeout(() =&gt; {\n  console.log(&#39;Module1 load complete and run!&#39;);\n}, 1000);\n\nconsole.log(&#39;Module1 run completed!&#39;);</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">// index.js\nconsole.log(&#39;Run index!&#39;);\nconst module1 = require(&#39;./module1&#39;);\nconsole.log(&#39;index:...&#39;);\nconst module2 = require(&#39;./module2&#39;);\nconsole.log(&#39;index run completed!&#39;);\n\n// Run index!\n// Module1 loading...\n// Module1 run completed!\n// index:...\n// Module2 loading...\n// Module2 run completed!\n// Module1 load complete and run!\n// Module2 load complete and run!\n// index run completed!</code>\n        </deckgo-highlight-code>\n<h3 id=\"로드가-완료된-모듈은-캐싱된다\" style=\"position:relative;\"><a href=\"#%EB%A1%9C%EB%93%9C%EA%B0%80-%EC%99%84%EB%A3%8C%EB%90%9C-%EB%AA%A8%EB%93%88%EC%9D%80-%EC%BA%90%EC%8B%B1%EB%90%9C%EB%8B%A4\" aria-label=\"로드가 완료된 모듈은 캐싱된다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>로드가 완료된 모듈은 캐싱된다</h3>\n<p>한번 로드가 완료된 모듈에 대해서 캐싱되고, 이후 같은 모듈 요청에 대해 캐싱된 값을 반환한다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">// module1.js\nconsole.log(&#39;Run Module1!&#39;);\n\nmodule.exports = &#39;Module1&#39;;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">const module1 = require(&#39;./module1&#39;);\nconst module2 = require(&#39;./module1&#39;);\nconst module3 = require(&#39;./module1&#39;);\n\nconsole.log(module1, module2, module3);\n\n// Run Module1!\n// Module1 Module1 Module1</code>\n        </deckgo-highlight-code>\n<p>만약 캐시를 지우고 싶다면, <code class=\"language-text\">require.cache</code>에 접근해 제거할 수 있다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">const module1 = require(&#39;./module1&#39;);\n\ndelete require.cache[require.resolve(&#39;./module1&#39;)];\n\nconst module2 = require(&#39;./module1&#39;);\nconst module3 = require(&#39;./module1&#39;);\n\nconsole.log(module1, module2, module3);\n\n// Run Module1!\n// Run Module1!\n// Module1 Module1 Module1</code>\n        </deckgo-highlight-code>\n<h3 id=\"모듈-내보내기\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%93%88-%EB%82%B4%EB%B3%B4%EB%82%B4%EA%B8%B0\" aria-label=\"모듈 내보내기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모듈 내보내기</h3>\n<p><code class=\"language-text\">CommonJS</code>는 모듈 각각의 독립적인 실행 영역과 스코프를 유지한 채 <code class=\"language-text\">module.exports</code>나 축약된 숏컷인 <code class=\"language-text\">exports</code>를 통해\n모듈을 내보낼 수 있다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">const { PI } = Math;\n\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction subtract(a, b) {\n  return a - b;\n}\n\nfunction circumference(r) {\n  return 2 * PI * r;\n}\n\nmodule.exports.add = add;\nmodule.exports.subtract = subtract;\nexports.circumference = circumference;\n\nconsole.log(module.exports === exports); // true</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">node.js</code>에서 내보내진 모듈을 구성할 때 <code class=\"language-text\">module wrapper</code> 함수를 통해 모듈 내의 코드를 래핑한다. 이는 위 예시 코드의 <code class=\"language-text\">Math</code>의 <code class=\"language-text\">PI</code>와 같이\n모듈에서 내보내지 않은 값들을 지역 변수로 은닉하여 글로벌 객체에 등록되는 것을 막는다. 또한 <code class=\"language-text\">module wrapper</code> 함수의 매개 변수들을\n통해 글로벌 객체의 값들을 참조할 수 있게 된다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">(function(exports, require, module, __filename, _dirname) {\n  // ... (모듈 코드)\n});</code>\n        </deckgo-highlight-code>\n<h3 id=\"moduleexports와-exports\" style=\"position:relative;\"><a href=\"#moduleexports%EC%99%80-exports\" aria-label=\"moduleexports와 exports permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>module.exports와 exports</h3>\n<p>모듈 내보내기의 예시 코드에서 <code class=\"language-text\">module.exports</code>와 <code class=\"language-text\">exports</code>가 함께 사용된 것을 확인할 수 있다. 이 둘의 차이가 있을 까 싶지만\n<a href=\"https://nodejs.org/api/modules.html#exports\">공식 문서</a>에서 알 수 있듯 <code class=\"language-text\">exports</code>는 단지 <code class=\"language-text\">module.exports</code>의 축약된 <code class=\"language-text\">shortcut</code>인 것이다.</p>\n<p>즉 <code class=\"language-text\">exports</code>는 <code class=\"language-text\">module.exports</code>가 기본적으로 내보낼 객체를 동일하게 가리키고 있어 위와 같이 객체에 새로운 키를 추가하여 내보낼 객체에 새로운 프로퍼티를\n할당하는 것은 어느 것을 사용해도 동일한 결과를 얻는다.</p>\n<p>그러나 주의해야 할 점은 <code class=\"language-text\">exports</code>나 <code class=\"language-text\">module.exports</code>에 새로운 함수나 객체를 할당해 내보내는 경우이다. 다음과 같이 <code class=\"language-text\">Square</code> 클래스를 <code class=\"language-text\">module.exports</code>\n에 할당하여 내보낸다면, <code class=\"language-text\">module.exports</code>는 새로운 객체를 참조하게 되어 <code class=\"language-text\">exports</code>와 참조 대상이 상이해진다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">module.exports = class Square {\n  constructor(width) {\n    this.width = width;\n  }\n\n  area() {\n    return this.width ** 2;\n  }\n};\n\nconsole.log(module.exports === exports); // false</code>\n        </deckgo-highlight-code>\n<p>하지만 <code class=\"language-text\">module.exports</code>가 <code class=\"language-text\">shortcut</code>인 <code class=\"language-text\">exports</code>와 다른 객체를 가리키게 되는 것은 크게 문제가 되지 않는다. 모듈을 불러오는 <code class=\"language-text\">require</code>함수는\n내부적으로 <code class=\"language-text\">module.exports</code>가 가리키는 값을 반환하기 때문이다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">function require() {\n  // ...\n  return module.exports;\n}\n\nconst Square = require(&#39;./Square.js&#39;);\nconsole.log(Square); // [class Square]</code>\n        </deckgo-highlight-code>\n<p>문제는 다음과 같이 <code class=\"language-text\">exports</code>를 통해 새로운 값을 할당해 내보내는 경우이다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">const { PI } = Math;\n\nexports = class Circle {\n  constructor(r) {\n    this.radius = r;\n  }\n\n  circumference() {\n    return 2 * PI * this.radius;\n  }\n};\n\nconsole.log(module.exports === exports); // false</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">export</code>에 새로운 값을 할당한다면, <code class=\"language-text\">module.exports</code>가 가리키고 있는 대상과 다른 참조를 가지게 된다. 이것 또한 구현상의 문제는 없어보이지만,\n위에서 언급한 것 처럼 <code class=\"language-text\">require</code>이 반환하는 <code class=\"language-text\">module.exports</code>과는 무관한 변경이기 때문에 의도한대로 모듈을 불러올 수 없게 된다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">const Square = require(&#39;./Square.js&#39;);\nconsole.log(Square); // [class Square]\n\nconst Circle = require(&#39;./Circle.js&#39;);\nconsole.log(Circle); // {}</code>\n        </deckgo-highlight-code>\n<p>결론적으로 <code class=\"language-text\">exports</code>를 통한 내보내기가 정상적으로 동작한다 하더라도, <code class=\"language-text\">module.exports</code>를 사용하는 것이 안전하다.</p>\n<h3 id=\"트리-쉬이킹의-한계\" style=\"position:relative;\"><a href=\"#%ED%8A%B8%EB%A6%AC-%EC%89%AC%EC%9D%B4%ED%82%B9%EC%9D%98-%ED%95%9C%EA%B3%84\" aria-label=\"트리 쉬이킹의 한계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>트리 쉬이킹의 한계</h3>\n<p>표준을 만들고자 독립적으로 설계되었던 <code class=\"language-text\">CommonJS</code>의 모듈 시스템은 자바스크립트의 근간을 다루는 혁명(?)처럼 느껴져 단점을 논하자니\n괜히 겸허해진다. 사실 단점이라고 하기보단 이후에 등장한 자바스크립트의 공식적인 모듈 시스템과 비교에 가깝다.</p>\n<p>대표적인 비교점은 아무래도 모듈을 동적, 그리고 동기적으로 불러올 수 있는 동작이 불러오는 결과일 것이다. <code class=\"language-text\">ESM</code>에 익숙한 개발자라면\n비교적 유연해 보일 수 있지만 브라우저를 중심으로 하는 자바스크립트 생태계에서 기준이 되기란 쉽지 않았는데, 대표적인 이유로 트리쉐이킹 문제를 꼽는다.</p>\n<p><code class=\"language-text\">CommonJS</code>는 동적으로 모듈을 불러올 수 있는 동작 때문에 런타임에 들어서야 모듈 평가가 이루어지는 <code class=\"language-text\">CommonJS</code> 모듈 시스템 구조상 참조되지 않은\n대상을 제거해도 되는지에 대한 가늠하기 어렵다.</p>\n<p>그러나 일체 불가능한 것은 아니다. 번들러 차원에서 <code class=\"language-text\">CommonJS</code>에서 트리쉐이킹이 가능하도록 플러그인들이나 기능을 제공하는 경우도 있다. 가령 <code class=\"language-text\">webpack</code>의 경우\n<a href=\"https://github.com/indutny/webpack-common-shake\">webpack-common-shake</a>를 통해 일정 부분 제거가 가능하다.</p>\n<p>하지만 이후 살펴볼 <code class=\"language-text\">ESM</code> 처럼 정적 분석이 가능한 모듈 시스템 구조보다는 트리쉐이킹 수행에 어려움이 있으며,\n다음과 같은 제약 사항들을 포함하고 있어 <code class=\"language-text\">CommonJS</code> 모듈 시스템의 특징적인 구현에 제동이 걸리게 된다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">// Dynamic exports\nexports[Math.random()] = ...\n// Overriding imported vars\nvar a = require(&#39;./a&#39;);\na.lib;\na = require(&#39;./b&#39;)\n// Using require in unknown way\nconsole.log(require(&#39;./lib&#39;))\n// Destructuring require dynamically\n{ [prop]: name } = require(&#39;./a&#39;)\n// Dynamic import\nvar fn = require(&#39;./lib&#39;)[Math.random()]</code>\n        </deckgo-highlight-code>\n<h2 id=\"nodejs의-esm-지원\" style=\"position:relative;\"><a href=\"#nodejs%EC%9D%98-esm-%EC%A7%80%EC%9B%90\" aria-label=\"nodejs의 esm 지원 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>node.js의 ESM 지원</h2>\n<p><code class=\"language-text\">CommonJS</code>를 채택한 <code class=\"language-text\">node.js</code>는 <code class=\"language-text\">--experimental-module</code> 플래그를 통해 실험적으로 <code class=\"language-text\">ESM</code>을 지원하다가 <a href=\"https://nodejs.org/api/esm.html#modules-ecmascript-modules\">버전 13.2.0부터 안정적으로 지원</a>\n하기 시작했다. 위에서 다뤘던 것처럼 <code class=\"language-text\">CommonJS</code>는 ECMA 표준의 지원 없이 독립적으로 개발되었고, 태생적으로 브라우저 중심의 생태계에 적합하지 않을 수 있다는 이야기들이 반영된 것이다.</p>\n<p>그렇다면 다소 아쉬운 점을 들어내는 <code class=\"language-text\">CommonJS</code>에서 <code class=\"language-text\">ESM</code>으로 급진적인 전환이 가능했을까. 사실 아직까지도 과도기이며, 최근 많은 라이브러리들이 <a href=\"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c\">순수 <code class=\"language-text\">ESM</code>만을\n지원하려는 움직임</a>도 보이고 있지만,\n이미 <code class=\"language-text\">CommonJS</code> 기반의 라이브러리들을 사용하고 있는 많은 사용자를 감안한다면 쉽게 선택할 수 있는 일이 아닌 것은 분명하다.\n그렇다면 현재 라이브러리들은 어떻게 대처하고 있을까. 이 내용은 우리가 익숙하게 사용하고 있는 <code class=\"language-text\">ESM</code>를 먼저 살펴보고 알아보자.</p>\n<h2 id=\"esm-ecmascript-modules\" style=\"position:relative;\"><a href=\"#esm-ecmascript-modules\" aria-label=\"esm ecmascript modules permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ESM (ECMAScript Modules)</h2>\n<p><code class=\"language-text\">ESM</code>은 자바스크립트 표준을 다루는 ECMAScript 발표한 표준 모듈 시스템이다. 이는 자바스크립트 자체적으로 모듈에 대한 문법을 지원하게 된 것을 의미한다.\n모던 브라우저 상에서 동작하는 어플리케이션을 개발하고 있다면, 가장 익숙한 모듈 시스템일 것이다. 기본적인 모듈 사용 방식은 건너뛰고 동작 방식과 특징들을\n살펴보자.</p>\n<h3 id=\"동작-방식\" style=\"position:relative;\"><a href=\"#%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>동작 방식</h3>\n<p><code class=\"language-text\">ESM</code>은 구성, 인스턴스화, 평가 세 단계로 동작한다. 가장 먼저 <strong>구성 단계</strong>에서는 번들러의 진입점과 같이 모듈 그래프의 시작점이 되는 파일에서부터 시작해 <code class=\"language-text\">import</code>\n구문을 통해 의존적으로 불러오고 있는 모듈들의 종속성 트리를 생성한다.</p>\n<p>여기서 <code class=\"language-text\">import</code>가 가리키고 있는 파일 자체를 브라우저가 사용할 수 없기 때문에 이를 <a href=\"https://262.ecma-international.org/6.0/#sec-source-text-module-records\">모듈 레코드(Module Record)</a>\n로 변환한다. 이때 모듈 간 관계를 구조화해야 하기 때문에 모든 파일을 구문 분석한다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 57.333333333333336%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRlwAAABXRUJQVlA4IFAAAAAwAwCdASoUAAsAPtFUo0uoJKMhsAgBABoJZQAAex/8Z3iAAP7w4wy+2nKQxn0/9IAGvRFz0zcktJQI4OWBtY6URzqArNfGGZ2SDAUgSlgAAA=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"모듈 레코드\"\n        title=\"\"\n        src=\"/static/295d985ffa55da2db2adca9a65fb2aee/8b983/05_module_record-768x441.webp\"\n        srcset=\"/static/295d985ffa55da2db2adca9a65fb2aee/c85cb/05_module_record-768x441.webp 300w,\n/static/295d985ffa55da2db2adca9a65fb2aee/e88ff/05_module_record-768x441.webp 600w,\n/static/295d985ffa55da2db2adca9a65fb2aee/8b983/05_module_record-768x441.webp 768w\"\n        sizes=\"(max-width: 768px) 100vw, 768px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><a href=\"https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/\">이미지 출처</a></p>\n<p>다음으로 모듈 레코드를 코드와 상태를 담은 <strong>모듈 인스턴스로 변환</strong>한다. <code class=\"language-text\">import</code>된 모든 값을 할당할 메모리 공간을 찾고, 해당 모듈을 불러온 사용처의 <code class=\"language-text\">import</code>\n와 해당 모듈을 내보낸 <code class=\"language-text\">export</code>가 모듈의 실제 메모리를 동일하게 가리키도록 한다. 이 과정을 마치면 진입점으로부터 시작되는 모든 모듈들에 대한 인스턴스 그래프를 얻게 된다.</p>\n<p>마지막으로 <strong>코드를 평가</strong>한다. 위에서 언급한 상태는 특정 시점의 변수의 실제 값들을 의미하는데, 코드를 평가함으로써 해당 시점에 얻어낼 수 있는 실제 값들을\n메모리에 채워 넣는다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 36.66666666666667%; position: relative; bottom: 0; left: 0; background-image: url('data:image/webp;base64,UklGRlQAAABXRUJQVlA4IEgAAAAwAwCdASoUAAcAPtFWo0uoJKMhsAgBABoJZ2DrAD3k7QHoAP7xxGUl+vXTCT4zbSeePIgNO8o72xsRakfDZjTLvRXzrIYAAAA='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"ESM 모듈 동작 방식\"\n        title=\"\"\n        src=\"/static/4b832e29b8d8d27d620c0bb85af25bbb/8b983/07_3_phases-768x282.webp\"\n        srcset=\"/static/4b832e29b8d8d27d620c0bb85af25bbb/c85cb/07_3_phases-768x282.webp 300w,\n/static/4b832e29b8d8d27d620c0bb85af25bbb/e88ff/07_3_phases-768x282.webp 600w,\n/static/4b832e29b8d8d27d620c0bb85af25bbb/8b983/07_3_phases-768x282.webp 768w\"\n        sizes=\"(max-width: 768px) 100vw, 768px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><a href=\"https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/\">이미지 출처</a></p>\n<p>위와 같은 세 과정은 각각 개별적으로, 비동기적으로 수행될 수 있다. 더불어 위 과정을 선재적으로 진행함에 따라 얻을 수 있는 이점들이 많다.</p>\n<h3 id=\"읽기-전용-실시간-바인딩\" style=\"position:relative;\"><a href=\"#%EC%9D%BD%EA%B8%B0-%EC%A0%84%EC%9A%A9-%EC%8B%A4%EC%8B%9C%EA%B0%84-%EB%B0%94%EC%9D%B8%EB%94%A9\" aria-label=\"읽기 전용 실시간 바인딩 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>읽기 전용 실시간 바인딩</h3>\n<p><code class=\"language-text\">ESM</code>는 <code class=\"language-text\">CommonJS</code>의 정적 바인딩과는 달리 실시간으로 바인딩된다. 이는 모듈을 내보낸 곳에서 변경 사항이 모듈을 불러온 사용처에서도 반영된다는 것이다.</p>\n<p>이는 <code class=\"language-text\">ESM</code>의 구동 방식의 인스턴스화 단계에서 모듈을 내보낸 <code class=\"language-text\">export</code>와 모듈을 불러온 <code class=\"language-text\">import</code>가 모두 모듈의 실제 메모리를 가리키도록 하는 작업이\n수행되기 때문에 가능한 일이다. 즉 복사본이 아니라 불러온 모듈의 실제 메모리를 참조하여 값을 읽어 사용하는 것이다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">// lib.js\nexport let counter = 3;\nexport function incCounter() {\n  counter++;\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">// main.js\nimport { counter, incCounter } from &#39;./lib&#39;;\n\n// The imported value `counter` is live\nconsole.log(counter); // 3\nincCounter();\nconsole.log(counter); // 4\n\n// The imported value can’t be changed\ncounter++; // TypeError</code>\n        </deckgo-highlight-code>\n<p>단, 위에서 <code class=\"language-text\">counter</code> 값을 수정할 때 <code class=\"language-text\">TypeError</code>가 발생하는 것처럼, 내보내는 모듈은 언제든지 해당 값을 변경할 수 있지만, 모듈을\n가져오는 곳에서는 마치 <code class=\"language-text\">const</code>로 선언된 값처럼 변경할 수 없다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 768px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 41%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZElEQVR42oVR7U6EMBDk/V9I30ATo/H8jJfjgOP4KBQOaIG2QMctd0b/qJtMWrrL7OysZwFYe8HlPisFzSuoooRpu3NusZiNgdVnYFnW94nezWwxmAVqWuA5kq+wVLFiHLH0PRYhYKV0GVj6NtRgYBwyYRhagZkyez7iJmhxbBRKaeB144y6NyiEgVQzOkI5zCgInHKcnbA9NvBzgfjjAP94QpA2iAiHgOH2Lcd9LJA4QuLwrt8qPB7FKjnIO2x9hiTmSOOSzgJhVOJhx/GSCOzDAn5YIstqDHWDlMtVhKJ/pZ7RE7y7qENUKbBOoyDk1ClvFRVOqISGoOKnrMdzKrGrNST51WoimEAifhp2Ds91OPXTSujuLY3JSHra6vUMqxGu6YamcPbgsrjfwruikTc0jttQVKvVZEfuDHbghFdS+M76b0L8Qei6OxVuS6wzyEhZ0ujzckih89anJiHZ4nz6j/AT1VxnpbWcbqkAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"읽기 전용 실시간 바인딩\"\n        title=\"\"\n        src=\"/static/00494c0d4e8627e8da139d21fbfeead9/e5715/live-binding.png\"\n        srcset=\"/static/00494c0d4e8627e8da139d21fbfeead9/5a46d/live-binding.png 300w,\n/static/00494c0d4e8627e8da139d21fbfeead9/0a47e/live-binding.png 600w,\n/static/00494c0d4e8627e8da139d21fbfeead9/e5715/live-binding.png 768w\"\n        sizes=\"(max-width: 768px) 100vw, 768px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p><a href=\"https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/\">이미지 출처</a></p>\n<h3 id=\"정적-모듈-구조\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EC%A0%81-%EB%AA%A8%EB%93%88-%EA%B5%AC%EC%A1%B0\" aria-label=\"정적 모듈 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정적 모듈 구조</h3>\n<p><code class=\"language-text\">ESM</code>은 정적 모듈 구조를 가진다. 동적인 모듈 시스템 구조를 가지고 있는 CommonJS는 어떤 모듈을 불러왔고 내보냈는지를 런타임에 파악할 수 있는 반면 ESM은\n정적인 모듈 구조를 가지고 있어 어떤 모듈을 불러왔고 내보냈는지에 대해 컴파일 단계에서 파악할 수 있다. <code class=\"language-text\">import</code>와 <code class=\"language-text\">export</code>를 최상위에서만 사용해야 하는\n이유이기도 하다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">import foo from &#39;./foo&#39;;\n\nif (condition) {\n  import bar from &#39;./bar&#39;; // SyntaxError\n}\n\nfunction exportModule() {\n  export default &#39;baz&#39;; // SyntaxError;\n}\n\nexportModule();</code>\n        </deckgo-highlight-code>\n<p>정적 모듈 구조가 다소 유연성이 떨어지는 것처럼 보이지만 동적 구조 대비 <a href=\"https://exploringjs.com/es6/ch_modules.html#static-module-structure\">다양한 이점</a>\n을 취할 수 있다.</p>\n<h3 id=\"죽은-코드를-제거하고-트리-쉐이킹-가능하다\" style=\"position:relative;\"><a href=\"#%EC%A3%BD%EC%9D%80-%EC%BD%94%EB%93%9C%EB%A5%BC-%EC%A0%9C%EA%B1%B0%ED%95%98%EA%B3%A0-%ED%8A%B8%EB%A6%AC-%EC%89%90%EC%9D%B4%ED%82%B9-%EA%B0%80%EB%8A%A5%ED%95%98%EB%8B%A4\" aria-label=\"죽은 코드를 제거하고 트리 쉐이킹 가능하다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>죽은 코드를 제거하고, 트리 쉐이킹 가능하다</h3>\n<p>ESM은 정적으로 모듈을 평가하여 번들링 과정에서 죽은 코드를 제거할 수 있다. 브라우저에서는 서버사이드와는 달리 웹을 구성하는 모든 모듈을 불러와\n사용해야 하기 때문에 모듈 크기의 최적화가 큰 영향을 끼친다. 만약 정의되었지만 참조되지 않은 함수나 주석/공백 제거와 같은 작업을 수행하여\n번들링을 최소한의 크기로 유지하는 것은 중요한 브라우저 생태계에서 중요하다.</p>\n<p><code class=\"language-text\">webpack</code>의 경우 <a href=\"https://webpack.js.org/configuration/optimization/#optimizationminimize\">optimization.minimize</a>를 <code class=\"language-text\">true</code>로\n설정하여 트리쉐이킹을 진행할 수 있다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">module.exports = {\n  optimization: {\n    minimize: true,\n  },\n};</code>\n        </deckgo-highlight-code>\n<p>현재는 <code class=\"language-text\">webpack5</code>에서 <code class=\"language-text\">ESM</code>을 지원하지만, <code class=\"language-text\">ESM</code> 빌드 결과물을 생성할 수 있었던 <code class=\"language-text\">rollup</code>은 조건부로 로드된 모듈을 고려할 필요 없는\n특징과 <code class=\"language-text\">import</code> 대상과 <code class=\"language-text\">export</code> 대상이 하나의 메모리를 참조하고 있다는 <code class=\"language-text\">ESM</code>의 특징을 살려 모든 모듈들을 동일한 수준으로 끌어올려 트리쉐이킹 판단을 용이하게\n진행할 수 있게 된다.</p>\n<p>이때 <code class=\"language-text\">rollup</code>은 불필요한 대상들을 제거하는 접근이 아닌 최종 번들 파일에 포함되어야 한다고 판단된 모듈만을 포함시키려는 접근을 제시하고 적용하고 있다.\n아래 <code class=\"language-text\">rollup</code>에서 번들링했을 때의 예시처럼 말이다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">// lib.js\nexport function foo() {}\nexport function bar() {}\n\n// main.js\nimport { foo } from &#39;./lib.js&#39;;\nconsole.log(foo());</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">function foo() {}\n\nconsole.log(foo());</code>\n        </deckgo-highlight-code>\n<h3 id=\"불러오기-검색-속도-향상\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0-%EA%B2%80%EC%83%89-%EC%86%8D%EB%8F%84-%ED%96%A5%EC%83%81\" aria-label=\"불러오기 검색 속도 향상 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불러오기 검색 속도 향상</h3>\n<p>동적으로 불러온 모듈의 속성을 참조한다면, 해당 속성에 대한 조회가 선행되어야 한다. 반면 <code class=\"language-text\">ESM</code>의 경우 <code class=\"language-text\">import</code>된 모듈에 대한 평가가 완료되어 정적으로\n참조 가능해 런타임에서 모듈에 대한 속성 조회가 완료된 상태로 최적화된 참조가 가능하다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">var lib = require(&#39;lib&#39;);\nlib.someFunc(); // property lookup</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">import * as lib from &#39;lib&#39;;\nlib.someFunc(); // statically resolved</code>\n        </deckgo-highlight-code>\n<h2 id=\"nodejs에서-모듈-시스템을-선정하는-방식\" style=\"position:relative;\"><a href=\"#nodejs%EC%97%90%EC%84%9C-%EB%AA%A8%EB%93%88-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EC%84%A0%EC%A0%95%ED%95%98%EB%8A%94-%EB%B0%A9%EC%8B%9D\" aria-label=\"nodejs에서 모듈 시스템을 선정하는 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>node.js에서 모듈 시스템을 선정하는 방식</h2>\n<p><code class=\"language-text\">ESM</code>과 <code class=\"language-text\">CommonJS</code> 모듈 시스템이 함께 지원되는 환경에서 <code class=\"language-text\">node.js</code>는 어떻게 모듈 시스템을 선정할 수 있을까.\n이는 파일 확장자와 <code class=\"language-text\">package.json</code>의 <code class=\"language-text\">type</code> 필드로 모듈 시스템을 명시할 수 있다.</p>\n<p>파일 확장자가 <code class=\"language-text\">.cjs</code> 경우 <code class=\"language-text\">CommonJS</code> 모듈 시스템을, <code class=\"language-text\">.mjs</code>의 경우 <code class=\"language-text\">ESM</code> 모듈 시스템을 사용한다.\n그러나 단순히 <code class=\"language-text\">.js</code>의 확장자를 가지는 경우 가장 가까운 부모의 <code class=\"language-text\">package.json</code>에 명시되어 있는 <code class=\"language-text\">type</code> 필드를 기준으로 모듈 시스템을 선정한다.</p>\n<p>만약 <code class=\"language-text\">type: \"module\"</code>로 명시되어 있는 경우 ESM 모듈 시스템을 사용하고, <code class=\"language-text\">type: \"commonjs\"</code>가 명시되어 있거나 필드가 명시되어 있지 않은 경우\n<code class=\"language-text\">CommonJS</code> 모듈 시스템을 사용하는데, 이미 많은 패키지들이 먼저 사용된 <code class=\"language-text\">CommonJS</code> 모듈 시스템을 따르고 있기 때문이다.</p>\n<deckgo-highlight-code language=\"json\" theme=\"nord\"  >\n          <code slot=\"code\">// package.json\n{\n  &quot;type&quot;: &quot;module&quot;\n}</code>\n        </deckgo-highlight-code>\n<p>타입스크립트 4.7 버전부터 <code class=\"language-text\">tsconfig.json</code>의 <code class=\"language-text\">moduleResolution: \"nodenext\" or \"node16\"</code>일 경우 위 규칙이 동일하게 적용된다.</p>\n<h2 id=\"두-모듈-시스템-지원하기\" style=\"position:relative;\"><a href=\"#%EB%91%90-%EB%AA%A8%EB%93%88-%EC%8B%9C%EC%8A%A4%ED%85%9C-%EC%A7%80%EC%9B%90%ED%95%98%EA%B8%B0\" aria-label=\"두 모듈 시스템 지원하기 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>두 모듈 시스템 지원하기</h2>\n<p>라이브러리를 제작하는 입장이라면 해당 라이브러리를 사용하는 환경에 따라 적절한 모듈 시스템이 적용된 빌드 파일을 제공해 줄 수 있어야 한다.\n이는 결국 각각의 모듈 시스템을 사용한 빌드된 결과물을 제공해 주어야 하는 것이다.</p>\n<h3 id=\"conditional-exports\" style=\"position:relative;\"><a href=\"#conditional-exports\" aria-label=\"conditional exports permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>conditional exports</h3>\n<p><code class=\"language-text\">node.js</code>는 <code class=\"language-text\">CommonJS</code>와 <code class=\"language-text\">ESM</code>을 함께 지원하기 위해 <code class=\"language-text\">exports</code> 기능을 추가했다. 패키지를 사용하는 쪽에서 해당 패키지를 불러올 때 <code class=\"language-text\">CommonJS</code>의\n<code class=\"language-text\">require</code> 혹은 <code class=\"language-text\">ESM</code>의 <code class=\"language-text\">import</code> 중 어느 구문을 통해 모듈을 불러왔는지에 따라 해당 패키지의 번들을 조건적으로 제공할 수 있게 된다.</p>\n<deckgo-highlight-code language=\"json\" theme=\"nord\"  >\n          <code slot=\"code\">// package.json\n{\n  &quot;name&quot;: &quot;my-package&quot;,\n  &quot;exports&quot;: {\n    &quot;.&quot;: {\n      &quot;import&quot;: &quot;./dist/lib.mjs&quot;,\n      &quot;require&quot;: &quot;./dist/lib.cjs&quot;\n    }\n  }\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  >\n          <code slot=\"code\">// commonjs, ./dist/lib.cjs 를 불러온다.\nconst myPackage = require(&#39;my-package&#39;);\n\n// esm, ./dist/lib.mjs\nimport myPackage from &#39;my-package&#39;;</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://webpack.kr/guides/ecma-script-modules/#flagging-modules-as-esm\">webpack5</a>에서는\n<code class=\"language-text\">package.json</code>에 <code class=\"language-text\">type: \"module\"</code>가 명시되어 있거나, 모듈 파일의 확장자를 <code class=\"language-text\">.mjs</code>로 설정하여 <code class=\"language-text\">ESM</code> 모듈 시스템을 사용하는 번들을\n생성해낼 수 있다. 또 다른 예시로 <code class=\"language-text\">vite</code>는 <a href=\"https://vitejs.dev/config/build-options.html#build-lib\">build.lib.formats</a>\n설정을 통해 명시한 각각의 모듈 시스템에 대한 번들을 생성해낸다.</p>\n<deckgo-highlight-code language=\"js\" theme=\"nord\"  highlight-lines=\"1 7\">\n          <code slot=\"code\">// vite.config.js\nbuild: {\n  lib: {\n    entry: path.resolve(__dirname, &#39;src/main.ts&#39;),\n    name: pascalCase(pkg.name.split(&#39;/&#39;).pop() ?? &#39;&#39;),\n    fileName: &#39;lib&#39;,\n    formats: [&#39;cjs&#39;, &#39;es&#39;, &#39;umd&#39;]\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>위에서 언급한 <a href=\"#conditional-exports\">conditional exports</a>는 동일한 불러오기 경로에 대해 특정 조건에 따라 다른 모듈을 제공할 수 있었다면,\n라이브러리가 사용되는 환경에 따라 이를 제공할 수도 있다.</p>\n<deckgo-highlight-code language=\"json\" theme=\"nord\"  >\n          <code slot=\"code\">// package.json\n{\n  // 패키지를 사용할 때 진입되는 경로\n  &quot;main&quot;: &quot;./dist/lib.js&quot;,\n  // ES6가 호환되는 환경에서의 진입 경로\n  &quot;module&quot;: &quot;./dist/lib.mjs&quot;,\n  // 클라이언트 사이드 (브라우저) 환경에서 사용할 때 진입 경로\n  &quot;browser&quot;: &quot;./dist/lib.js&quot;\n}</code>\n        </deckgo-highlight-code>\n<p>여기서 <code class=\"language-text\">main</code>은 <code class=\"language-text\">node.js</code> 10 버전 이하에서 사용되는 필드이며, 11 이상에서는 <code class=\"language-text\">main</code>과 <code class=\"language-text\">exports</code>가 함께 명시되어 있는 경우 <code class=\"language-text\">exports</code>가 먼저 적용된다.</p>\n<h2 id=\"마치면서\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C\" aria-label=\"마치면서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치면서</h2>\n<p>익숙하게 사용 중인 <code class=\"language-text\">typescript</code> 4.7 버전과 <code class=\"language-text\">next12</code>의 <code class=\"language-text\">ESM</code> 공식 지원과, <code class=\"language-text\">jest</code>의 실험적인 기능을 통해 서둘러 <code class=\"language-text\">ESM</code>을 지원하기 시작했다는 레퍼런스들을 보면서\n그 시점에 해당 체인지 로그를 본 나는 업데이트하게 된 배경을 이해하고 있지 못하고 그러려니 했을거다. 지금이라도 두서없이 정리해 본 게 정말 다행이라 생각한다.</p>\n<p>사실 <code class=\"language-text\">CommonJS</code>를 청산할 수 있을까에 대한 의문은 남는다. 라이브러리 메인테이너들이 여전히 건재한 <code class=\"language-text\">CommonJS</code> 생태계를 제쳐두고 기꺼이 <code class=\"language-text\">ESM</code> 도입을 위해\n적극적으로 참여해줄 지, 아니면 크게 문제 없어보이는 두 모듈 시스템이 공존하는 현 상황에 만족할 것인지 나중 일들이 궁금해진다. 지금은 여전히 시끌시끌한 자바스크립트\n생태계 이슈들에 조금씩 공감할 수 있게 된 것 같아 기쁘다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://so-so.dev/web/tree-shaking-module-system/\">Tree Shaking과 Module System</a></li>\n<li><a href=\"https://yceffort.kr/2023/05/what-is-commonjs\">1부) commonjs란 무엇인가?</a></li>\n<li><a href=\"https://yceffort.kr/2023/05/why-esmodule\">3부) 왜 esmodule 이어야 하는가?</a></li>\n<li><a href=\"https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/\">ES modules: A cartoon deep-dive</a></li>\n<li><a href=\"https://exploringjs.com/es6/ch_modules.html#static-module-structure\">exploringjs#static-module-structure</a></li>\n<li><a href=\"https://toss.tech/article/commonjs-esm-exports-field\">CommonJS와 ESM에 모두 대응하는 라이브러리 개발하기:exports field</a></li>\n<li><a href=\"https://velog.io/@yesbb/%EB%AA%A8%EB%93%88-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%98-%EC%97%AD%EC%82%AC-%EA%B7%B8%EB%A6%AC%EA%B3%A0-ESM\">모듈 시스템의 역사, 그리고 ESM</a></li>\n</ul>","frontmatter":{"title":"node.js에서 하나의 모듈 시스템을 사용하는 날이 올까","description":"호환되지 않는 node.js 모듈 시스템들의 불편한 공존을 살펴봅니다.","date":"2023.11.09"}}},"pageContext":{"slug":"/javascript/nodejs-module-system/","previous":{"fields":{"slug":"/development/git-glances-skills-retrospect/"},"frontmatter":{"title":"웹 제품을 만들기 위한 개발 환경과 기술 스택 되짚어보기"}},"next":{"fields":{"slug":"/javascript/timezone/"},"frontmatter":{"title":"자바스크립트와 타임존, 그리고 Temporal"}}}},"staticQueryHashes":["3665086019"],"slicesMap":{}}