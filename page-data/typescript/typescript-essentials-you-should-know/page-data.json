{"componentChunkName":"component---src-templates-blog-post-js","path":"/typescript/typescript-essentials-you-should-know/","result":{"data":{"site":{"siteMetadata":{"title":"Youthfulhps.dev","description":"Blog posted front-end, troubleshooting!","author":"youthfulhps","siteUrl":"https://youthfulhps.dev","thumbnail":"static/banner.png","comment":{"disqusShortName":"youthfulhps","utterances":"youthfulhps/youthfulhps.github.io"},"sponsor":{"buyMeACoffeeId":"youthfulhps"}}},"markdownRemark":{"id":"803efc39-d2d3-510d-ba85-fee64c30bd81","excerpt":"개인적으로 타입스크립트는 실무에서 사용하면서 익히기 시작해서\n약…","html":"<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 864px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 58.00000000000001%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAACfUlEQVR42mWTW09TQRSFz5/yxT+gbz5qjIlIkKggoGIvtOcy054CPb3QgoWWtoaEpEAiIQjSVCsCLdBDW1paFRLDq4lP/oPlnmlRTB9WMpNz5pu199qjGNM6mCVkgIdIYQYfSaP9esSD5oKO6ryOmlBCw0lChT2nojLrwXHcjcOYE+WoA3n/MDbUx1D8YQ4hM+zryk97PyYtBjvJcZE10UgyEsdZiqNJ66bcM9Tpkipdsh9xojA5hrw5AiVAh3sUMTEVYsi4n2LNGJUOW4sc5bgHnyMT2It6yKmGZsqH0wUmHQtoMTjeC5zsOowFdQzeuQVX/300slNopQy8s1TcvnkDQw/uwn4bwVlSR0O4JpVjHuyGnb1AM2xiOmjgS8xLJRmwEzrsNxodZKgkDHyyHOTSg1rKJJAhYadJAwf0/2Fc7QX6LY6dGRXnGY522ocKlSN69pXWAioAnZ4KGOuK43hOQ4mgyvVSOblLhzR8o37t08dV9gJHs155+07Q0QlEAK/AslxaLzIJ3A27/gcy4W7WQCHoBHv2CN4nfZgaGQAf6odr8CFS7iHpWAD/wiSQU1s6rVH+9Y6gIR+KMRXxsQHktOf4EHiJnD5KTkeRdAzCSQFtBMbRyvg7ZV8r+XSh00/lehgWDbO9NIOz4xJ+tav4WdvH0bwPl9vL+P29ilJ+E3bhPc5X4hSYJgHNrlMBFyOkmFdAmj2T0i2ng6hv5nCRX0N7K4fWSgI/tpZwWVzH5nIWHxejaGcCMpSGDIhLUI0m4kSULF6HTJfKTdIT3IvS4FqvcUCDukuDWpqZwKo2jMSrATj67mGb2iDSrxOkTmXWaKwEqELhHcVc+AOgpJcgC5QkDQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"A man who thinks about whether to use any type\"\n        title=\"\"\n        src=\"/static/cae53aa5a9bba8e6c1df878cf26b4f5d/9cab2/thumbnail.png\"\n        srcset=\"/static/cae53aa5a9bba8e6c1df878cf26b4f5d/5a46d/thumbnail.png 300w,\n/static/cae53aa5a9bba8e6c1df878cf26b4f5d/0a47e/thumbnail.png 600w,\n/static/cae53aa5a9bba8e6c1df878cf26b4f5d/9cab2/thumbnail.png 864w\"\n        sizes=\"(max-width: 864px) 100vw, 864px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>개인적으로 타입스크립트는 실무에서 사용하면서 익히기 시작해서\n약 2년 가까이 매일 사용하는 언어가 되었습니다.\n타입스크립트로 시작한 프로젝트도 있었던 반면, 자바스크립트에서\n타입스크립트로 마이그레이션해야 하는 프로젝트들도 있었는데요.</p>\n<p>타입스크립트는 단순히 ‘자바스크립트에 타입을 부여한 언어’ 라고 생각할 수 있지만,\n최근 몇 개월동안 어설프게 시작한 타입스크립트를 다시 공부하면서\n‘자바스크립트에 타입을 명시한다고 해서 타입스크립트를\n사용할 줄 안다’ 라고 치환될 수 없음을 느꼈고,\n주로 <a href=\"https://effectivetypescript.com/\">이펙티브 타입스크립트</a>\n를 <a href=\"https://github.com/youthfulhps/TIL/tree/main/typescript\">TIL/typescript</a>\n에 정리하고, <a href=\"https://github.com/youthfulhps/type-challenges\">타입 챌린지</a>\n도 도전해보며 타입스크립트, 그리고 자바스크립트와의 관계를\n깊게 이해하기 위해 노력하고 있습니다.</p>\n<p>이 글의 목적은 이펙티브 타입스크립트와 그 외 타입스크립트에\n대한 좋은 글들을 모아 <strong>실무에서 적용할 수 있는 마인드 셋을\n갖추기 위함</strong>이며, 지속적으로 업데이트할 예정입니다.</p>\n<h2 id=\"1-타입스크립트는-자바스크립트의-상위-집합이다\" style=\"position:relative;\"><a href=\"#1-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EC%9D%98-%EC%83%81%EC%9C%84-%EC%A7%91%ED%95%A9%EC%9D%B4%EB%8B%A4\" aria-label=\"1 타입스크립트는 자바스크립트의 상위 집합이다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. 타입스크립트는 자바스크립트의 상위 집합이다</h2>\n<p>타입스크립트와 자바스크립트의 관계를 설명할 때 자주 등장하는\n이야기입니다. 집합 개념으로 표현한 것은 이 둘의 관계를\n직관적으로 이해하는 데 큰 도움이 됩니다.</p>\n<p>간단하게 증명해보자면, 타입을 명시하는 문법을 가진\n타입스크립트는 타입을 명시하는 문법을 가지고 있기 때문에\n자바스크립트 런타임에서는 오류로 출력하지만, 반대로\njs 파일을 ts 파일로 변경해도 문제가 없습니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">function sayHello(who: string) {\n  console.log(&#39;Hello&#39;, who);\n}\n\n//SyntaxError: Unexpected token : ,in node</code>\n        </deckgo-highlight-code>\n<p>타입스크립트의 영역이 자바스크립트의 상위 집합인 특성은\n자바스크립트 코드를 타입스크립트로 점진적으로 마이그레이션하는 데\n큰 도움이 됩니다.</p>\n<h2 id=\"2-코드-생성과-타입-체크는-독립적이다\" style=\"position:relative;\"><a href=\"#2-%EC%BD%94%EB%93%9C-%EC%83%9D%EC%84%B1%EA%B3%BC-%ED%83%80%EC%9E%85-%EC%B2%B4%ED%81%AC%EB%8A%94-%EB%8F%85%EB%A6%BD%EC%A0%81%EC%9D%B4%EB%8B%A4\" aria-label=\"2 코드 생성과 타입 체크는 독립적이다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. 코드 생성과 타입 체크는 독립적이다</h2>\n<p>타입스크립트 컴파일러는 최신 자바스크립트 / 타입스크립트를\n브라우저에서 동작할 수 있도록 구 버전의 자바스크립트로\n트랜스파일하고, 코드의 타입 오류를 체크하는 두 가지 역할을 합니다.</p>\n<p>여기서, <strong>타입스크립트 컴파일러의 두 가지 역할은 서로 완벽히 독립적입니다.</strong>\n타입스크립트가 자바스크립트로 변환될 때 타입에는 영향을 주지 않으며,\n반대로 타입은 자바스크립트 런타임에 영향을 미치지 않습니다.</p>\n<p>아래의 코드는 타입 체커에게 다음과 같은 지적을 받지만,\n자바스크립트 코드로서 문법적 오류가 없다면, 문제없이 컴파일됩니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// main.ts\nlet greetings = &#39;hello&#39;;\ngreetings = 1234;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"shell\"  >\n          <code slot=\"code\">~$ tsc main.ts\nmain.ts:2:1 -error ... &#39;1234&#39; 형식은 &#39;string&#39; 형식에 할당할 수 없습니다.</code>\n        </deckgo-highlight-code>\n<p>타입 체크에는 문제가 있지만, 컴파일이 수행되는 타입스크립트의\n독립적 기능 수행은 타입 체크의 오류 여부와 상관없이 컴파일된\n결과를 만들어낼 수 있다는 점에서 어플리케이션 운영 단계에서\n도움이 됩니다.</p>\n<h2 id=\"3-런타임에서-타입-구문은-제거-가능-하다\" style=\"position:relative;\"><a href=\"#3-%EB%9F%B0%ED%83%80%EC%9E%84%EC%97%90%EC%84%9C-%ED%83%80%EC%9E%85-%EA%B5%AC%EB%AC%B8%EC%9D%80-%EC%A0%9C%EA%B1%B0-%EA%B0%80%EB%8A%A5-%ED%95%98%EB%8B%A4\" aria-label=\"3 런타임에서 타입 구문은 제거 가능 하다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. 런타임에서 타입 구문은 ‘제거 가능’ 하다</h2>\n<p>타입 구문은 자바스크립트로 컴파일되는 과정에서 모두 제거됩니다.\n즉, <strong>런타임에는 타입 체크가 불가능하며 타입은 런타임에 아무런\n영향을 끼치지 않습니다.</strong></p>\n<p>아래의 코드에서 <code class=\"language-text\">instanceof</code> 체크는 런타임에 일어나지만,\n<code class=\"language-text\">Rectangle</code>은 타입이기 때문에 런타임 시점에 아무런 역할을\n할 수 없습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface Square {\n  width: number;\n}\n\ninterface Rectangle extends Square {\n  height: number;\n}\n\ntype Shape = Square | Rectangle;\n\nfunction calculateArea(shape: Shape) {\n  if (shape instanceof Rectangle) {\n    return shape.width * shape * height;\n  } else {\n    return shape.width * shape.width;\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>런타임에 타입 정보를 유지하고자 한다면 속성의 존재 여부를\n알아보거나, 런타임에 접근 가능한 접근 정보를 명시하는\n‘태그’ 기법을 활용하여야 합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function calculateArea(...) {\n  if (&#39;height&#39; in shape) { ... }\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface Square {\n  kind: &quot;square&quot;;  //tag\n  width: number;\n}\n\ninterface Rectangle extends Square {\n  kind: &quot;rectangle&quot;;  //tag\n  height: number;\n}\n\ntype Shape = Square | Rectangle;\n\nfunction calculateArea(...) {\n  if (shape.kind === &#39;rectangle&#39;) { ... }\n}</code>\n        </deckgo-highlight-code>\n<p>하지만 특이하게도, 타입스크립트 클래스는 자바스크립트 런타임에서\n실제로 동작하는 함수이지만, 타입으로도 사용할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">class Square {\n  constructor(public width: number) {}\n}\n\nclass Rectangle extends Square {\n  constructor(public width: number, public height: number) {\n    super(width);\n  }\n}\n\ntype Shape = Square | Rectangle;\n\nfunction calculateArea(shape: Shape) {\n  if (shape instanceof Rectangle) {\n    return shape.width * shape * height;\n  } else {\n    return shape.width * shape.width;\n  }\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"4-덕-타이핑-기반-자바스크립트를-모델링한다\" style=\"position:relative;\"><a href=\"#4-%EB%8D%95-%ED%83%80%EC%9D%B4%ED%95%91-%EA%B8%B0%EB%B0%98-%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%A5%BC-%EB%AA%A8%EB%8D%B8%EB%A7%81%ED%95%9C%EB%8B%A4\" aria-label=\"4 덕 타이핑 기반 자바스크립트를 모델링한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. 덕 타이핑 기반 자바스크립트를 모델링한다</h2>\n<p>타입스크립트는 <a href=\"https://ko.wikipedia.org/wiki/%EB%8D%95_%ED%83%80%EC%9D%B4%ED%95%91\">덕 타이핑</a> 기반 자바스크립트를\n모델링하기 위해 구조적 타이핑을 사용합니다. 여기서\n덕 타이핑은 동적 타이핑의 한 종류로, 객체의 변수 및 메서드의 집합이\n객체의 타입을 결정하는 것을 말합니다.</p>\n<p>Rectangle과 NamedRectangle 인터페이스는 서로 무관하지만,\ncalculateArea의 매개변수로 NamedRectangle 타입의 객체를\n사용해도 정상적으로 동작하는 것이 타입스크립트가 구조적 타이핑을\n모델링하고 있음을 보여줍니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface Square {\n  width: number;\n}\n\ninterface Rectangle extends Square {\n  height: number;\n}\n\ninterface NamedRectangle {\n  name: string;\n  width: number;\n  height: number;\n}\n\nfunction calculateArea(rectangle: Rectangle) {\n  return rectangle.width * rectangle.height;\n}\n\nconst rectangle: NamedRectangle = {\n  name: &#39;namedRectangle&#39;,\n  width: 3,\n  height: 4,\n};\n\ncalculateArea(rectangle); //OK</code>\n        </deckgo-highlight-code>\n<p>이러한 관점에서 함수를 작성할 때 호출에 사용되는 매개변수의 속성들이\n선언된 타입에 국한되어 있지 않고 ‘열려 (open)’ 있음을 인지해야\n합니다.</p>\n<h2 id=\"5-type-interface의-차이를-이해하고-일관성을-유지해야-한다\" style=\"position:relative;\"><a href=\"#5-type-interface%EC%9D%98-%EC%B0%A8%EC%9D%B4%EB%A5%BC-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B3%A0-%EC%9D%BC%EA%B4%80%EC%84%B1%EC%9D%84-%EC%9C%A0%EC%A7%80%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"5 type interface의 차이를 이해하고 일관성을 유지해야 한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. type, interface의 차이를 이해하고 일관성을 유지해야 한다</h2>\n<p>타입스크립트는 type, interface를 통해 명명된 타입을\n정의할 수 있습니다. 일반적으로 두 방법 모두 사용가능하지만,\n그 차이점을 이해하고 사용의 일관성을 유지하도록 노력해야 합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type TState = {\n  name: string;\n  age: number;\n};\n\ntype IState = {\n  name: string;\n  age: number;\n};</code>\n        </deckgo-highlight-code>\n<p>type과 interface 모두 추가적인 속성을 할당하면 동일한\n오류가 발생합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">const foo: TState = {\n  name: &#39;foo&#39;,\n  age: 29,\n  organization: &#39;fastfive&#39;,\n  // ~~~~ Type ... is not assignable to type &#39;TState&#39;\n  //      Object literal may only specify known properties, and\n  //     &#39;organization&#39; does not exist in type &#39;TState&#39;\n};\n\ntype TDict = { [key: string]: string };\ninterface IDict {\n  [key: string]: string;\n}</code>\n        </deckgo-highlight-code>\n<p>두 방법 모두 인덱스 시그니처, 함수 타입, 제너릭이 가능합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">//index signature\ntype TDict = { [key: string]: string };\ninterface IDict {\n  [key: string]: string;\n}\n\n//function type\ntype TFn = (x: number) =&gt; string;\ninterface IFn {\n  (x: number): string;\n}\n\n//generic\ntype TPair&lt;T&gt; = {\n  first: T;\n  second: T;\n};\ninterface IPair&lt;T&gt; {\n  first: T;\n  second: T;\n}</code>\n        </deckgo-highlight-code>\n<p>두 방법 모두 클래스를 구현할 때 사용할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">class StateT implements TState {\n  name: string = &#39;&#39;;\n  capital: string = &#39;&#39;;\n}\nclass StateI implements IState {\n  name: string = &#39;&#39;;\n  capital: string = &#39;&#39;;\n}</code>\n        </deckgo-highlight-code>\n<p>일반적으로 타입과 인터페이스는 서로 확장할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface IStateWithPop extends TState {\n  population: number;\n}\ntype TStateWithPop = IState &amp; { population: number };</code>\n        </deckgo-highlight-code>\n<p>대표적인 공통점이 있는 반면 차이점도 존재하는데,\n유니온 타입은 있지만 유니온 인터페이스라는 개념은 없습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type AorB = &#39;a&#39; | &#39;b&#39;;</code>\n        </deckgo-highlight-code>\n<p>‘일반적으로’ 타입과 인터페이스는 서로 확장 가능하다는 것은\n인터페이스가 유니온 타입을 확장할 수 없음을 담고 있습니다.\n또한, 인터페이스는 복잡한 타입 (유니온 타입, 원시값,\n템플릿 리터럴, 튜플 등) 을 확장하지 못해\n흔히 type은 interface 보다 쓰임새가 많습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type AorB = &#39;A&#39; | &#39;B&#39;;\ntype Input = {\n  /* ... */\n};\ntype Output = {\n  /* ... */\n};\n\ninterface VariableMap {\n  [name: string]: Input | Output;\n}\n\ntype NamedVariable = (Input | Output) &amp; { name: string };</code>\n        </deckgo-highlight-code>\n<p>type은 튜플과 배열 타입도 간결하게 표현할 수 있습니다.\n물론 interface로도 표현이 가능하지만, 튜플에서\n사용할 수 있는 concat과 같은 메서드를 사용할 수 없기 때문에\n튜플은 type을 통해 구현하는 것이 낫습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type Pair = [number, number];\ntype StringList = string[];\ntype NamedNums = [string, ...number[]];</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface ITuple {\n  0: string;\n  1: number;\n}\n\nconst foo: ITuple = [&#39;0&#39;, 1];\n\nfoo.concat();\n// Property &#39;concat&#39; does not exist on type &#39;ITuple&#39;.(2339)</code>\n        </deckgo-highlight-code>\n<p>반면 인터페이스는 속성을 확장하는 ‘선언 병합’\n을 통해 보강이 가능합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface IState {\n  name: string;\n  age: number;\n}\ninterface IState {\n  organization: string;\n}\nconst foo: IState = {\n  name: &#39;foo&#39;,\n  age: 29,\n  organization: &#39;fastfive&#39;,\n}; // OK</code>\n        </deckgo-highlight-code>\n<p>선언 병합은 주로 타입 선언 파일에서 사용됩니다.\n예를 들어, <em>lib.es5.d.ts</em> 에 선언되어 있는 Array 인터페이스가\n<em>lib.es2015.d.ts</em> 에 선언된 인터페이스를 병합하여\n보강될 수 있도록 하기 위함입니다. 결과적으로\n각 선언이 병합되어 전체 메서드를 가지는 하나의\nArray 타입을 얻게 됩니다.</p>\n<p>결론적으로, 복잡한 타입이라면 타입 별칭을 사용합니다. 그러나\n두 가지 방법으로 모두 표현할 수 있다면 일관성과 보강의 관점에서\n고려해봐야 합니다. 또한 합류하게 된 프로젝트의 코드 베이스의\n일관성을 지키기 위해 선택되어도 좋습니다.</p>\n<h2 id=\"6-any-타입은-타입-시스템을-무력화-시킨다\" style=\"position:relative;\"><a href=\"#6-any-%ED%83%80%EC%9E%85%EC%9D%80-%ED%83%80%EC%9E%85-%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%9D%84-%EB%AC%B4%EB%A0%A5%ED%99%94-%EC%8B%9C%ED%82%A8%EB%8B%A4\" aria-label=\"6 any 타입은 타입 시스템을 무력화 시킨다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>6. any 타입은 타입 시스템을 무력화 시킨다</h2>\n<p>any 타입은 점진적이며 선택적인 타입스크립트의 특성을 위한\n핵심 타입이지만, 타입 안정성이 없으며 설계를 감추고\n언어 서비스 또한 제공받지 못하게 만드는 강력한 힘을 가지고 있고,\n자바스크립트에서 표현할 수 있는 모든 값을 아우르는 매우\n큰 범위의 타입입니다.</p>\n<p>반대로 말하면, <strong>any는 더 구체적인 타입으로 대체할 수 있는\n가능성 또한 높습니다.</strong> 가령, 함수의 매개변수가 객체이긴 하지만\n값을 알 수 없다면 인덱스 시그니처를 사용하거나, 열거가\n가능한 객체임을 표현할 수 있습니다.</p>\n<deckgo-highlight-code language=\"yaml\"  >\n          <code slot=\"code\">any -&gt; {[key: string]: any};\nany -&gt; any[];</code>\n        </deckgo-highlight-code>\n<p>부득이하게 any를 사용해야 한다면, any 타입의 영향력이\n퍼져나가지 않도록 주의해야 합니다. 아래의 코드처럼\n<code class=\"language-text\">expressionReturningFoo</code>의 반환값을 <code class=\"language-text\">processBar</code> 의 매개변수로\n전달하기 위해 any를 사용한다면, any로 명시하는 것 보다는\n차라리 f2 처럼 사용처에서 단언하여 사용하는 것이 낫습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface Foo {\n  foo: string;\n}\ninterface Bar {\n  bar: string;\n}\ndeclare function expressionReturningFoo(): Foo;\n\nfunction processBar(b: Bar) {\n  /* ... */\n}\n\n//// Don&#39;t do this\nfunction f1() {\n  const x: any = expressionReturningFoo();\n  processBar(x);\n}\n\n// Prefer this\nfunction f2() {\n  const x = expressionReturningFoo();\n  processBar(x as any);\n}</code>\n        </deckgo-highlight-code>\n<p>f1에서 x 타입은 <code class=\"language-text\">processBar</code> 호출 이후에도 여전히 any 타입인\n반면, f2는 사용처 영역에서만 any 타입으로 단언되어 호출 이후\nx 타입은 <code class=\"language-text\">Foo</code> 가 됩니다.</p>\n<p>만약 f1이 x를 반환하는 구조의 함수라면, any 타입의 영향력은\n함수 내부 뿐만 아니라 외부까지 퍼져나가게 되기 때문에\nany 타입의 적용 범위를 좁게 제한해야 합니다.</p>\n<h2 id=\"7-타입스크립트-기본형-타입과-객체-래퍼-타입은-다르다\" style=\"position:relative;\"><a href=\"#7-%ED%83%80%EC%9E%85%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%EA%B8%B0%EB%B3%B8%ED%98%95-%ED%83%80%EC%9E%85%EA%B3%BC-%EA%B0%9D%EC%B2%B4-%EB%9E%98%ED%8D%BC-%ED%83%80%EC%9E%85%EC%9D%80-%EB%8B%A4%EB%A5%B4%EB%8B%A4\" aria-label=\"7 타입스크립트 기본형 타입과 객체 래퍼 타입은 다르다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7. 타입스크립트 기본형 타입과 객체 래퍼 타입은 다르다</h2>\n<p>자바스크립트는 여섯 가지의 원시 타입(number, string, boolean, undefined, null, Symbol)이 있습니다. 기본형들은\n불변이고 메서드를 가지고 있지 않다는 점에서 객체와 구분됩니다.</p>\n<p>하지만 기본형인 string은 메서드가 호출이 되어 마치 메서드를\n가지고 있는 것 처럼 보이지만, string의 메서드가 아닙니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">&#39;string&#39;.charAt(3); //&quot;i&quot;</code>\n        </deckgo-highlight-code>\n<p>자바스크립트는 기본형과 객체 타입을 서로 자유롭게 변환하여\n기본형에서 charAt에 접근할 때, 자바스크립트는 <strong>기본형을\nString 객체로 래핑하고 메서드를 호출하고 래핑한 객체를\n버립니다.</strong> 이러한 동작으로 아래의 코드처럼 혼란을 가져오기도 합니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const foo = &#39;foo&#39;;\nfoo.bar = &#39;hi&#39;;\nconsole.log(foo.bar); //undefined</code>\n        </deckgo-highlight-code>\n<p>타입스크립트는 이러한 자바스크립트 동작을 위해\n기본형 타입과 객체 래퍼 타입을 구분지어 모델링합니다.\n즉, 기본형 타입과 객체 래퍼 타입은 다릅니다.</p>\n<p>하지만 string을 String으로 잘못 타이핑하기 쉽고, 실수를\n하더라도 아래의 코드처럼 잘 동작하는 것처럼 보일 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function getStringLength(foo: String) {\n  return foo.length;\n}\n\ngetStringLen(&#39;hello&#39;); // OK\ngetStringLen(new String(&#39;hello&#39;)); // OK</code>\n        </deckgo-highlight-code>\n<p>그러나, string은 String에 할당할 수 있지만, String은\nstring에 할당할 수 없습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function isSubString(subString: String) {\n  return &#39;hello&#39;.includes(subString);\n  //Argument of type &#39;String&#39; is not assignable to parameter of type &#39;string&#39;.\n}</code>\n        </deckgo-highlight-code>\n<p>타입스크립트가 제공하는 타입 선언은 전부 기본형 타입으로\n되어 있기 때문에 기본형 타입과 객체 래퍼 타입을\n혼동해서는 안되며, 기본형 타입을 사용해야 합니다.</p>\n<h2 id=\"8-잉여-속성-체크와-할당-가능-검사는-별도-과정이다\" style=\"position:relative;\"><a href=\"#8-%EC%9E%89%EC%97%AC-%EC%86%8D%EC%84%B1-%EC%B2%B4%ED%81%AC%EC%99%80-%ED%95%A0%EB%8B%B9-%EA%B0%80%EB%8A%A5-%EA%B2%80%EC%82%AC%EB%8A%94-%EB%B3%84%EB%8F%84-%EA%B3%BC%EC%A0%95%EC%9D%B4%EB%8B%A4\" aria-label=\"8 잉여 속성 체크와 할당 가능 검사는 별도 과정이다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>8. ‘잉여 속성 체크’와 ‘할당 가능 검사’는 별도 과정이다</h2>\n<p>타입이 명시되어 있는 변수에 객체 리터럴을 할당한다면\n타입스크립트는 해당 타입의 속성이 있는 지, 그리고\n‘그 외의 속성은 없는지’ 확인하는 과정을 거칩니다.\n타입이 명시되어 있는 변수에 명명된 속성의 매개변수 외의\n속성을 할당하려 한다면 오류가 발생합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface Room {\n  numDoors: number;\n  ceilingHeightFt: number;\n}\nconst r: Room = {\n  numDoors: 1,\n  ceilingHeightFt: 10,\n  elephant: &#39;present&#39;,\n  // ~~~~ Object literal may only specify known properties,\n  //      and &#39;elephant&#39; does not exist in type &#39;Room&#39;\n};</code>\n        </deckgo-highlight-code>\n<p>하지만, 구조적 타이핑 관점으로 생각해보면\nr은 구조적으로 Room 타입에 해당하는 속성을 모두\n가지고 있기 때문에 오류가 발생하지 않아야 합니다.</p>\n<p>다른 예시로, 임시 변수를 도입하여 Room 타입에 할당한다면\n오류가 발생하지 않습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface Room {\n  numDoors: number;\n  ceilingHeightFt: number;\n}\nconst obj = {\n  numDoors: 1,\n  ceilingHeightFt: 10,\n  elephant: &#39;present&#39;,\n};\nconst r: Room = obj; // OK</code>\n        </deckgo-highlight-code>\n<p>타입스크립트는 <strong>타입 시스템의 구조적 본질을 해치지 않으면서,\n알 수 없는 객체 리터럴의 속성을 허용하지 않도록 하여\n구조적 타입 시스템에서 발생할 수 있는 중요한 오류를 잡을 수\n있도록 조건적으로 ‘잉여 속성 체크’를 진행합니다.</strong></p>\n<p>두 예제에 대입하여 생각해보면, 첫번 째 명명된 타입에 객체의 속성을 할당하는 경우\n구조적 시스템 관점에서 오류를 잡기 위해 ‘잉여 속성 체크’ 가 수행되었지만,\n두 번째 예시의 경우 조건에 따라 ‘잉여 속성 체크’가 수행되지 않았습니다.</p>\n<p>‘잉여 속성 체크’는 구조적 타이핑 시스템에서 허용되는\n속성 이름의 오타 같은 실수를 잡아내고, 선택적 필드를\n포함하는 타입에 특히 유용하지만, 적용 범위도 매우 제한적이고\n오직 객체 리터럴에서만 수행합니다.</p>\n<p>즉, ‘할당 가능 검사’와 조건적으로 동작하는 ‘잉여 속성 체크’는\n별도의 과정이라는 것을 인지하고 있어야 합니다.</p>\n<h2 id=\"9-타입-선언도-dry-원칙을-준수해야-한다\" style=\"position:relative;\"><a href=\"#9-%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8%EB%8F%84-dry-%EC%9B%90%EC%B9%99%EC%9D%84-%EC%A4%80%EC%88%98%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"9 타입 선언도 dry 원칙을 준수해야 한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>9. 타입 선언도 DRY 원칙을 준수해야 한다</h2>\n<p>코드에서 반복되고 공유된 패턴을 제거하여 DRY(don’t repeat yourself)\n원칙을 준수하려고 노력합니다. 반면 타입 중복은 코드에 비해\n흔한 일입니다. <strong>타입 간에 매핑하는 방법을 익혀\n타입 정의에서도 DRY 원칙을 준수해야 합니다.</strong></p>\n<p>간단하게 타입의 이름을 붙이는 것으로 반복을 줄일 수 있습니다.\n이는 상수를 정의하고 사용하는 것과 동일합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function getDistance(a: { x: number; y: number }, b: { x: number; y: number }) {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}\n\n=&gt;\n\ninterface Point2D {\n  x: number;\n  y: number;\n}\n\nfunction getDistance(a: Point2D, b: Point2D) {\n  return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));\n}</code>\n        </deckgo-highlight-code>\n<p>타입 시그니처가 동일하다면, 시그니처 또한 명명된 타입으로 정의하여\n공유할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type HTTPFunction = (url: string, opts: Options) =&gt; Promise&lt;Response&gt;;\n\nconst get: HTTPFunction = (url, options) =&gt; { ... }\nconst post: HTTPFunction = (url, options) =&gt; { ... }</code>\n        </deckgo-highlight-code>\n<p>이미 존재하는 인터페이스를 확장해서 반복을 제거할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface Person {\n  firstName: string;\n  lastName: string;\n}\n\ninterface PersonWithBirthDate extends Person {\n  birth?: Date;\n}\n\ntype PersonWithBirthDate = Person &amp; { birth?: Date };</code>\n        </deckgo-highlight-code>\n<p>제너릭 타입을 사용하여 중복을 제거할 수 있습니다.\n타입스크립트는 자주 사용되는 타입 변환을 모델링하여\n<a href=\"https://www.typescriptlang.org/ko/docs/handbook/utility-types.html\">유틸리티 타입</a>\n을 제공합니다.</p>\n<p>가령 다수의 중복된 속성을 가진 두 타입이 있다면,\nState의 속성을 인덱싱하여 topNavState를 정의할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface State {\n  userId: string;\n  pageTitle: string;\n  recentFiles: string[];\n  pageContents: string;\n}\ninterface TopNavState {\n  userId: string;\n  pageTitle: string;\n  recentFiles: string[];\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type TopNavState = {\n  userId: State[&#39;userId&#39;];\n  pageTitle: State[&#39;pageTitle&#39;];\n  recentFiles: State[&#39;recentFiles&#39;];\n};</code>\n        </deckgo-highlight-code>\n<p>하거나, 여전히 남아있는 중복은 매핑된 타입으로\n중복을 제거할 수 있습니다. 이러한 패턴은 중복 제거에\n자주 등장하는 패턴이며 이를 모델링하여 타입스크립트는\n유틸리티 제너릭 타입 <a href=\"https://www.typescriptlang.org/ko/docs/handbook/utility-types.html#picktype-keys\">Pick</a>\n을 제공합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type TopNavState = {\n  [k in &#39;userId&#39; | &#39;pageTitle&#39; | &#39;recentFiles&#39;]: State[k];\n};\n\ntype TopNavState = Pick&lt;State, &#39;userId&#39; | &#39;pageTitle&#39; | &#39;recentFiles&#39;&gt;;</code>\n        </deckgo-highlight-code>\n<p>추가적으로 문자열 리터럴 타입을 기반으로 하는 템플릿 리터럴 타입은\n문자열 리터럴을 통해 새로운 타입을 확장할 수 있는 도구입니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type Ade = &#39;ade&#39;;\ntype LemonAde = `lemon${Ade}`;</code>\n        </deckgo-highlight-code>\n<p>더 복잡하게는 여러 개의 유니온 타입을 확장하여 새로운\n문자열 리터럴 타입을 정의할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type DrinkType = &#39;ade&#39; | &#39;juice&#39;;\ntype Flavor = &#39;lemon&#39; | &#39;graphfruit&#39; | &#39;Strawberry&#39;\n\ntype DrinkMenu = `${Flavor}${DrinkType}`;\n//type DrinkMenu = &quot;lemonade&quot; | &quot;lemonjuice&quot; | &quot;graphfruitade&quot; | &quot;graphfruitjuice&quot; | &quot;Strawberryade&quot; | &quot;Strawberryjuice&quot;</code>\n        </deckgo-highlight-code>\n<p>반복적인 작업을 줄이기 위해 노력하는 만큼, 타입의 공간에서\n또한 반복을 주의해야 합니다.</p>\n<h2 id=\"10-객체의-숫자-키를-허용하고-문자열-키와-다르게-인식한다\" style=\"position:relative;\"><a href=\"#10-%EA%B0%9D%EC%B2%B4%EC%9D%98-%EC%88%AB%EC%9E%90-%ED%82%A4%EB%A5%BC-%ED%97%88%EC%9A%A9%ED%95%98%EA%B3%A0-%EB%AC%B8%EC%9E%90%EC%97%B4-%ED%82%A4%EC%99%80-%EB%8B%A4%EB%A5%B4%EA%B2%8C-%EC%9D%B8%EC%8B%9D%ED%95%9C%EB%8B%A4\" aria-label=\"10 객체의 숫자 키를 허용하고 문자열 키와 다르게 인식한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>10. 객체의 숫자 키를 허용하고 문자열 키와 다르게 인식한다</h2>\n<p>자바스크립트의 객체는 키와 값의 모음입니다. 키는 일반적으로 문자열이고\n값은 어떤 것이든 될 수 있습니다. 여기서, 일반적으로 문자열이라는\n것은 더 복잡한 객체를 키로 사용해도 문제가 되지 않음을 이야기합니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const x = {};\nx[[1, 2, 3]] = 2;\nconsole.log(x); // {&#39;1,2,3&#39;: 2};</code>\n        </deckgo-highlight-code>\n<p>자바스크립트는 ‘해시 기능’ 객체라는 표현이 없기 때문에 만약, <strong>문자열이\n아닌 더 복잡한 객체를 키로 사용하려 한다면, 내부적으로 toString 메서드가\n호출되어 객체를 문자열로 반환하여 키로 사용합니다.</strong></p>\n<p>물론 객체의 키를 숫자로 사용한다면, 문자열로 변환되며\n숫자로 인덱싱하는 배열 또한 객체로서 배열의 모든 숫자 인덱스들은\n문자열로 변환되어 사용됩니다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const x = {\n  1: 2,\n  3: 4,\n};\nconsole.log(x); // {&#39;1&#39;: 2, &#39;3&#39;: 4};\n\nconsole.log(typeof []); // &#39;object&#39;\nconst x = [1, 2, 3];\nconsole.log(x[0]); // 1\nconsole.log(x[&#39;1&#39;]); // 2\nconsole.log(Object.keys(x)); // [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]\nconsole.log(typeof Object.keys(x)[0]); // &#39;string&#39;</code>\n        </deckgo-highlight-code>\n<p>타입스크립트는 <strong>혼란스러운 자바스크립트의 동작을 그대로 모델링하지 않고,\n숫자 키를 허용하며 문자열 키와는 다른 것으로 인식합니다.</strong></p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// lib.es5.d.ts\n\ninterface Array&lt;T&gt; {\n  ...\n  [n: number]: T;\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">const xs = [1, 2, 3];\nconst x0 = xs[0]; // OK\nconst x1 = xs[&#39;1&#39;];\n// ~~~~ Element implicitly has an &#39;any&#39; type\n//      because index expression is not of type &#39;number&#39;</code>\n        </deckgo-highlight-code>\n<p>숫자 키와 문자열 키를 다른 것으로 보는 타입스크립트의 동작은\n타입 체크 단계에서만 유효한 런타임에는 모두 제거되는 가상의 동작입니다.\n그럼에도 타입 체크 단계에서 혼란스러운 자바스크립트의 동작을 오류로\n잡을 수 있어 충분히 유용합니다.</p>\n<h2 id=\"11-인덱스-시그니처는-동적-데이터에만-사용되어야-한다\" style=\"position:relative;\"><a href=\"#11-%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%8B%9C%EA%B7%B8%EB%8B%88%EC%B2%98%EB%8A%94-%EB%8F%99%EC%A0%81-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%90%EB%A7%8C-%EC%82%AC%EC%9A%A9%EB%90%98%EC%96%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"11 인덱스 시그니처는 동적 데이터에만 사용되어야 한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>11. 인덱스 시그니처는 동적 데이터에만 사용되어야 한다</h2>\n<p>CSV 파일을 파싱하여 행과 열을 값으로 매칭하는 객체로\n나타내고 싶은 경우, 객체의 프로퍼티 스펙을 명확히\n알 수 없는 경우에 대해 미리 동적 데이터에 대한 타입을\n지정해야 한다면, 키와 값 쌍의 타입 시그니처인\n인덱스 시그니처를 사용할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type TestScore = { [property: string]: number };\nconst testScore: TestScore = {\n  math: 90,\n  english: 85,\n};</code>\n        </deckgo-highlight-code>\n<p>하지만, <strong>인덱스 시그니처는 동적 데이터에 대한 타입을 지정할 때만\n사용되어야 하며 객체의 가능한 필드가 제한되어 있는 경우라면 인덱스\n시그니처로 모델링하지 말아야 합니다.</strong>\n객체 키의 string 타입은 매우 넓은 값을 포함하는 타입이기 때문에\n잘못된 키를 포함한 모든 문자열 키를 허용하는 위험이 있으며, 객체의\n키값에 대한 자동완성 기능을 제공받지 못하게 됩니다.</p>\n<p>만약 데이터의 키가 한정적이지만 존재 여부를 몰라 인덱스 시그니처를\n사용했다면, 선택적 필드를 사용하거나 유니온 타입으로 모델링할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface Row1 {\n  a: number;\n  b?: number;\n  c?: number;\n  d?: number;\n}\n\ntype Row2 =\n  | { a: number }\n  | { a: number; b: number }\n  | { a: number; b: number; c: number }\n  | { a: number; b: number; c: number; d: number };</code>\n        </deckgo-highlight-code>\n<p>이러한 방법이 번거롭다면, 키 타입에 유연성을 부여하는 <a href=\"https://www.typescriptlang.org/ko/docs/handbook/utility-types.html#recordkeystype\">Record</a>\n제너릭 타입을 사용할 수도 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type Vec3D = Record&lt;&#39;x&#39; | &#39;y&#39; | &#39;z&#39;, number&gt;;\n// Type Vec3D = {\n//   x: number;\n//   y: number;\n//   z: number;\n// }</code>\n        </deckgo-highlight-code>\n<p>키마다 별도의 타입을 사용해야 한다면, 매핑된 타입을 사용할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type ABC = { [k in &#39;x&#39; | &#39;y&#39; | &#39;z&#39;]: k extends &#39;y&#39; ? string : number };\n// Type ABC = {\n//   a: number;\n//   y: string;\n//   c: number;\n// }</code>\n        </deckgo-highlight-code>\n<h2 id=\"12-타입-단언보다는-타입-선언을-하는-것이-낫다\" style=\"position:relative;\"><a href=\"#12-%ED%83%80%EC%9E%85-%EB%8B%A8%EC%96%B8%EB%B3%B4%EB%8B%A4%EB%8A%94-%ED%83%80%EC%9E%85-%EC%84%A0%EC%96%B8%EC%9D%84-%ED%95%98%EB%8A%94-%EA%B2%83%EC%9D%B4-%EB%82%AB%EB%8B%A4\" aria-label=\"12 타입 단언보다는 타입 선언을 하는 것이 낫다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>12. 타입 단언보다는 타입 선언을 하는 것이 낫다</h2>\n<p>변수가 값을 할당하고 타입을 부여하려면 변수에 타입을 선언하여\n그 값이 선언된 타입임을 명시하거나,\n타입을 단언하여 타입스크립트가 추론한 타입이 있더라도\n단언한 타입으로 간주하는 두 방법을 사용합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface Person {\n  name: string;\n}\n\nconst alice: Person = { name: &#39;Alice&#39; };\nconst bob = { name: &#39;Bob&#39; } as Person;</code>\n        </deckgo-highlight-code>\n<p>타입 선언은 할당되는 값이 해당 타입을 만족하는 지\n검사하지만, 타입 단언은 타입을 강제로 단언하여\n타입 체커에게 타입 오류가 있지만, 강제하여 무시하도록 합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">const alice: Person = {\n  name: &#39;Alice&#39;,\n  occupation: &#39;Typescript developer&#39;,\n  // ~~~~~ Object literal may only specify known properties\n  //       and &#39;occupation&#39; does not exist in type &#39;Person&#39;\n};\n\nconst bob = {\n  name: &#39;Bob&#39;,\n  occupation: &#39;Javascript developer&#39;,\n} as Person; //No error</code>\n        </deckgo-highlight-code>\n<p>타입 단언을 사용하면 문제가 해결되는 것처럼 보이지만\n런타임에 문제가 발생할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface Person {\n  name: string;\n}\n\nconst people = [&#39;alice&#39;, &#39;bob&#39;, &#39;jan&#39;].map(name =&gt; ({} as Person));\n//No error</code>\n        </deckgo-highlight-code>\n<p>일반적으로 단언문을 사용하지 않는 것이 변수를 선언하는 것이\n가장 직관적이며 타입 단언은 타입 체커가 추론한 타입보다\n개발자가 판단하는 타입이 더 정확할 때 유효합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">document.querySelector(&#39;#myButton&#39;).addEventListener(&#39;click&#39;, e =&gt; {\n  e.currentTarget; //타입은 EventTarget;\n  const button = e.currentTarget as HTMLButtonElement;\n  button; //타입은 HTMLButtonElement;\n});</code>\n        </deckgo-highlight-code>\n<h2 id=\"13-타입-추론은-잘못된-추론을-할-만큼-구체적으로-수행되지-않는다\" style=\"position:relative;\"><a href=\"#13-%ED%83%80%EC%9E%85-%EC%B6%94%EB%A1%A0%EC%9D%80-%EC%9E%98%EB%AA%BB%EB%90%9C-%EC%B6%94%EB%A1%A0%EC%9D%84-%ED%95%A0-%EB%A7%8C%ED%81%BC-%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9C%BC%EB%A1%9C-%EC%88%98%ED%96%89%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4\" aria-label=\"13 타입 추론은 잘못된 추론을 할 만큼 구체적으로 수행되지 않는다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>13. 타입 추론은 잘못된 추론을 할 만큼 구체적으로 수행되지 않는다</h2>\n<p>타입 체커는 타입이 명시되어 있지 않은 코드에 대해\n할당된 값과 문맥을 통해 가능한 값들의 집합을 유추하여\n타입을 추론하는 기능을 제공하기 때문에 장황하게 타입 구문\n을 넣을 필요가 없습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">let x: number = 12;\nlet x = 12;</code>\n        </deckgo-highlight-code>\n<p>하지만, 타입 추론은 넓은 타입 추론으로 인해 발생할 수 있는\n오류를 잡고자 노력하지만, <strong>명확성과 유연성을 유지하기 위해\n잘못된 추론을 할 만큼 구체적으로 수행하지는 않습니다.</strong></p>\n<p>타입 추론 과정에서 가능한 값들을 포함하는 집합을 찾기 위한\n타입스크립트의 동작을 ‘타입 넓히기’라고 하며, 작성자의 의도가\n명확하지 않은 코드에 대해 명확성과 유연성을 유지하기 위해\n많은 타입의 후보군을 추론하게 됩니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">const mixed = [&#39;x&#39;, 1];</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"yaml\"  >\n          <code slot=\"code\">(&#39;x&#39;, 1)[]\n[&#39;x&#39;, 1]\n[string, number]\nreadonly [string, number]\n(string|number)[]\nreadonly (string|number)[]\n[any, any]\nany[]</code>\n        </deckgo-highlight-code>\n<p><strong>타입 넓히기 과정을 제어하고 더 좁은 타입으로\n추론할 수 있도록 작성자의 의도를 전달해야 합니다.</strong></p>\n<p>함수의 파라미터에 할당하고자 하는 값을 변수로 분리해내면\n타입스크립트는 할당 시점에 타입을 추론하기 때문에 변수\nlanguage는 string으로 추론되어 아래와 같은 에러가 발생합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type Language = &#39;JavaScript&#39; | &#39;TypeScript&#39; | &#39;Python&#39;;\nfunction setLanguage(language: Language) {\n  /* ... */\n}\n\nlet language = &#39;Javascript&#39;;\nsetLanguage(language);\n// ~~~~ Argument of type &#39;string&#39; is not assignable\n//      to parameter of type &#39;Language&#39;</code>\n        </deckgo-highlight-code>\n<p>명시된 타입 구문을 적절히 제공하여 타입 추론의 강도를 제어할\n수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">let language: Language = &#39;Javascript&#39;;\nsetLanguage(language); //OK</code>\n        </deckgo-highlight-code>\n<p>넓혀진 타입을 제한하기 위해 함수 파라미터에 문자열 리터럴\n값을 직접 제공하여 문자열 리터럴 타입으로 추론되도록 유도할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">setLanguage(&#39;Javascript&#39;); //OK</code>\n        </deckgo-highlight-code>\n<p>let을 const로 사용하여 선언하면, 재할당이 없을 것이라는\n의도를 전달하여 더 좁은 타입으로 추론될 수 있도록\n유도할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">let x = &#39;x&#39;; // type is string\nconst y = &#39;y&#39;; // type is &#39;y&#39;</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">const language = &#39;Javascript&#39;;\nsetLanguage(language); //OK</code>\n        </deckgo-highlight-code>\n<p>추가적인 예시로, 객체의 경우 타입스크립트의 넓히기 알고리즘에 의해\n각 요소가 let으로 할당된 것처럼 다루기 때문에 여전히\n구체적으로 타입을 추론할 수 없는 문제가 존재합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type Language = &#39;JavaScript&#39; | &#39;TypeScript&#39; | &#39;Python&#39;;\ninterface GovernedLanguage {\n  language: Language;\n  organization: string;\n}\n\nfunction complain(language: GovernedLanguage) {\n  /* ... */\n}\n\ncomplain({ language: &#39;TypeScript&#39;, organization: &#39;Microsoft&#39; }); // OK\n\nconst ts = {\n  language: &#39;TypeScript&#39;,\n  organization: &#39;Microsoft&#39;,\n};\ncomplain(ts);\n//       ~~ Argument of type &#39;{ language: string; organization: string; }&#39;\n//            is not assignable to parameter of type &#39;GovernedLanguage&#39;\n//          Types of property &#39;language&#39; are incompatible\n//            Type &#39;string&#39; is not assignable to type &#39;Language&#39;</code>\n        </deckgo-highlight-code>\n<p>이럴 때는 ‘상수 문맥(as const)‘을 제공할 수 있습니다. <strong>const는\n단지 값이 가리키는 참조가 변하지 않는 얕은 상수인 반면,\nas const는 그 값이 내부까지 상수라는 사실을 타입스크립트에게\n알려주는 타입 공간의 기법입니다.</strong></p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">const ts = {\n  language: &#39;TypeScript&#39;,\n  organization: &#39;Microsoft&#39;,\n} as const;\n\ncomplain(ts); // OK</code>\n        </deckgo-highlight-code>\n<h2 id=\"14-string-타입보다는-더-구체적인-타입-사용을-고민해야-한다\" style=\"position:relative;\"><a href=\"#14-string-%ED%83%80%EC%9E%85%EB%B3%B4%EB%8B%A4%EB%8A%94-%EB%8D%94-%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8-%ED%83%80%EC%9E%85-%EC%82%AC%EC%9A%A9%EC%9D%84-%EA%B3%A0%EB%AF%BC%ED%95%B4%EC%95%BC-%ED%95%9C%EB%8B%A4\" aria-label=\"14 string 타입보다는 더 구체적인 타입 사용을 고민해야 한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>14. string 타입보다는 더 구체적인 타입 사용을 고민해야 한다</h2>\n<p>string은 매우 넓은 범위의 타입입니다. string은 any와\n마찬가지로 더 좁은 타입으로 대체할 수 있을 가능성이 높습니다.</p>\n<p>Album 인터페이스를 정의할 때, string을 남발한 덕분에\n주석에 타입 정보를 적어두었습니다.\n타입으로 가능한 값을 좁히지 못하여 주석을 사용했다면,\n인터페이스에 문제가 있다는 것을 증명합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">interface Album {\n  artist: string;\n  title: string;\n  releaseDate: string; // YYYY-MM-DD\n  recordingType: string; // E.g., &quot;live&quot; or &quot;studio&quot;\n}</code>\n        </deckgo-highlight-code>\n<p>또한 주석에 명시되어 있는 규칙을 따르지 않아도 타입은\n문제없이 타입 체크를 통과합니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">const kindOfBlue: Album = {\n  artist: &#39;Miles Davis&#39;,\n  title: &#39;Kind of Blue&#39;,\n  releaseDate: &#39;August 17th, 1959&#39;, // Oops!\n  recordingType: &#39;Studio&#39;, // Oops!\n}; // OK</code>\n        </deckgo-highlight-code>\n<p>releaseDate는 Date 객체를 사용하여 날짜 형식으로만\n제한하고, recordingType은 ‘live’ | ‘studio’\n두 가지 값으로 제한된 유니온 타입으로 정의하여 사용하는\n것이 좋습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">type RecordingType = &#39;studio&#39; | &#39;live&#39;;\n\ninterface Album {\n  artist: string;\n  title: string;\n  releaseDate: Date;\n  recordingType: RecordingType;\n}</code>\n        </deckgo-highlight-code>\n<p>타입을 좁혀두면, 타입스크립트가 오류를 더 세밀하게\n체크할 수 있고, 타입을 명시적으로 정의하여 다른 곳으로\n값이 전달되어도 타입 정보를 유지시킬 수 있으며\nkeyof 연산자로 더욱 세밀하게 객체의 속성 체크가\n가능해집니다.</p>\n<p>다른 예시로 객체 배열에서 한 필드의 값만 추출하는 함수를 작성할 때,\n키 값으로 전달할 매개 변수의 타입이 string이기 때문에\n타입 체크에 문제는 없지만, 반환값에 any가 사용되어\nany의 영향력이 퍼져나가게 됩니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function pluck&lt;T&gt;(record: T[], key: string): any[] {\n  return record.map(r =&gt; r[key]);\n  // ~~~~~~ Element implicitly has an &#39;any&#39; type\n  //        because type &#39;{}&#39; has no index signature\n}</code>\n        </deckgo-highlight-code>\n<p>타입 시그니처와 가능한 키 값을 keyof를 통해 제한하여\n사용하거나, 더 좁히기 위해 <code class=\"language-text\">keyof T</code>의 부분 집합으로\n두 번째 제너릭 매개변수로 전달하여 완벽하게 좁혀진 타입으로\nstring을 대체할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function pluck&lt;T&gt;(record: T[], key: keyof T) {\n  return record.map(r =&gt; r[key]);\n}\n\nfunction pluck&lt;T, K extends keyof T&gt;(record: T[], key: K): T[K][] {\n  return record.map(r =&gt; r[key]);\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"15-unknown은-타입시스템에-부합하는-타입이다\" style=\"position:relative;\"><a href=\"#15-unknown%EC%9D%80-%ED%83%80%EC%9E%85%EC%8B%9C%EC%8A%A4%ED%85%9C%EC%97%90-%EB%B6%80%ED%95%A9%ED%95%98%EB%8A%94-%ED%83%80%EC%9E%85%EC%9D%B4%EB%8B%A4\" aria-label=\"15 unknown은 타입시스템에 부합하는 타입이다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>15. unknown은 타입시스템에 부합하는 타입이다</h2>\n<p>unknown은 할당 가능성 관점에서 any와 비교할 수 있습니다.\nany의 강력함은 어떠한 타입이든 any에 할당 가능하며,\nany는 어떠한 타입으로도 할당 가능한 것에서 비롯됩니다.</p>\n<p>함수 반환값 타입을 any로 사용한다면, 함수를 호출한 곳에서\n반환값은 암시적 any 타입이 되어 사용되는 곳마다 문제를\n발생시킵니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function parseYAML(yaml: string): any {\n  // ...\n}\n\ninterface Book {\n  name: string;\n  author: string;\n}\nconst book: Book = parseYAML(`\n  name: Wuthering Heights\n  author: Emily Brontë\n`);\n\nalert(book.title); // No error, alerts &quot;undefined&quot; at runtime\nbook(&#39;read&#39;); // No error, throws &quot;TypeError: book is not a\n// function&quot; at runtime</code>\n        </deckgo-highlight-code>\n<p>대신, unknown 타입을 반환하게 만들면 타입 체크 단계에서\n오류를 발생시키며 적절한 타입으로 반환을 강제하여 사용할 수\n있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function safeParseYAML(yaml: string): unknown {\n  return parseYAML(yaml);\n}\n\nconst book = safeParseYAML(`\n  name: Villette\n  author: Charlotte Brontë\n`) as Book;\nalert(book.title);\n// ~~~~~ Property &#39;title&#39; does not exist on type &#39;Book&#39;\nbook(&#39;read&#39;);\n// ~~~~~~~~~ this expression is not callable</code>\n        </deckgo-highlight-code>\n<p>또한, any를 대신하여 모르는 값이 할당된 변수의 타입을 unknown으로\n명시하였다면 instanceof를 체크하여 unknown에서 원하는 타입으로\n변환할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function processValue(val: unknown) {\n  if (val instanceof Date) {\n    val; // Type is Date\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>정의된 타입 가드를 사용하여 unknown에서 원하는 타입으로 변환할 수 있습니다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">function isBook(val: unknown): val is Book {\n  return (\n    typeof val === &#39;object&#39; &amp;&amp; val !== null &amp;&amp; &#39;name&#39; in val &amp;&amp; &#39;author&#39; in val\n  );\n}\nfunction processValue(val: unknown) {\n  if (isBook(val)) {\n    val; // Type is Book\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>타입을 집합의 관점에서 생각해본다면, any는 모든 집합의\n부분 집합이면서, 동시에 상위 집합인 것이고, 이는\n타입시스템과 상충되는 측면을 가지고 있습니다.\n타입체커는 집합 기반으로 할당 가능성을 판단하기 때문에\nany를 사용하면 타입 체커가 무력화됩니다.</p>\n<p>대신, unknown타입은 any를 대신하여 사용할 수 있는\n타입 시스템에 부합하는 타입입니다. <strong>어떤 타입이든 unknown에\n할당 가능하지만, unknown은 오직 unknown과 any에만\n할당 가능</strong>하기 때문에 타입 시스템의 기능을 제공받으며\n모르는 값에 대해 안전하게 타입 처리를 해줄 수 있습니다.</p>\n<h2 id=\"17-enum은-트리쉐이킹되지-않는다\" style=\"position:relative;\"><a href=\"#17-enum%EC%9D%80-%ED%8A%B8%EB%A6%AC%EC%89%90%EC%9D%B4%ED%82%B9%EB%90%98%EC%A7%80-%EC%95%8A%EB%8A%94%EB%8B%A4\" aria-label=\"17 enum은 트리쉐이킹되지 않는다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>17. enum은 트리쉐이킹되지 않는다</h2>\n<p><a href=\"https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/\">TypeScript enum을 사용하지 않는 게 좋은 이유를 Tree-shaking 관점에서 소개합니다.</a></p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<p>Dan VanderKam. 『<a href=\"https://effectivetypescript.com/\">effective typescript</a>』</p>\n<p><a href=\"https://github.com/danvk/effective-typescript\">danvk/effective-typescript</a></p>\n<p><a href=\"https://toss.tech/article/template-literal-types\">Template Literal Types로 타입 안전하게 코딩하기</a></p>\n<p><a href=\"https://engineering.linecorp.com/ko/blog/typescript-enum-tree-shaking/\">TypeScript enum을 사용하지 않는 게 좋은 이유를 Tree-shaking 관점에서 소개합니다.</a></p>","frontmatter":{"title":"타입스크립트, 글로 배웠습니다만","description":"단순히 자바스크립트에 타입을 부여한 언어라고 생각하고 싶지 않았어요.","date":"June 14, 2022"}}},"pageContext":{"slug":"/typescript/typescript-essentials-you-should-know/","previous":{"fields":{"slug":"/react/react-concurrent-mode-01/"},"frontmatter":{"title":"리엑트 동시성 매커니즘들은 어떻게 구현되어 있을까 - 01"}},"next":{"fields":{"slug":"/react/memoization/"},"frontmatter":{"title":"리엑트 메모이제이션 셀프 코칭"}}}},"staticQueryHashes":["3665086019"],"slicesMap":{}}