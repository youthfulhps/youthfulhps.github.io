{"componentChunkName":"component---src-templates-blog-post-js","path":"/react-native/metro/","result":{"data":{"site":{"siteMetadata":{"title":"Youthfulhps.dev","description":"프론트엔드 주니어 개발자, 트러블슈팅에 대한 고민의 흔적을 기록으로 남기는 것을 좋아합니다.","author":"youthfulhps","siteUrl":"https://youthfulhps.dev","thumbnail":"/banner.png","comment":{"disqusShortName":"youthfulhps","utterances":"youthfulhps/youthfulhps.github.io"},"sponsor":{"buyMeACoffeeId":"youthfulhps"}}},"markdownRemark":{"id":"37fa364b-36ed-5916-8126-4db2fa736f2f","excerpt":"최근 리엑트 네이티브를 통해 사내 신사업 앱 개발을 담당하게 되었다. 사실 네이티브 플랫폼은 익숙지 않았고, 과거 세 달 정도 개발했던 경험이 분명 좋지는 못했던 기억에\n고민이 많았다. 그럼에도 프로젝트를 완수하고 싶었다. 회사에 돈을 벌어다 줄 채널을 늘려야 했고, 에자일 TF…","html":"<p>최근 리엑트 네이티브를 통해 사내 신사업 앱 개발을 담당하게 되었다. 사실 네이티브 플랫폼은 익숙지 않았고, 과거 세 달 정도 개발했던 경험이 분명 좋지는 못했던 기억에\n고민이 많았다.</p>\n<p>그럼에도 프로젝트를 완수하고 싶었다. 회사에 돈을 벌어다 줄 채널을 늘려야 했고, 에자일 TF팀으로서 본보기를 보여야 했으며, 플랫폼에 한정되지 않은 리엑트 개발자가\n되고 싶은 것도 동기부여 삼을 수 있었고, 프로젝트를 맡게 되면 스스로 쉽게 사명감 같은 뜨거운 것들을 만들어내는 것에 익숙한 것도 한몫했다.</p>\n<p>프로젝트 베타 버전의 앱이 나오고 QA를 진행하는 시점에서 뿌듯함보다는 작업을 하면서 느낀 부족함이 더 크게 다가온다. 개인적으로 개발에 있어 한계를 타파시켜 주는\n도구들을 사용할 때면 해당 도구의 기저에 있는 구현체들이 궁금해진다. 리엑트 네이티브도 마찬가지다. 리엑트 네이티브를 통해 크로스 플랫폼 앱 개발을 쉽게 할 수 있다는\n훅보다는, 어떻게 가능하게 만들었는지가 더 관심을 끈다. 그리고 이런 궁금증들이 해소가 되고 나서야 비로소 사용할 명분을 찾은 기분이 든다.</p>\n<p>짧은 회고는 이쯤 하고, 급하게 담당한 프로젝트 출시를 앞두고 지금이라도 리엑트 네이티브에 대해 조금 더 깊이 살펴보려 한다. <a href=\"https://geundung.dev/126\">React Native Under The Hood</a>는\n어떻게 시작해야 할까 고민하던 중 찾은 걸출한 레퍼런스로 공부 방향을 잡는데 큰 도움이 되었다. 본 글은 해당 시리즈의 번들러 포스트를 따라가 보며 구현체들을 살펴본 글이다.</p>\n<h2 id=\"번들러\" style=\"position:relative;\"><a href=\"#%EB%B2%88%EB%93%A4%EB%9F%AC\" aria-label=\"번들러 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>번들러</h2>\n<p>자바스크립트 생태계에서 번들링 작업은 필연적이다. 리엑트 네이티브 기반으로 작성된 자바스크립트 모듈들과 앱을 구성하는 에셋들도 마찬가지로 번들링 과정을 걸쳐\n네이티브로 제공된다. 리엑트 네이티브는 기본적으로 메타에서 제작한 <a href=\"https://github.com/facebook/metro\">Metro</a>를 번들러로 사용하는데,\n크게 <code class=\"language-text\">Resolution</code>, <code class=\"language-text\">Transformation</code>, <code class=\"language-text\">Serialization</code>라는 세 가지 컨셉을 가지고 있다. 여기서 모듈 해석과 변환 과정을 살펴볼 것이다.</p>\n<h2 id=\"모듈-해석\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%93%88-%ED%95%B4%EC%84%9D\" aria-label=\"모듈 해석 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모듈 해석</h2>\n<p><code class=\"language-text\">Metro</code>의 모듈 해석 과정은 기본적으로 <a href=\"https://nodejs.org/api/modules.html#loading-from-node_modules-folders\">Node’s module resolution algorithm</a>를\n따르며, <code class=\"language-text\">haste</code> 모듈 시스템이나 네이티브 플랫폼별 확장을 고려한 기능들이 보강되어 있다. 관련해서 공식 문서의 <a href=\"https://metrobundler.dev/docs/resolution/\">Module Resolution</a>에도\n잘 설명이 되어 있는데, 해당 문서에 나열되어 있는 순서대로 구현체를 살펴보자.</p>\n<h3 id=\"metro-resolver\" style=\"position:relative;\"><a href=\"#metro-resolver\" aria-label=\"metro resolver permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>metro-resolver</h3>\n<p>프로젝트를 구성하는 모든 모듈들은 <a href=\"https://github.com/facebook/metro/blob/v0.80.9/packages/metro-resolver/src/resolve.js\">metro-resolver</a>의 <code class=\"language-text\">resolve()</code>를 통해\n해석 과정을 거치게 된다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L34\nfunction resolve(context, moduleName, platform) {\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">resolve()</code>에 전달되는 파라미터들을 먼저 살펴보자. 가장 먼저 <code class=\"language-text\">context</code>는 <a href=\"https://metrobundler.dev/docs/resolution/#resolution-context\">Resolution context</a>에\n선언된 속성 값들을 전달받으며, <code class=\"language-text\">metro.config.js</code> 파일 혹은 <code class=\"language-text\">react-native bundle</code> 명령어에 옵션으로 주어지는 값들이 기본 설정값에 덮어쓰기 되어 인자로 사용된다.</p>\n<p><code class=\"language-text\">resolve()</code> 전개를 살펴보다 보면 등장하는 설정들이라 모든 속성을 설명하진 않겠지만, 가령 개발 모드를 위한 번들인지 여부를 나타내기 위한 <code class=\"language-text\">dev</code>, 폴더 모듈을\n해석할 때 <code class=\"language-text\">package.json</code>의 어떤 필드를 진입점으로 사용할 것인지 설정하기 위한 <code class=\"language-text\">mainFields</code>, 모듈 경로의 확장자가 표기되어 있지 않은 경우 임의로\n대입해 모듈 해석을 시도하는 확장자 목록을 담고 있는 <code class=\"language-text\">sourceExts</code>과 같은 값들이 그 예시이다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// context\n{\n  redirectModulePath: (moduleName) =&gt; {...},\n  dev: true,\n  allowHaste: true,\n  sourceExts: [ &#39;js&#39;, &#39;jsx&#39;, &#39;json&#39;, &#39;ts&#39;, &#39;tsx&#39; ],\n  mainFields: [ &#39;react-native&#39;, &#39;browser&#39;, &#39;main&#39; ],\n  allowHaste: true,\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>다음으로 <code class=\"language-text\">moduleName</code>은 실제 코드상에서 모듈 불러오기 구문에 제공된 경로를 가지고 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// moduleName\n&#39;@babel/runtime/helpers/interopRequireDefault&#39;\n&#39;react-native&#39;\n&#39;./App&#39;\n&#39;./app.json&#39;\n&#39;./Libraries/Core/registerCallableModule&#39;\n&#39;./Libraries/Components/AccessibilityInfo/AccessibilityInfo&#39;\n&#39;./Libraries/Components/ActivityIndicator/ActivityIndicator&#39;\n...</code>\n        </deckgo-highlight-code>\n<p>마지막으로 <code class=\"language-text\">platform</code>이다. 번들을 생성할 때 다음과 같이 어떤 플랫폼에서 사용할 번들인지 명시할 수 있는 옵션이 있는데, 해당 옵션에 따라 <code class=\"language-text\">android</code> 혹은\n<code class=\"language-text\">ios</code>가 전달된다. 그 외 <code class=\"language-text\">windows</code>, <code class=\"language-text\">web</code>도 가능하다.</p>\n<deckgo-highlight-code language=\"shell\"  >\n          <code slot=\"code\">~$ react-native bundle --platform android</code>\n        </deckgo-highlight-code>\n<h3 id=\"제공된-customresolver가-있다면-해석-요청을-위임한다\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EA%B3%B5%EB%90%9C-customresolver%EA%B0%80-%EC%9E%88%EB%8B%A4%EB%A9%B4-%ED%95%B4%EC%84%9D-%EC%9A%94%EC%B2%AD%EC%9D%84-%EC%9C%84%EC%9E%84%ED%95%9C%EB%8B%A4\" aria-label=\"제공된 customresolver가 있다면 해석 요청을 위임한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제공된 CustomResolver가 있다면, 해석 요청을 위임한다</h3>\n<p><code class=\"language-text\">resolve()</code>에서는 가장 먼저 <code class=\"language-text\">CustomResolver</code>를 제공하고 있는지 확인하고, 만약 있다면 모듈 해석 요청을 해당 <code class=\"language-text\">CustomResolver</code>에게 위임한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L34\nfunction resolve(context, moduleName, platform) {\n  const resolveRequest = context.resolveRequest;\n  if (resolveRequest &amp;&amp; resolveRequest !== resolve) {\n    return resolveRequest(\n      Object.freeze({\n        ...context,\n        resolveRequest: resolve,\n      }),\n      moduleName,\n      platform\n    );\n  }\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>이는 <code class=\"language-text\">resolver.resolveRequest</code> 속성으로 제공할 수 있는데, 가령 모듈에 대해 분기적으로 해석이 필요한 경우 별칭을 붙여 해당 모듈 해석 요청을 커스텀된\n리졸버가 위임받을 수 있도록 제공할 수 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro.config.js\nmodule.exports = {\n  resolver: {\n    resolveRequest: (context, moduleName, platform) =&gt; {\n      if (moduleName.startsWith(&#39;my-custom-resolver:&#39;)) {\n        return {\n          filePath: &#39;path/to/file&#39;,\n          type: &#39;sourceFile&#39;,\n        };\n      }\n\n      return context.resolveRequest(context, moduleName, platform);\n    };\n  }\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"불러오기-구문에-제공된-대상을-파일-혹은-폴더-경로로서-해석을-시도한다\" style=\"position:relative;\"><a href=\"#%EB%B6%88%EB%9F%AC%EC%98%A4%EA%B8%B0-%EA%B5%AC%EB%AC%B8%EC%97%90-%EC%A0%9C%EA%B3%B5%EB%90%9C-%EB%8C%80%EC%83%81%EC%9D%84-%ED%8C%8C%EC%9D%BC-%ED%98%B9%EC%9D%80-%ED%8F%B4%EB%8D%94-%EA%B2%BD%EB%A1%9C%EB%A1%9C%EC%84%9C-%ED%95%B4%EC%84%9D%EC%9D%84-%EC%8B%9C%EB%8F%84%ED%95%9C%EB%8B%A4\" aria-label=\"불러오기 구문에 제공된 대상을 파일 혹은 폴더 경로로서 해석을 시도한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>불러오기 구문에 제공된 대상을 파일 혹은 폴더 경로로서 해석을 시도한다</h3>\n<p>제공된 커스텀 리졸버가 없다면, <code class=\"language-text\">Metro</code>는 기본적인 모듈 해석 과정에 돌입한다. 가장 먼저 불러오기 구문에 제공된 대상 즉, <code class=\"language-text\">moduleName</code>을 모듈의 경로로서\n해석을 시도한다. 이를 위해 <code class=\"language-text\">moduleName</code>이 상대 경로 혹은 절대 경로의 형태를 갖추고 있는지 판단한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L34\nfunction resolve(context, moduleName, platform) {\n  ...\n  // &#39;moduleName&#39;이 상대 경로 혹은 절대 경로의 형태를 갖추고 있는지 판단하여 해당 모듈 해석을 시도한다.\n  if (isRelativeImport(moduleName) || _path.default.isAbsolute(moduleName)) {\n    const result = resolveModulePath(context, moduleName, platform);\n    if (result.type === &quot;failed&quot;) {\n      throw new _FailedToResolvePathError.default(result.candidates);\n    }\n    return result.resolution;\n  }\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>해당 분기는 <code class=\"language-text\">node.js</code>에서 <a href=\"https://nodejs.org/api/modules.html#file-modules\">File Modules</a>, <a href=\"https://nodejs.org/api/modules.html#folders-as-modules\">Folders as modules</a>을\n해석하기 위한 단계와 동일하다. 간단하게 정리하자면, 모듈 불러오기 구문에 제공된 대상이 <code class=\"language-text\">'./'</code>, <code class=\"language-text\">'/'</code>, <code class=\"language-text\">'../'</code>로 시작할 경우 이를 파일 혹은 폴더 모듈의 경로로\n간주하고 <code class=\"language-text\">resolveModulePath()</code>를 통해 해당 모듈 경로 해석을 시도하게 된다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L157\nfunction resolveModulePath(context, toModuleName, platform) {\n  ...\n  const dirPath = _path.default.dirname(redirectedPath);\n  const fileName = _path.default.basename(redirectedPath);\n  // 대상을 파일로 가정하고 해석을 시도한다.\n  const fileResult = resolveFile(context, dirPath, fileName, platform);\n  if (fileResult.type === &quot;resolved&quot;) {\n    return fileResult;\n  }\n  // 대상을 폴더로 가정하고 해석을 시도한다.\n  const dirResult = resolvePackageEntryPoint(context, redirectedPath, platform);\n  if (dirResult.type === &quot;resolved&quot;) {\n    return dirResult;\n  }\n  return failedFor({\n    file: fileResult.candidates,\n    dir: dirResult.candidates,\n  });\n}</code>\n        </deckgo-highlight-code>\n<p>먼저 <code class=\"language-text\">resolveFile()</code>를 통해 해당 경로를 파일 경로로 간주하고 해석을 시도하는데, 해당 파일이 에셋인 경우 혹은 소스 파일인 경우에 대한 반환점을 가지고 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L375\nfunction resolveFile(context, dirPath, fileName, platform) {\n  if ((0, _isAssetFile.default)(fileName, context.assetExts)) {\n    ...\n    // 에셋 파일 경로로서 해석된 결과를 반환한다.\n    return resolvedAs(assetResolutions);\n  }\n\n  const sourceFileResolution = resolveSourceFile(sfContext, platform);\n  if (sourceFileResolution != null) {\n    if (typeof sourceFileResolution === &quot;string&quot;) {\n      // 소스 파일 경로로서 해석된 결과를 반환한다.\n      return resolvedAs({\n        type: &quot;sourceFile&quot;,\n        filePath: sourceFileResolution,\n      });\n    }\n    return resolvedAs(sourceFileResolution);\n  }\n  return failedFor({\n    type: &quot;sourceFile&quot;,\n    filePathPrefix,\n    candidateExts,\n  });\n}</code>\n        </deckgo-highlight-code>\n<p>소스 파일 경로로 해석되는 <code class=\"language-text\">resolveSourceFile()</code>에서는 <code class=\"language-text\">resolver.sourceExts</code> 설정을 통해 제공된 소스 파일 확장자 혹은 기본값인 <code class=\"language-text\">['js', 'jsx', 'json', 'ts', 'tsx']</code>\n를 순회하여 확장자가 제공되지 않은 파일 경로에 대입하여 해당 경로 해석을 시도한다.</p>\n<p>위에서 줄곧 ‘파일 모듈 경로로 간주하고’ 라는 표현을 사용했다. 이는 아직 해당 경로가 파일 경로인지 폴더 경로인지 모르는 단계에서 파일 확장자를 대입해 해당 경로를\n해석하려는 시도가 포함되어 있기 때문이기도 하다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L426\nfunction resolveSourceFile(context, platform) {\n  // 파일 경로가 파일 확장자를 포함하고 있다면, 그대로 파일 경로 해석을 시도한다.\n  let filePath = resolveSourceFileForAllExts(context, &#39;&#39;);\n  if (filePath) {\n    return filePath;\n  }\n\n  // 파일 경로에 파일 확장자를 대입하고 파일 경로 해석을 시도한다.\n  const { sourceExts } = context;\n  for (let i = 0; i &lt; sourceExts.length; i++) {\n    const ext = `.${sourceExts[i]}`;\n    filePath = resolveSourceFileForAllExts(context, ext, platform);\n    if (filePath != null) {\n      return filePath;\n    }\n  }\n  return null;\n}</code>\n        </deckgo-highlight-code>\n<p>여기서 짚고 넘어갈 점은 <code class=\"language-text\">resolveSourceFileForAllExts()</code>에서 플랫폼 별 코드를 제공하는 <code class=\"language-text\">.android.{ext}</code>, <code class=\"language-text\">.ios.{ext}</code>, <code class=\"language-text\">.native.{ext}</code>\n확장자를 처리하기 위한 단계도 포함되어 있다. 리엑트 네이티브에서는 특정 플랫폼별 코드를 구분할 수 있는 방법을 제공하는데, 그중 하나가 플랫폼을 확장자에 포함시키는 방법이다.\n관련해서 <a href=\"https://reactnative.dev/docs/platform-specific-code\">Platform-Specific Code</a>를 참고하자.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L451\nfunction resolveSourceFileForAllExts(context, sourceExt, platform) {\n  // 지정된 플랫폼을 확장자에 포함시켜 파일 경로 해석을 시도한다.\n  if (platform != null) {\n    const ext = `.${platform}${sourceExt}`;\n    const filePath = resolveSourceFileForExt(context, ext);\n    if (filePath) {\n      return filePath;\n    }\n  }\n\n  // &#39;preferNativePlatform&#39; 속성이 &#39;true&#39;로 설정되어 있다면,\n  // &#39;native&#39;를 확장자에 포함시켜 파일 경로 해석을 시도한다.\n  if (context.preferNativePlatform &amp;&amp; sourceExt !== &#39;&#39;) {\n    const filePath = resolveSourceFileForExt(context, `.native${sourceExt}`);\n    if (filePath) {\n      return filePath;\n    }\n  }\n  const filePath = resolveSourceFileForExt(context, sourceExt);\n  return filePath;\n}</code>\n        </deckgo-highlight-code>\n<p>주어진 경로가 파일 경로로서 해석되지 못한 경우, 해당 경로를 폴더 경로로 간주하고 <code class=\"language-text\">resolveModulePath()</code>의 <code class=\"language-text\">resolvePackageEntryPoint()</code>로 진입하게 된다.\n이는 위에 언급한 <code class=\"language-text\">node.js</code> 모듈 해석 단계의 <a href=\"https://nodejs.org/api/modules.html#folders-as-modules\">Folders as modules</a>과 유사하다.</p>\n<p>대상 경로를 폴더 경로로서 해석하기 위해 가장 먼저 해당 폴더 하위에 위치한 <code class=\"language-text\">package.json</code> 파일을 찾고, <code class=\"language-text\">package.json</code> 파일에 제공된 진입점으로 제안된 필드에\n제공된 경로를 가져와 파일 모듈 경로로서 해석을 시도한다. 이때 진입점으로 사용될 필드는 기본적으로 <code class=\"language-text\">['react-native', 'browser', 'main']</code> 순으로 적용되지만,\n<code class=\"language-text\">resolvers.resolverMainFields</code> 설정값을 통해 덮어쓸 수 있다.</p>\n<p>하지만 <code class=\"language-text\">package.json</code> 파일이 없거나, <code class=\"language-text\">package.json</code>에 진입점으로 설정된 필드가 없거나, <code class=\"language-text\">package.json</code>의 진입점으로 참조할 필드의 경로를 파일 경로로서\n해석해내지 못한 경우가 발생한다. 이런 경우, 폴더 경로 하위의 <code class=\"language-text\">index.js</code> 파일을 찾아 파일 경로로서 해석을 시도하고 그 결과를 반환한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L319\nfunction resolvePackageEntryPoint(context, packagePath, platform) {\n  // 폴더에서 &#39;package.json&#39; 파일을 찾는다.\n  const packageJsonPath = _path.default.join(packagePath, &#39;package.json&#39;);\n\n  // 만약 &#39;package.json&#39; 파일이 없다면, 해당 폴더의 &#39;index&#39; 파일을 찾는다.\n  if (!context.doesFileExist(packageJsonPath)) {\n    return resolveFile(context, packagePath, &#39;index&#39;, platform);\n  }\n  const packageInfo = {\n    rootPath: _path.default.dirname(packageJsonPath),\n    packageJson: context.getPackage(packageJsonPath) ?? {},\n  };\n\n  // &#39;package.json&#39;의 진입점으로 제안된 필드에 제공된 경로를 참조하여 파일 모듈 경로로서 해석을 시도한다.\n  const mainModulePath = _path.default.join(\n    packageInfo.rootPath,\n    (0, _PackageResolve.getPackageEntryPoint)(context, packageInfo, platform)\n  );\n  const fileResult = resolveFile(\n    context,\n    _path.default.dirname(mainModulePath),\n    _path.default.basename(mainModulePath),\n    platform\n  );\n  if (fileResult.type === &#39;resolved&#39;) {\n    return fileResult;\n  }\n\n  // &#39;package.json&#39;의 진입점으로 제공된 필드를 참조하여 경로를 해석하지 못했다면,\n  // 해당 경로 폴더의 &#39;index&#39; 파일을 찾는다.\n  const indexResult = resolveFile(context, mainModulePath, &#39;index&#39;, platform);\n  if (indexResult.type !== &#39;resolved&#39;) {\n    throw new _InvalidPackageError.default({\n      packageJsonPath,\n      mainModulePath,\n      fileCandidates: fileResult.candidates,\n      indexCandidates: indexResult.candidates,\n    });\n  }\n  return indexResult;\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"리다이렉션된-경로의-실제-경로를-구해-해석을-시도한다\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EB%8B%A4%EC%9D%B4%EB%A0%89%EC%85%98%EB%90%9C-%EA%B2%BD%EB%A1%9C%EC%9D%98-%EC%8B%A4%EC%A0%9C-%EA%B2%BD%EB%A1%9C%EB%A5%BC-%EA%B5%AC%ED%95%B4-%ED%95%B4%EC%84%9D%EC%9D%84-%EC%8B%9C%EB%8F%84%ED%95%9C%EB%8B%A4\" aria-label=\"리다이렉션된 경로의 실제 경로를 구해 해석을 시도한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리다이렉션된 경로의 실제 경로를 구해 해석을 시도한다</h3>\n<p>파일 혹은 폴더 경로로서 해석을 시도했지만 실패했다면, 해당 경로를 리다이렉션된 경로로 간주하고 실제 경로를 구해 해석을 시도한다.\n<code class=\"language-text\">Metro</code>에서는 가령 특정 모듈 경로를 다른 경로로 리다이렉션해야 하는 경우를 위해 이에 대한 규칙을 정의할 수 있는 <code class=\"language-text\">resolver.redirectModulePath</code> 속성을\n제공한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro.config.js\nconst path = require(&#39;path&#39;);\n\nmodule.exports = {\n  resolver: {\n    redirectModulePath: modulePath =&gt; {\n      // &#39;src/utils/math&#39; 모듈 경로를 &#39;src/utils/calculator&#39;로 리다이렉션한다.\n      if (modulePath === path.resolve(__dirname, &#39;src/utils/math&#39;)) {\n        return path.resolve(__dirname, &#39;src/utils/calculator&#39;);\n      }\n      return modulePath;\n    },\n  },\n};</code>\n        </deckgo-highlight-code>\n<p>즉 전 단계에서 해석해내지 못한 모듈 경로가 리다이렉션된 경로일 수 있다는 가정하에 실제 경로를 구하는 작업을 진행하고 대응되는 실제 모듈 경로가 제공되어 있다면,\n실제 경로를 통해 다시 전 과정을 진행한다.</p>\n<p>여기서 특이한 점은 <code class=\"language-text\">resolver.redirectModulePath</code>에서 특정 모듈 경로에 대해 <code class=\"language-text\">false</code>를 반환할 수 있다는 점이고, 실제 경로가 <code class=\"language-text\">false</code>로 반환된 경로는 <code class=\"language-text\">empty</code> 타입의\n결과를 반환한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L34\nfunction resolve(context, moduleName, platform) {\n  // ... 파일 혹은 폴더로서 모듈 대상을 해석하기 위한 과정\n\n  // &#39;moduleName&#39;을 리다이렉션된 경로로 간주하고 이에 대한 실제 경로를 구한다.\n  const realModuleName = context.redirectModulePath(moduleName);\n  if (realModuleName === false) {\n    return {\n      type: &#39;empty&#39;,\n    };\n  }\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>사실 <code class=\"language-text\">empty</code> 타입의 모듈이 왜 필요한지 아직 명확히 파악하지 못했지만, 특정 모듈을 번들링 과정에서 포함시키지 않고 싶거나, 특정 모듈 해석에 실패해도 모든 모듈들을\n해석하는 과정에 있어 문제없이 넘어갈 수 있도록 하기 위해 속성으로 열어둔 것이 아닌가 하는 생각이다.</p>\n<h3 id=\"hastemodule로서-해석을-시도한다\" style=\"position:relative;\"><a href=\"#hastemodule%EB%A1%9C%EC%84%9C-%ED%95%B4%EC%84%9D%EC%9D%84-%EC%8B%9C%EB%8F%84%ED%95%9C%EB%8B%A4\" aria-label=\"hastemodule로서 해석을 시도한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>HasteModule로서 해석을 시도한다</h3>\n<p>자바스크립트 모듈 시스템의 일환으로 정적 리소스에 대한 종속성 관리를 위해 고안된 <code class=\"language-text\">Haste</code>를 통해 대상 모듈 해석을 시도한다. 사실 <code class=\"language-text\">Haste</code>라는\n키워드 자체를 <code class=\"language-text\">Metro</code>를 공부하며 처음 접했다. 며칠 동안 찾아봐도 그럴싸한 레퍼런스를 찾기 어려워 과연 본 섹션을 잘 정리해 낼 수 있을까도 의문이었는데,\n구 페이스북에서 <code class=\"language-text\">Haste</code> 모듈 시스템을 사용해 온 흔적들과 <code class=\"language-text\">Metro</code> 패키지의 구현체들을 토대로 정리해보려 한다. (옳고 그름이 명확하지 않을 수 있으니 넘어가셔도 좋습니다.)</p>\n<p>현재 <code class=\"language-text\">Metro</code>에서 사용되는 <code class=\"language-text\">Haste</code> 구현체는 <a href=\"https://github.com/facebook/metro/tree/v0.80.9/packages/metro-file-map\">metro-file-map</a> 패키지로 관리되고 있으며,\n아직 실험적인 단계로 본 해석 과정을 <code class=\"language-text\">resolver.allowHaste</code> 속성을 통해 제한할 수 있다.</p>\n<p>아직 실험적인 단계의 패키지인터라 어쩌면 모듈 시스템의 뜨거운 감자일 수 있겠다는 생각이 들 수 있겠지만, 2015년 이전에 제안되어 구 페이스북 패키지 생태계에서\n널리 사용되어 온 모듈 시스템으로 보인다. <code class=\"language-text\">react v.15</code>의 코드를 살펴보면, <code class=\"language-text\">@providesModule {MODULE_ID}</code> 구문이 눈에 띄는데, 이는 <code class=\"language-text\">Haste</code> 모듈\n시스템에서 유효한 모듈 식별자를 정의하기 위한 구문이며 모든 모듈들에 동일하게 정의되어 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// https://github.com/facebook/react/blob/v15.4.0/src/renderers/dom/ReactDOM.js#L8-L10\n\n/**\n * ...\n *\n * @providesModule ReactDOM\n */</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// Haste 모듈 시스템에서 유효한 모듈 식별자를 통해 &#39;ReactDOM&#39; 모듈을 불러온다.\nvar ReactDOM = require(&#39;ReactDOM&#39;);</code>\n        </deckgo-highlight-code>\n<p>하지만 <code class=\"language-text\">react v.16</code>에서 <a href=\"https://legacy.reactjs.org/blog/2017/12/15/improving-the-repository-infrastructure.html#removing-the-custom-module-system\">Haste 모듈 시스템이 제거</a>되었다.\n더불어 2015년도 리엑트 네이티브 블로그의 <a href=\"https://reactnative.dev/blog/2019/06/12/react-native-open-source-update#meaningful-community-contributions\">포스트</a>를 통해\n<code class=\"language-text\">Haste</code> 모듈 시스템을 제거하기 위한 움직임이 제안된 것을 확인할 수 있으며, 비슷한 시기에 <a href=\"https://github.com/facebookarchive/node-haste/tree/archived\">facebookarchive/node-haste</a> 저장소 또한 아카이빙 되었다.</p>\n<p>아무래도 자바스크립트의 정식 모듈 시스템인 <code class=\"language-text\">ES Module</code>이 등장하면서 정식 모듈 시스템을 도입하자는 구 페이스북 패키지 생태계의 움직임에 <code class=\"language-text\">Haste</code> 모듈 시스템이\n레거시가 되어버린 것으로 짐작할 수 있다.</p>\n<p>하지만 본 모듈 해석 단계와 같이 아직 완벽하게 제거된 것은 아니기 때문에 다시 본론으로 돌아와서 <code class=\"language-text\">HasteModule</code>로서 어떻게 모듈 해석을 시도하는지 알아보자.</p>\n<p>예시와 같이 <code class=\"language-text\">@providesModule {MODULE_ID}</code> 구문을 통해 <code class=\"language-text\">Haste</code> 모듈 시스템에서 유효한 모듈 식별자를 정의하여, 상대적인 경로의 깊이와 상관없이\n마치 절대 경로를 통해 모듈을 불러오는 것처럼 모듈 불러오기가 가능하다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// /src/utils/Math.js\n\n/**\n * @providesModule Math\n */\n\nexport default class Math {\n  static add(a, b) {\n    return a + b;\n  }\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// App.js\n\nconst Math = require(&#39;Math&#39;);\nconsole.log(Math.add(1, 2)); // 3</code>\n        </deckgo-highlight-code>\n<p>그렇다면 <code class=\"language-text\">Haste</code> 모듈 시스템에서 어떻게 <code class=\"language-text\">Math</code> 모듈 경로를 해석할 수 있을까? 이에 대한 답은, 모듈 해석 단계 전에 <code class=\"language-text\">HasteMap</code>이 생성되는 과정에서 찾아볼 수 있다.\n<code class=\"language-text\">Haste</code> 모듈 시스템에서는 모든 모듈들을 순회하여 파입맵을 생성하고, 파일맵을 기준으로 <code class=\"language-text\">HasteModule</code>로서 유효한 모듈 정보를 <code class=\"language-text\">HasteMap</code>에 <code class=\"language-text\">set</code>한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-file-map/src/index.js#L413\nasync _constructHasteMap(fileSystem) {\n  ...\n  // &#39;HasteMap&#39;을 생성한다.\n  const hasteMap = new _MutableHasteMap.default({\n    console: this._console,\n    platforms: new Set(this._options.platforms),\n    rootDir: this._options.rootDir,\n    throwOnModuleCollision: this._options.throwOnModuleCollision,\n  });\n\n  let hasteFiles = 0;\n  // 모든 모듈들의 파일맵을 순회한다.\n  for (const {\n    baseName,\n    canonicalPath,\n    metadata,\n  } of fileSystem.metadataIterator({\n    includeNodeModules: false,\n    includeSymlinks: false,\n  })) {\n    // &#39;metadata&#39; 배열에 모듈 식별자 인덱스에 해당하는 0번 째 요소가 빈 문자열이 아니라면,\n    // 해당 모듈 정보를 &#39;HasteMap&#39;에 등록한다.\n    if (metadata[_constants.default.ID]) {\n      hasteMap.setModule(metadata[_constants.default.ID], [\n        canonicalPath,\n        baseName === &quot;package.json&quot;\n          ? _constants.default.PACKAGE\n          : _constants.default.MODULE,\n      ]);\n      if (++hasteFiles % YIELD_EVERY_NUM_HASTE_FILES === 0) {\n        await new Promise(setImmediate);\n      }\n    }\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>가령 위에서 예시로 든 <code class=\"language-text\">Math.js</code>에 대한 메타데이터 정보는 다음과 같은데, <code class=\"language-text\">metadata</code> 배열에 담기는 요소들이 가지는 정보는 <code class=\"language-text\">[ID, MTIME, SIZE, VISITED, DEPENDENCIES, SHA1, SYMLINK]</code>와\n대응된다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">export type FileMetaData = [\n  /* id */ string,\n  /* mtime */ number,\n  /* size */ number,\n  /* visited */ 0 | 1,\n  /* dependencies */ string,\n  /* sha1 */ string | null,\n  /* symlink */ 0 | 1 | string // string specifies target, if known\n];</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">console.log(baseName);\n// Math.js\nconsole.log(canonicalPath);\n// src/utils/Math.js\nconsole.log(metadata);\n// [&#39;Math&#39;, 1716187520142, 106, 1, &#39;&#39;, &#39;32e0890a27cae526e33f56ed9b3a88cb75b21fc2&#39;, 0]</code>\n        </deckgo-highlight-code>\n<p>여기서 <code class=\"language-text\">ID</code>, 즉 모듈 식별자를 가지고 있는 0번째 요소의 값이 있다는 것은 해당 모듈 파일에서 <code class=\"language-text\">@providesModule {MODULE_ID}</code> 구문을 통해 모듈 식별자가\n정의되었다는 것이고 만약 모듈 식별자가 정의되어 있지 않다면, 빈 문자열이 담겨 <code class=\"language-text\">HasteMap</code>에 등록되는 분기 영역에서 제외되는 것이다. 결과적으로 <code class=\"language-text\">Math.js</code>에 정의된\n모듈 정보는 <code class=\"language-text\">Math</code> 라는 모듈 식별자로 <code class=\"language-text\">HasteMap</code>에 등록된다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">console.log(hasteMap.getRawHasteMap().map);\n// Map(1) {\n//   &#39;Math&#39; =&gt; [Object: null prototype] { g: [ &#39;src/utils/Math.js&#39;, 0 ] }\n// }</code>\n        </deckgo-highlight-code>\n<p>이제 다시 돌아가 <code class=\"language-text\">resolve()</code>에서 <code class=\"language-text\">HasteModule</code>로서 해당 모듈 경로 해석을 시도하는 <code class=\"language-text\">resolveHasteName()</code> 과정을 살펴보자.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L34\nfunction resolve(context, moduleName, platform) {\n  ...\n  if (context.allowHaste &amp;&amp; !isDirectImport) {\n    const normalizedName = normalizePath(realModuleName);\n    // &#39;HasteModule&#39;로서 모듈 경로 해석을 시도한다.\n    const result = resolveHasteName(context, normalizedName, platform);\n    if (result.type === &quot;resolved&quot;) {\n      return result.resolution;\n    }\n  }\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">resolveHasteName()</code>를 들여다보면 <code class=\"language-text\">context.resolveHasteModule()</code>, <code class=\"language-text\">context.resolveHastePackage()</code>를 통해 <code class=\"language-text\">HasteModule</code>로서\n경로 해석을 시도하는데, <code class=\"language-text\">context.resolveHasteModule()</code>은 <code class=\"language-text\">metro-file-map</code>에 정의된 <a href=\"https://github.com/facebook/metro/blob/v0.80.9/packages/metro-file-map/src/lib/MutableHasteMap.js#L95\">getModule</a>을,\n<code class=\"language-text\">context.resolveHastePackage()</code>은 <a href=\"https://github.com/facebook/metro/blob/v0.80.9/packages/metro-file-map/src/lib/MutableHasteMap.js#L113\">getPackage</a>을 기본 구현체로 한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L188\nfunction resolveHasteName(context, moduleName, platform) {\n  const modulePath = context.resolveHasteModule(moduleName);\n  if (modulePath != null) {\n    return resolvedAs({\n      type: &quot;sourceFile&quot;,\n      filePath: modulePath,\n    });\n  }\n  let packageName = moduleName;\n  let packageJsonPath = context.resolveHastePackage(packageName);\n  ...\n  if (result.type === &quot;resolved&quot;) {\n    return result;\n  }</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">getModule()</code>과 <code class=\"language-text\">getPackage()</code>는 주요하게 <code class=\"language-text\">_getModuleMetadata()</code> 메서드를 사용하고 있다. 이는 모듈 해석 단계 전에 호출되어 생성되고, <code class=\"language-text\">HasteModule</code>로서\n유효한 모듈 정보들이 <code class=\"language-text\">set</code> 되어 있는 <code class=\"language-text\">HasteMap</code>에서 대상 모듈들의 실제 경로를 찾아 모듈 경로로서 해석을 시도하는 것을 확인할 수 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-file-map/src/lib/MutableHasteMap.js#L42\nexport default class MutableHasteMap implements HasteMap {\n  ...\n  getModule(...): ?Path {\n    const module = this._getModuleMetadata(\n      name,\n      platform,\n      !!supportsNativePlatform,\n    );\n    if (module &amp;&amp; module[H.TYPE] === (type ?? H.MODULE)) {\n      const modulePath = module[H.PATH];\n      return modulePath &amp;&amp; this.#pathUtils.normalToAbsolute(modulePath);\n    }\n    return null;\n  }\n\n  getPackage(...): ?Path {\n    return this.getModule(name, platform, null, H.PACKAGE);\n  }\n\n  _getModuleMetadata(name, platform, supportsNativePlatform) {\n    // &#39;HasteMap&#39;에서 모듈 식별자를 통해 대상 모듈 정보를 찾는다.\n    const map = this.#map.get(name) || EMPTY_OBJ;\n    const dupMap = this.#duplicates.get(name) || EMPTY_MAP;\n    if (platform != null) {\n      this._assertNoDuplicates(\n        name,\n        platform,\n        supportsNativePlatform,\n        dupMap.get(platform)\n      );\n      if (map[platform] != null) {\n        return map[platform];\n      }\n    }\n  ...\n  }\n  ...\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"node_modules-경로를-붙여-모듈-경로-해석을-시도한다\" style=\"position:relative;\"><a href=\"#node_modules-%EA%B2%BD%EB%A1%9C%EB%A5%BC-%EB%B6%99%EC%97%AC-%EB%AA%A8%EB%93%88-%EA%B2%BD%EB%A1%9C-%ED%95%B4%EC%84%9D%EC%9D%84-%EC%8B%9C%EB%8F%84%ED%95%9C%EB%8B%A4\" aria-label=\"node_modules 경로를 붙여 모듈 경로 해석을 시도한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>node_modules 경로를 붙여 모듈 경로 해석을 시도한다</h3>\n<p>이제 위 단계에서 해석되지 못한 모듈들은 <code class=\"language-text\">realModuleName</code>에 담긴 실제 경로를 통해 <code class=\"language-text\">node_modules</code>에서 찾기 시작한다. 가장 먼저 현재 디렉토리에서부터\n루트 디렉토리까지를 <code class=\"language-text\">node_modules</code>이 위치할 수 있는 후보군으로 두고 모두 <code class=\"language-text\">nodeModulesPaths</code> 배열에 담는다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L34\nfunction resolve(context, moduleName, platform) {\n  ...\n  // &#39;disableHierarchicalLookup&#39;, &#39;node_modules&#39; 폴더에서 모듈 조회를 비활성화하는 속성.\n  const {disableHierarchicalLookup} = context;\n  const nodeModulesPaths = [];\n  let next = _path.default.dirname(originModulePath);\n  if (!disableHierarchicalLookup) {\n    let candidate;\n    // &#39;node_modules&#39; 폴더가 위치할 수 있는 현재 디렉토리부터 루트 디렉토리까지를 모두 후보군으로 둔다.\n    do {\n      candidate = next;\n      nodeModulesPaths.push(_path.default.join(candidate, &#39;node_modules&#39;));\n      next = _path.default.dirname(candidate);\n    } while (candidate !== next);\n  }\n  nodeModulesPaths.push(...context.nodeModulesPaths);\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>또한, <code class=\"language-text\">resolver.extraNodeModules</code>로 제공된 그 외 <code class=\"language-text\">node_modules</code>의 경로 또한 후보군으로 추가한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L34\nfunction resolve(context, moduleName, platform) {\n  ...\n  const extraPaths = [];\n  const { extraNodeModules } = context;\n  // &#39;moduleName&#39; 패키지가 존재할 수 있는 추가적인 경로를 제공했다면, 해당 경로 또한 후보군으로 둔다.\n  if (extraNodeModules) {\n    let bits = _path.default.normalize(moduleName).split(_path.default.sep);\n    let packageName;\n    ...\n    if (extraNodeModules[packageName]) {\n      bits[0] = extraNodeModules[packageName];\n      extraPaths.push(_path.default.join.apply(_path.default, bits));\n    }\n  }\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>마지막으로 모듈 경로의 후보군들을 순회하며 위에서 진행된 방식으로 모듈 해석을 시도하며 해석 결과를 반환한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L34\nfunction resolve(context, moduleName, platform) {\n  ...\n  // 취합된 후보군의 패키지 경로를 통해 모듈 해석을 시도한다.\n  const allDirPaths = nodeModulesPaths\n    .map(nodeModulePath =&gt; _path.default.join(nodeModulePath, realModuleName))\n    .concat(extraPaths);\n  for (let i = 0; i &lt; allDirPaths.length; ++i) {\n    // &#39;resolver.resolverMainFields&#39;에 제공된 &#39;package.json&#39;의 진입점 필드를 통해\n    // 후보 경로들을 패키지 모듈로서 해석을 시도한다.\n    const candidate = context.redirectModulePath(allDirPaths[i]);\n    if (candidate === false) {\n      return {\n        type: &#39;empty&#39;,\n      };\n    }\n    const result = resolvePackage(context, candidate, platform);\n    if (result.type === &#39;resolved&#39;) {\n      return result.resolution;\n    }\n  }\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">node_modules</code>에서 모듈을 해석하는 과정은 마지막 단계에 해당하기 때문에 본 과정에서도 해석되지 않은 모듈 경로에 대해 에러를 반환한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-resolver/src/resolve.js#L34\nfunction resolve(context, moduleName, platform) {\n  ...\n  throw new _FailedToResolveNameError.default(nodeModulesPaths, extraPaths);\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"변환\" style=\"position:relative;\"><a href=\"#%EB%B3%80%ED%99%98\" aria-label=\"변환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>변환</h2>\n<p>개발환경에서 작성되어 해석된 모든 모듈들은 대상 플랫폼에서 구동할 수 있는 형식으로 코드를 변환한다. 대부분의 코드 변환은 <code class=\"language-text\">babel</code>이 담당하고 있으며, <code class=\"language-text\">swc</code>와\n같은 대체제를 사용할 수 있도록 개선하고 있지만, 아직 생태계가 한정적이다.</p>\n<p>모든 모듈들이 변환 과정을 거쳐야 하기 때문에 변환 과정은 매우 높은 비용을 차지한다. 일반적인 번들러를 생각해 보면, 변환 과정을 주체적으로 담당하는 메인 프로세스에서\n순차적으로 모듈을 변환하는 직렬적인 방식으로 진행하게 된다. 이는 코드 베이스 크기에 따라 의존적으로 변환 수행 시간이 늘어난다.</p>\n<p><code class=\"language-text\">Metro</code>는 이를 개선하기 위해 메인 프로세스에서 <code class=\"language-text\">Worker</code>라 칭하는 하위 변환 작업들을 생성하고, 포크된 여러 개의 하위 프로세스에서 생성된 변환 작업들을 병렬적으로 처리할 수 있도록\n한다. 여기서 포크된 하위 프로세스의 개수는 하드웨어의 코어 개수에 의존적이며, 이렇게 생성된 <code class=\"language-text\">Worker</code>들은 <code class=\"language-text\">JestWorker</code>를 기반으로 한 <code class=\"language-text\">WorkerFarm</code>을 통해 내부적으로 관리된다.</p>\n<p><svg aria-roledescription=\"flowchart-v2\" role=\"graphics-document document\" viewBox=\"-8 -8 412.3125 201\" style=\"max-width: 412.3125px;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" id=\"mermaid-0\"><style>#mermaid-0{font-family:arial,sans-serif;font-size:16px;fill:#ccc;}#mermaid-0 .error-icon{fill:#a44141;}#mermaid-0 .error-text{fill:#ddd;stroke:#ddd;}#mermaid-0 .edge-thickness-normal{stroke-width:2px;}#mermaid-0 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-0 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-0 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-0 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-0 .marker{fill:lightgrey;stroke:lightgrey;}#mermaid-0 .marker.cross{stroke:lightgrey;}#mermaid-0 svg{font-family:arial,sans-serif;font-size:16px;}#mermaid-0 .label{font-family:arial,sans-serif;color:#ccc;}#mermaid-0 .cluster-label text{fill:#F9FFFE;}#mermaid-0 .cluster-label span,#mermaid-0 p{color:#F9FFFE;}#mermaid-0 .label text,#mermaid-0 span,#mermaid-0 p{fill:#ccc;color:#ccc;}#mermaid-0 .node rect,#mermaid-0 .node circle,#mermaid-0 .node ellipse,#mermaid-0 .node polygon,#mermaid-0 .node path{fill:#1f2020;stroke:#81B1DB;stroke-width:1px;}#mermaid-0 .flowchart-label text{text-anchor:middle;}#mermaid-0 .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-0 .node .label{text-align:center;}#mermaid-0 .node.clickable{cursor:pointer;}#mermaid-0 .arrowheadPath{fill:lightgrey;}#mermaid-0 .edgePath .path{stroke:lightgrey;stroke-width:2.0px;}#mermaid-0 .flowchart-link{stroke:lightgrey;fill:none;}#mermaid-0 .edgeLabel{background-color:hsl(0, 0%, 34.4117647059%);text-align:center;}#mermaid-0 .edgeLabel rect{opacity:0.5;background-color:hsl(0, 0%, 34.4117647059%);fill:hsl(0, 0%, 34.4117647059%);}#mermaid-0 .labelBkg{background-color:rgba(87.75, 87.75, 87.75, 0.5);}#mermaid-0 .cluster rect{fill:hsl(180, 1.5873015873%, 28.3529411765%);stroke:rgba(255, 255, 255, 0.25);stroke-width:1px;}#mermaid-0 .cluster text{fill:#F9FFFE;}#mermaid-0 .cluster span,#mermaid-0 p{color:#F9FFFE;}#mermaid-0 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:arial,sans-serif;font-size:12px;background:hsl(20, 1.5873015873%, 12.3529411765%);border:1px solid rgba(255, 255, 255, 0.25);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-0 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#ccc;}#mermaid-0 .label{line-height:normal;font-size:0.55rem;}#mermaid-0 :root{--mermaid-font-family:arial,sans-serif;}</style><g><marker orient=\"auto\" markerHeight=\"12\" markerWidth=\"12\" markerUnits=\"userSpaceOnUse\" refY=\"5\" refX=\"6\" viewBox=\"0 0 10 10\" class=\"marker flowchart\" id=\"mermaid-0_flowchart-pointEnd\"><path style=\"stroke-width: 1; stroke-dasharray: 1, 0;\" class=\"arrowMarkerPath\" d=\"M 0 0 L 10 5 L 0 10 z\"></path></marker><marker orient=\"auto\" markerHeight=\"12\" markerWidth=\"12\" markerUnits=\"userSpaceOnUse\" refY=\"5\" refX=\"4.5\" viewBox=\"0 0 10 10\" class=\"marker flowchart\" id=\"mermaid-0_flowchart-pointStart\"><path style=\"stroke-width: 1; stroke-dasharray: 1, 0;\" class=\"arrowMarkerPath\" d=\"M 0 5 L 10 10 L 10 0 z\"></path></marker><marker orient=\"auto\" markerHeight=\"11\" markerWidth=\"11\" markerUnits=\"userSpaceOnUse\" refY=\"5\" refX=\"11\" viewBox=\"0 0 10 10\" class=\"marker flowchart\" id=\"mermaid-0_flowchart-circleEnd\"><circle style=\"stroke-width: 1; stroke-dasharray: 1, 0;\" class=\"arrowMarkerPath\" r=\"5\" cy=\"5\" cx=\"5\"></circle></marker><marker orient=\"auto\" markerHeight=\"11\" markerWidth=\"11\" markerUnits=\"userSpaceOnUse\" refY=\"5\" refX=\"-1\" viewBox=\"0 0 10 10\" class=\"marker flowchart\" id=\"mermaid-0_flowchart-circleStart\"><circle style=\"stroke-width: 1; stroke-dasharray: 1, 0;\" class=\"arrowMarkerPath\" r=\"5\" cy=\"5\" cx=\"5\"></circle></marker><marker orient=\"auto\" markerHeight=\"11\" markerWidth=\"11\" markerUnits=\"userSpaceOnUse\" refY=\"5.2\" refX=\"12\" viewBox=\"0 0 11 11\" class=\"marker cross flowchart\" id=\"mermaid-0_flowchart-crossEnd\"><path style=\"stroke-width: 2; stroke-dasharray: 1, 0;\" class=\"arrowMarkerPath\" d=\"M 1,1 l 9,9 M 10,1 l -9,9\"></path></marker><marker orient=\"auto\" markerHeight=\"11\" markerWidth=\"11\" markerUnits=\"userSpaceOnUse\" refY=\"5.2\" refX=\"-1\" viewBox=\"0 0 11 11\" class=\"marker cross flowchart\" id=\"mermaid-0_flowchart-crossStart\"><path style=\"stroke-width: 2; stroke-dasharray: 1, 0;\" class=\"arrowMarkerPath\" d=\"M 1,1 l 9,9 M 10,1 l -9,9\"></path></marker><g class=\"root\"><g class=\"clusters\"></g><g class=\"edgePaths\"><path marker-end=\"url(#mermaid-0_flowchart-pointEnd)\" style=\"fill:none;\" class=\"edge-thickness-normal edge-pattern-solid flowchart-link LS-A LE-B\" id=\"L-A-B-0\" d=\"M210.387,25L210.387,29.167C210.387,33.333,210.387,41.667,210.387,49.117C210.387,56.567,210.387,63.133,210.387,66.417L210.387,69.7\"></path><path marker-end=\"url(#mermaid-0_flowchart-pointEnd)\" style=\"fill:none;\" class=\"edge-thickness-normal edge-pattern-solid flowchart-link LS-B LE-D\" id=\"L-B-D-0\" d=\"M159.416,100L139.028,105C118.639,110,77.863,120,57.474,129.117C37.086,138.233,37.086,146.467,37.086,150.583L37.086,154.7\"></path><path marker-end=\"url(#mermaid-0_flowchart-pointEnd)\" style=\"fill:none;\" class=\"edge-thickness-normal edge-pattern-solid flowchart-link LS-B LE-E\" id=\"L-B-E-0\" d=\"M195.937,100L190.157,105C184.377,110,172.818,120,167.038,129.117C161.258,138.233,161.258,146.467,161.258,150.583L161.258,154.7\"></path><path marker-end=\"url(#mermaid-0_flowchart-pointEnd)\" style=\"fill:none;\" class=\"edge-thickness-normal edge-pattern-solid flowchart-link LS-B LE-F\" id=\"L-B-F-0\" d=\"M224.836,100L230.616,105C236.396,110,247.956,120,253.736,129.117C259.516,138.233,259.516,146.467,259.516,150.583L259.516,154.7\"></path><path marker-end=\"url(#mermaid-0_flowchart-pointEnd)\" style=\"fill:none;\" class=\"edge-thickness-normal edge-pattern-solid flowchart-link LS-B LE-G\" id=\"L-B-G-0\" d=\"M253.949,100L271.375,105C288.8,110,323.65,120,341.075,129.117C358.5,138.233,358.5,146.467,358.5,150.583L358.5,154.7\"></path></g><g class=\"edgeLabels\"><g class=\"edgeLabel\"><g transform=\"translate(0, 0)\" class=\"label\"><foreignObject height=\"0\" width=\"0\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"edgeLabel\"></span></div></foreignObject></g></g><g transform=\"translate(37.0859375, 130)\" class=\"edgeLabel\"><g transform=\"translate(-14.09375, -5)\" class=\"label\"><foreignObject height=\"10\" width=\"28.1875\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"edgeLabel\">Worker</span></div></foreignObject></g></g><g transform=\"translate(161.2578125, 130)\" class=\"edgeLabel\"><g transform=\"translate(-14.09375, -5)\" class=\"label\"><foreignObject height=\"10\" width=\"28.1875\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"edgeLabel\">Worker</span></div></foreignObject></g></g><g transform=\"translate(259.515625, 130)\" class=\"edgeLabel\"><g transform=\"translate(-14.09375, -5)\" class=\"label\"><foreignObject height=\"10\" width=\"28.1875\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"edgeLabel\">Worker</span></div></foreignObject></g></g><g transform=\"translate(358.5, 130)\" class=\"edgeLabel\"><g transform=\"translate(-14.09375, -5)\" class=\"label\"><foreignObject height=\"10\" width=\"28.1875\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"edgeLabel\">Worker</span></div></foreignObject></g></g></g><g class=\"nodes\"><g transform=\"translate(210.38671875, 12.5)\" data-id=\"A\" data-node=\"true\" id=\"flowchart-A-0\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"62.578125\" y=\"-12.5\" x=\"-31.2890625\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-23.7890625, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"47.578125\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">Transformer</span></div></foreignObject></g></g><g transform=\"translate(210.38671875, 87.5)\" data-id=\"B\" data-node=\"true\" id=\"flowchart-B-1\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"125.140625\" y=\"-12.5\" x=\"-62.5703125\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-55.0703125, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"110.140625\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">WorkerFarm (w/JestWorker)</span></div></foreignObject></g></g><g transform=\"translate(37.0859375, 172.5)\" data-id=\"D\" data-node=\"true\" id=\"flowchart-D-3\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"74.171875\" y=\"-12.5\" x=\"-37.0859375\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-29.5859375, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"59.171875\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">Child Process1</span></div></foreignObject></g></g><g transform=\"translate(161.2578125, 172.5)\" data-id=\"E\" data-node=\"true\" id=\"flowchart-E-5\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"74.171875\" y=\"-12.5\" x=\"-37.0859375\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-29.5859375, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"59.171875\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">Child Process2</span></div></foreignObject></g></g><g transform=\"translate(259.515625, 172.5)\" data-id=\"F\" data-node=\"true\" id=\"flowchart-F-7\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"22.34375\" y=\"-12.5\" x=\"-11.171875\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-3.671875, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"7.34375\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">...</span></div></foreignObject></g></g><g transform=\"translate(358.5, 172.5)\" data-id=\"G\" data-node=\"true\" id=\"flowchart-G-9\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"75.625\" y=\"-12.5\" x=\"-37.8125\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-30.3125, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"60.625\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">Child ProcessN</span></div></foreignObject></g></g></g></g></g></svg></p>\n<p>변환 작업을 생성하고 포크된 하위 프로세스로 작업을 제공하는 전개 과정을 담은 구현체의 시작점은 <a href=\"https://github.com/facebook/metro/blob/v0.80.9/packages/metro/src/DeltaBundler/Transformer.js#L27\">Transformer</a>이다.\n가장 먼저 <code class=\"language-text\">Transformer</code> 클래스를 보면 인스턴스를 초기화하는 과정에서 <code class=\"language-text\">WorkerFarm</code> 인스턴스를 생성하여 내부적으로 참조할 수 있도록 구성한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/DeltaBundler/Transformer.js#L27\nconst WorkerFarm = require(&#39;./WorkerFarm&#39;);\n\nclass Transformer {\n  ...\n  _workerFarm: WorkerFarm;\n  constructor(config: ConfigT, getSha1Fn: string =&gt; string) {\n    ...\n    // &#39;WorkFarm&#39; 인스턴스를 생성한다.\n    this._workerFarm = new WorkerFarm(config, transformerOptions);\n    ...\n  }\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>그럼 <code class=\"language-text\">WorkerFarm</code>의 인스턴스는 어떻게 초기화되고 있을까. <code class=\"language-text\">WorkFarm</code>은 <code class=\"language-text\">_makeFarm()</code>를 통해 내부적으로 참조 가능한 <code class=\"language-text\">Worker</code>를 구성하고 있는데,\n<code class=\"language-text\">_makeFarm()</code>의 반환 결과를 통해 <code class=\"language-text\">WorkerFarm</code>이 <code class=\"language-text\">JestWorker</code>를 기반으로 하고 있음을 확인할 수 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/DeltaBundler/WorkerFarm.js#L34\nconst { Worker: JestWorker } = require(&quot;jest-worker&quot;);\n\nclass WorkerFarm {\n  constructor(config, transformerConfig) {\n    ...\n    const worker = this._makeFarm(\n      absoluteWorkerPath,\n      [&quot;transform&quot;],\n      this._config.maxWorkers\n    );\n    ...\n    this._worker = worker;\n  }\n  ...\n  _makeFarm(\n    absoluteWorkerPath: string,\n    exposedMethods: $ReadOnlyArray&lt;string&gt;,\n    numWorkers: number,\n  ): any {\n    const env = {\n      ...process.env,\n      FORCE_COLOR: 1,\n    };\n\n    return new JestWorker(absoluteWorkerPath, {\n      computeWorkerKey: this._config.stickyWorkers\n        ? this._computeWorkerKey\n        : undefined,\n      exposedMethods,\n      enableWorkerThreads: this._config.transformer.unstable_workerThreads,\n      forkOptions: {env},\n      numWorkers,\n    });\n  }\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>흔히 테스트 도구로 잘 알려진 <code class=\"language-text\">jest</code> 패키지 중 하나인 <a href=\"https://github.com/jestjs/jest/tree/v30.0.0-alpha.5/packages/jest-worker\">jest-worker</a>는\n<code class=\"language-text\">Metro</code>에서 무거운 변환 작업을 포크된 여러 개의 하위 프로세스에서 병렬적으로 처리하기 위한 메커니즘의 실제 솔루션이며, 이를 <code class=\"language-text\">WorkerFarm</code>에 담아낸 것이다.\n참고로 <code class=\"language-text\">jest-worker</code>는 <code class=\"language-text\">node.js</code>의 <a href=\"https://nodejs.org/api/worker_threads.html\">worker_threads</a>를 사용하고 있다.</p>\n<p><em>외람된 이야기지만, 위에서 본 <a href=\"https://github.com/facebook/metro/tree/v0.80.9/packages/metro-file-map\">metro-file-map</a>도\n<a href=\"https://github.com/jestjs/jest/tree/v30.0.0-alpha.5/packages/jest-haste-map\">jest-haste-map</a>을 포크하여 구성한 패키지라고 한다.</em></p>\n<p><code class=\"language-text\">WorkerFarm</code>에서 <code class=\"language-text\">JestWorker</code> 인스턴스를 생성하고 사용하기 위해 전달하는 파라미터들을 살펴보자. <code class=\"language-text\">jest-worker</code>에서 제공하는\n<a href=\"https://github.com/jestjs/jest/tree/v30.0.0-alpha.5/packages/jest-worker#file-parentjs-1\">사용 예시</a>와 비교해서 살펴보면 쉽게\n이해할 수 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/DeltaBundler/WorkerFarm.js#L110\nreturn new JestWorker(absoluteWorkerPath, {\n  computeWorkerKey: this._config.stickyWorkers\n    ? this._computeWorkerKey\n    : undefined,\n  exposedMethods, // [&quot;transform&quot;]\n  enableWorkerThreads: this._config.transformer.unstable_workerThreads,\n  forkOptions: { env },\n  numWorkers,\n});</code>\n        </deckgo-highlight-code>\n<p>가장 먼저 <code class=\"language-text\">absoluteWorkerPath</code>를 통해 <code class=\"language-text\">Worker</code>의 절대 경로를 제공한다. 여기서 <code class=\"language-text\">Worker</code>는 포크된 하위 프로세스에서 진행할 작업에 대한 구조체 정의가\n담겨 있으며 이를 <code class=\"language-text\">JestWorker</code>에게 제공하여 병렬적으로 작업을 수행할 수 있도록 한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// https://github.com/jestjs/jest/tree/v30.0.0-alpha.5/packages/jest-worker#file-parentjs\nimport { Worker as JestWorker } from &#39;jest-worker&#39;;\n\nasync function main() {\n  const worker = new JestWorker(require.resolve(&#39;./worker&#39;));\n  const result = await worker.hello(&#39;Alice&#39;); // &quot;Hello, Alice&quot;\n}\n\nmain();</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// https://github.com/jestjs/jest/tree/v30.0.0-alpha.5/packages/jest-worker#file-workerjs\nexport function hello(param) {\n  return `Hello, ${param}`;\n}</code>\n        </deckgo-highlight-code>\n<p>실제 <code class=\"language-text\">WorkerFarm</code>에서 제공하는 <code class=\"language-text\">absoluteWorkerPath</code>는 다음과 같으며, <a href=\"https://github.com/facebook/metro/blob/v0.80.9/packages/metro/src/DeltaBundler/Worker.flow.js\">Worker.flow.js</a>에서\n<code class=\"language-text\">JestWorker</code>에게 전달할 변환 작업에 대한 구조체를 정의하고 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">console.log(absoluteWorkerPath);\n// `{root}/{project}/node_modules/metro/src/DeltaBundler/Worker.js`</code>\n        </deckgo-highlight-code>\n<p>다음은 <code class=\"language-text\">exposedMethods</code>이다. 이는 <code class=\"language-text\">Worker</code>의 특정 메서드들을 노출시켜 <code class=\"language-text\">JestWorker</code>의 하위 프로세스들이 작업을 진행할 때 호출하여 사용할 수 있도록\n명시적으로 제공하는 파라미터이다. <code class=\"language-text\">WorkerFarm</code>에서는 <code class=\"language-text\">transform</code> 메서드를 노출시키고 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/DeltaBundler/WorkerFarm.js#L45\nconst worker = this._makeFarm(\n  absoluteWorkerPath,\n  [&#39;transform&#39;], // exposedMethods\n  this._config.maxWorkers\n);</code>\n        </deckgo-highlight-code>\n<p>마지막으로 살펴볼 파라미터는 <code class=\"language-text\">computeWorkerKey</code>이다. <code class=\"language-text\">Worker</code>라 일컫는 각각의 하위 프로세스들은 진행했던 작업 결과를 캐싱하게 되는데,\n가령 첫 번째 <code class=\"language-text\">Worker</code>가 <code class=\"language-text\">/tmp/foo.js</code> 파일에 대한 변환 작업을 완료하고 해당 결과를 캐싱하고 있다고 가정해 보자. 이후 동일한 <code class=\"language-text\">/tmp/foo.js</code> 파일의\n변환 작업이 트리거 된다면, 첫 번째 <code class=\"language-text\">Worker</code>에게 할당되어 즉시 캐시를 반환받는 것이 가장 유리하다. 이처럼 동일한 작업은 동일한 <code class=\"language-text\">Worker</code>에게 할당될 수 있도록\n보장하기 위해 사용되는 키이다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// https://github.com/jestjs/jest/tree/v30.0.0-alpha.5/packages/jest-worker#file-parentjs-2\nimport { Worker as JestWorker } from &#39;jest-worker&#39;;\n\nasync function main() {\n  const myWorker = new JestWorker(require.resolve(&#39;./worker&#39;), {\n    // 파일명을 &#39;computeWorkerKey&#39;로 사용한다.\n    computeWorkerKey: (method, filename) =&gt; filename,\n  });\n\n  // &#39;/tmp/foo.js&#39; 변환 작업 진행을 요청한다.\n  console.log(await myWorker.transform(&#39;/tmp/foo.js&#39;));\n\n  // Wait a bit.\n  await sleep(10_000);\n\n  // &#39;/tmp/foo.js&#39; 변환 작업 진행을 다시 요청한다.\n  // &#39;computeWorkerKey&#39;를 통해 해당 작업에 대한 캐시를 가진 &#39;Worker&#39;에게\n  // 해당 작업이 할당되며, `Worker`는 즉시 캐시를 반환한다.\n  console.log(await myWorker.transform(&#39;/tmp/foo.js&#39;));\n\n  const { forceExited } = await myWorker.end();\n  if (forceExited) {\n    console.error(&#39;Workers failed to exit gracefully&#39;);\n  }\n}\n\nmain();</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">jest</code>에서 제공하는 위 예시에서 파일명을 <code class=\"language-text\">computeWorkerKey</code>로 사용하고 있다. 마찬가지로 <code class=\"language-text\">WorkerFarm</code>에서도 <code class=\"language-text\">computeWorkerKey</code>를 파일명으로\n설정하고 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/DeltaBundler/WorkerFarm.js#L134\nclass WorkerFarm {\n  ...\n  _computeWorkerKey(method, filename) {\n    if (method === &quot;transform&quot;) {\n      return filename;\n    }\n    return null;\n  }\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>여기까지 <code class=\"language-text\">WorkerFarm</code>에서 변환 작업을 처리하는 메커니즘에 대해 알아보았다. 이제 <code class=\"language-text\">JestWorker</code>에게 제공되는 <code class=\"language-text\">Worker</code>의 <code class=\"language-text\">transform()</code>을 살펴보자.\n변환 과정에서 코드상의 패키지 스위칭이 있어 혼란스러울 수 있을 것 같아 흐름 도면을 잠시 살펴보고 실제 변환이 어떻게 이루어지는지 따라가 보자.</p>\n<p><svg aria-roledescription=\"flowchart-v2\" role=\"graphics-document document\" viewBox=\"-8 -8 430.609375 416\" style=\"max-width: 430.609375px;\" xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" id=\"mermaid-1\"><style>#mermaid-1{font-family:arial,sans-serif;font-size:16px;fill:#ccc;}#mermaid-1 .error-icon{fill:#a44141;}#mermaid-1 .error-text{fill:#ddd;stroke:#ddd;}#mermaid-1 .edge-thickness-normal{stroke-width:2px;}#mermaid-1 .edge-thickness-thick{stroke-width:3.5px;}#mermaid-1 .edge-pattern-solid{stroke-dasharray:0;}#mermaid-1 .edge-pattern-dashed{stroke-dasharray:3;}#mermaid-1 .edge-pattern-dotted{stroke-dasharray:2;}#mermaid-1 .marker{fill:lightgrey;stroke:lightgrey;}#mermaid-1 .marker.cross{stroke:lightgrey;}#mermaid-1 svg{font-family:arial,sans-serif;font-size:16px;}#mermaid-1 .label{font-family:arial,sans-serif;color:#ccc;}#mermaid-1 .cluster-label text{fill:#F9FFFE;}#mermaid-1 .cluster-label span,#mermaid-1 p{color:#F9FFFE;}#mermaid-1 .label text,#mermaid-1 span,#mermaid-1 p{fill:#ccc;color:#ccc;}#mermaid-1 .node rect,#mermaid-1 .node circle,#mermaid-1 .node ellipse,#mermaid-1 .node polygon,#mermaid-1 .node path{fill:#1f2020;stroke:#81B1DB;stroke-width:1px;}#mermaid-1 .flowchart-label text{text-anchor:middle;}#mermaid-1 .node .katex path{fill:#000;stroke:#000;stroke-width:1px;}#mermaid-1 .node .label{text-align:center;}#mermaid-1 .node.clickable{cursor:pointer;}#mermaid-1 .arrowheadPath{fill:lightgrey;}#mermaid-1 .edgePath .path{stroke:lightgrey;stroke-width:2.0px;}#mermaid-1 .flowchart-link{stroke:lightgrey;fill:none;}#mermaid-1 .edgeLabel{background-color:hsl(0, 0%, 34.4117647059%);text-align:center;}#mermaid-1 .edgeLabel rect{opacity:0.5;background-color:hsl(0, 0%, 34.4117647059%);fill:hsl(0, 0%, 34.4117647059%);}#mermaid-1 .labelBkg{background-color:rgba(87.75, 87.75, 87.75, 0.5);}#mermaid-1 .cluster rect{fill:hsl(180, 1.5873015873%, 28.3529411765%);stroke:rgba(255, 255, 255, 0.25);stroke-width:1px;}#mermaid-1 .cluster text{fill:#F9FFFE;}#mermaid-1 .cluster span,#mermaid-1 p{color:#F9FFFE;}#mermaid-1 div.mermaidTooltip{position:absolute;text-align:center;max-width:200px;padding:2px;font-family:arial,sans-serif;font-size:12px;background:hsl(20, 1.5873015873%, 12.3529411765%);border:1px solid rgba(255, 255, 255, 0.25);border-radius:2px;pointer-events:none;z-index:100;}#mermaid-1 .flowchartTitleText{text-anchor:middle;font-size:18px;fill:#ccc;}#mermaid-1 .label{line-height:normal;font-size:0.55rem;}#mermaid-1 :root{--mermaid-font-family:arial,sans-serif;}</style><g><marker orient=\"auto\" markerHeight=\"12\" markerWidth=\"12\" markerUnits=\"userSpaceOnUse\" refY=\"5\" refX=\"6\" viewBox=\"0 0 10 10\" class=\"marker flowchart\" id=\"mermaid-1_flowchart-pointEnd\"><path style=\"stroke-width: 1; stroke-dasharray: 1, 0;\" class=\"arrowMarkerPath\" d=\"M 0 0 L 10 5 L 0 10 z\"></path></marker><marker orient=\"auto\" markerHeight=\"12\" markerWidth=\"12\" markerUnits=\"userSpaceOnUse\" refY=\"5\" refX=\"4.5\" viewBox=\"0 0 10 10\" class=\"marker flowchart\" id=\"mermaid-1_flowchart-pointStart\"><path style=\"stroke-width: 1; stroke-dasharray: 1, 0;\" class=\"arrowMarkerPath\" d=\"M 0 5 L 10 10 L 10 0 z\"></path></marker><marker orient=\"auto\" markerHeight=\"11\" markerWidth=\"11\" markerUnits=\"userSpaceOnUse\" refY=\"5\" refX=\"11\" viewBox=\"0 0 10 10\" class=\"marker flowchart\" id=\"mermaid-1_flowchart-circleEnd\"><circle style=\"stroke-width: 1; stroke-dasharray: 1, 0;\" class=\"arrowMarkerPath\" r=\"5\" cy=\"5\" cx=\"5\"></circle></marker><marker orient=\"auto\" markerHeight=\"11\" markerWidth=\"11\" markerUnits=\"userSpaceOnUse\" refY=\"5\" refX=\"-1\" viewBox=\"0 0 10 10\" class=\"marker flowchart\" id=\"mermaid-1_flowchart-circleStart\"><circle style=\"stroke-width: 1; stroke-dasharray: 1, 0;\" class=\"arrowMarkerPath\" r=\"5\" cy=\"5\" cx=\"5\"></circle></marker><marker orient=\"auto\" markerHeight=\"11\" markerWidth=\"11\" markerUnits=\"userSpaceOnUse\" refY=\"5.2\" refX=\"12\" viewBox=\"0 0 11 11\" class=\"marker cross flowchart\" id=\"mermaid-1_flowchart-crossEnd\"><path style=\"stroke-width: 2; stroke-dasharray: 1, 0;\" class=\"arrowMarkerPath\" d=\"M 1,1 l 9,9 M 10,1 l -9,9\"></path></marker><marker orient=\"auto\" markerHeight=\"11\" markerWidth=\"11\" markerUnits=\"userSpaceOnUse\" refY=\"5.2\" refX=\"-1\" viewBox=\"0 0 11 11\" class=\"marker cross flowchart\" id=\"mermaid-1_flowchart-crossStart\"><path style=\"stroke-width: 2; stroke-dasharray: 1, 0;\" class=\"arrowMarkerPath\" d=\"M 1,1 l 9,9 M 10,1 l -9,9\"></path></marker><g class=\"root\"><g class=\"clusters\"></g><g class=\"edgePaths\"><path marker-end=\"url(#mermaid-1_flowchart-pointEnd)\" style=\"fill:none;\" class=\"edge-thickness-normal edge-pattern-solid flowchart-link LS-A LE-B\" id=\"L-A-B-0\" d=\"M171.492,25L171.492,29.167C171.492,33.333,171.492,41.667,171.492,49.117C171.492,56.567,171.492,63.133,171.492,66.417L171.492,69.7\"></path><path marker-end=\"url(#mermaid-1_flowchart-pointEnd)\" style=\"fill:none;\" class=\"edge-thickness-normal edge-pattern-solid flowchart-link LS-B LE-C\" id=\"L-B-C-0\" d=\"M171.492,100L171.492,104.167C171.492,108.333,171.492,116.667,171.492,124.117C171.492,131.567,171.492,138.133,171.492,141.417L171.492,144.7\"></path><path marker-end=\"url(#mermaid-1_flowchart-pointEnd)\" style=\"fill:none;\" class=\"edge-thickness-normal edge-pattern-solid flowchart-link LS-C LE-D\" id=\"L-C-D-0\" d=\"M171.492,175L171.492,179.167C171.492,183.333,171.492,191.667,171.492,199.117C171.492,206.567,171.492,213.133,171.492,216.417L171.492,219.7\"></path><path marker-end=\"url(#mermaid-1_flowchart-pointEnd)\" style=\"fill:none;\" class=\"edge-thickness-normal edge-pattern-solid flowchart-link LS-D LE-E\" id=\"L-D-E-0\" d=\"M142.484,245.82L125.527,250.683C108.57,255.546,74.656,265.273,57.699,273.42C40.742,281.567,40.742,288.133,40.742,291.417L40.742,294.7\"></path><path marker-end=\"url(#mermaid-1_flowchart-pointEnd)\" style=\"fill:none;\" class=\"edge-thickness-normal edge-pattern-solid flowchart-link LS-D LE-F\" id=\"L-D-F-0\" d=\"M171.492,250L171.492,254.167C171.492,258.333,171.492,266.667,171.492,274.117C171.492,281.567,171.492,288.133,171.492,291.417L171.492,294.7\"></path><path marker-end=\"url(#mermaid-1_flowchart-pointEnd)\" style=\"fill:none;\" class=\"edge-thickness-normal edge-pattern-solid flowchart-link LS-D LE-G\" id=\"L-D-G-0\" d=\"M200.5,245.044L219.698,250.037C238.896,255.029,277.292,265.015,296.49,273.291C315.688,281.567,315.688,288.133,315.688,291.417L315.688,294.7\"></path><path marker-end=\"url(#mermaid-1_flowchart-pointEnd)\" style=\"fill:none;\" class=\"edge-thickness-normal edge-pattern-solid flowchart-link LS-G LE-H\" id=\"L-G-H-0\" d=\"M315.688,325L315.688,329.167C315.688,333.333,315.688,341.667,315.688,349.117C315.688,356.567,315.688,363.133,315.688,366.417L315.688,369.7\"></path></g><g class=\"edgeLabels\"><g class=\"edgeLabel\"><g transform=\"translate(0, 0)\" class=\"label\"><foreignObject height=\"0\" width=\"0\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"edgeLabel\"></span></div></foreignObject></g></g><g class=\"edgeLabel\"><g transform=\"translate(0, 0)\" class=\"label\"><foreignObject height=\"0\" width=\"0\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"edgeLabel\"></span></div></foreignObject></g></g><g class=\"edgeLabel\"><g transform=\"translate(0, 0)\" class=\"label\"><foreignObject height=\"0\" width=\"0\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"edgeLabel\"></span></div></foreignObject></g></g><g class=\"edgeLabel\"><g transform=\"translate(0, 0)\" class=\"label\"><foreignObject height=\"0\" width=\"0\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"edgeLabel\"></span></div></foreignObject></g></g><g class=\"edgeLabel\"><g transform=\"translate(0, 0)\" class=\"label\"><foreignObject height=\"0\" width=\"0\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"edgeLabel\"></span></div></foreignObject></g></g><g class=\"edgeLabel\"><g transform=\"translate(0, 0)\" class=\"label\"><foreignObject height=\"0\" width=\"0\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"edgeLabel\"></span></div></foreignObject></g></g><g class=\"edgeLabel\"><g transform=\"translate(0, 0)\" class=\"label\"><foreignObject height=\"0\" width=\"0\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"edgeLabel\"></span></div></foreignObject></g></g></g><g class=\"nodes\"><g transform=\"translate(171.4921875, 12.5)\" data-id=\"A\" data-node=\"true\" id=\"flowchart-A-10\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"96.5\" y=\"-12.5\" x=\"-48.25\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-40.75, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"81.5\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">DeltaBundler/Worker</span></div></foreignObject></g></g><g transform=\"translate(171.4921875, 87.5)\" data-id=\"B\" data-node=\"true\" id=\"flowchart-B-11\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"72.1875\" y=\"-12.5\" x=\"-36.09375\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-28.59375, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"57.1875\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">transformFile()</span></div></foreignObject></g></g><g transform=\"translate(171.4921875, 162.5)\" data-id=\"C\" data-node=\"true\" id=\"flowchart-C-13\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"171.578125\" y=\"-12.5\" x=\"-85.7890625\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-78.2890625, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"156.578125\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">Transformer (w/metro-transform-worker)</span></div></foreignObject></g></g><g transform=\"translate(171.4921875, 237.5)\" data-id=\"D\" data-node=\"true\" id=\"flowchart-D-15\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"58.015625\" y=\"-12.5\" x=\"-29.0078125\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-21.5078125, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"43.015625\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">transform()</span></div></foreignObject></g></g><g transform=\"translate(40.7421875, 312.5)\" data-id=\"E\" data-node=\"true\" id=\"flowchart-E-17\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"81.484375\" y=\"-12.5\" x=\"-40.7421875\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-33.2421875, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"66.484375\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">transformJSON()</span></div></foreignObject></g></g><g transform=\"translate(171.4921875, 312.5)\" data-id=\"F\" data-node=\"true\" id=\"flowchart-F-19\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"80.015625\" y=\"-12.5\" x=\"-40.0078125\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-32.5078125, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"65.015625\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">transformAsset()</span></div></foreignObject></g></g><g transform=\"translate(315.6875, 312.5)\" data-id=\"G\" data-node=\"true\" id=\"flowchart-G-21\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"108.375\" y=\"-12.5\" x=\"-54.1875\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-46.6875, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"93.375\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">transformJSWithBabel()</span></div></foreignObject></g></g><g transform=\"translate(315.6875, 387.5)\" data-id=\"H\" data-node=\"true\" id=\"flowchart-H-23\" class=\"node default default flowchart-label\"><rect height=\"25\" width=\"197.84375\" y=\"-12.5\" x=\"-98.921875\" ry=\"0\" rx=\"0\" style=\"\" class=\"basic label-container\"></rect><g transform=\"translate(-91.421875, -5)\" style=\"\" class=\"label\"><rect></rect><foreignObject height=\"10\" width=\"182.84375\"><div style=\"display: inline-block; white-space: nowrap;\" xmlns=\"http://www.w3.org/1999/xhtml\"><span class=\"nodeLabel\">transformer (w/react-native-babel-transformer)]</span></div></foreignObject></g></g></g></g></g></svg></p>\n<p><code class=\"language-text\">DeltaBundler/Worker</code>의 <code class=\"language-text\">transform()</code>은 <code class=\"language-text\">transformFile()</code>을 반환하고 있다.</p>\n<deckgo-highlight-code language=\"ts\"  >\n          <code slot=\"code\">// metro/src/DeltaBundler/Worker.flow.js#L72\nasync function transform(\n  filename: string,\n  transformOptions: JsTransformOptions,\n  projectRoot: string,\n  transformerConfig: TransformerConfig,\n  fileBuffer?: Buffer,\n): Promise&lt;Data&gt; {\n  ...\n  return transformFile(\n    filename,\n    data,\n    transformOptions,\n    projectRoot,\n    transformerConfig,\n  );\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">transformFile()</code>에서는 <code class=\"language-text\">Transformer</code>을 정의하고 있는데, 실제 변환기는 <code class=\"language-text\">transformerConfig.transformerPath</code>에 제공된\n경로에 구현되어 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/DeltaBundler/Worker.flow.js#L96\nasync function transformFile(\n  filename: string,\n  data: Buffer,\n  transformOptions: JsTransformOptions,\n  projectRoot: string,\n  transformerConfig: TransformerConfig,\n): Promise&lt;Data&gt; {\n  const Transformer: TransformerInterface = require.call(\n    null,\n    transformerConfig.transformerPath,\n  );\n  ...\n  const result = await Transformer.transform(\n    transformerConfig.transformerConfig,\n    projectRoot,\n    filename,\n    data,\n    transformOptions,\n  );\n\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">transformerConfig.transformerPath</code>는 기본적으로 <code class=\"language-text\">metro-transform-worker</code>로 제공되는데, 이는 <a href=\"https://github.com/facebook/metro/blob/v0.80.9/packages/metro-config/src/defaults/index.js#L166\">metro-config</a>에서\n확인할 수 있다. 즉, <code class=\"language-text\">metro-transform-worker</code>에서 제공하는 <a href=\"https://github.com/facebook/metro/blob/v0.80.9/packages/metro-transform-worker/src/index.js#L601\">transform</a>을 통해 변환 작업을 진행하는 것이다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-transform-worker/src/index.js#L601\nmodule.exports = {\n  transform: async (\n    config: JsTransformerConfig,\n    projectRoot: string,\n    filename: string,\n    data: Buffer,\n    options: JsTransformOptions,\n  ): Promise&lt;TransformResponse&gt; =&gt; {\n    ...\n    // JSON 파일 변환\n    if (filename.endsWith(&#39;.json&#39;)) {\n      const jsonFile: JSONFile = {\n        filename,\n        inputFileSize: data.length,\n        code: sourceCode,\n        type: options.type,\n      };\n\n      return await transformJSON(jsonFile, context);\n    }\n\n    // ASSET 파일 변환\n    if (options.type === &#39;asset&#39;) {\n      const file: AssetFile = {\n        filename,\n        inputFileSize: data.length,\n        code: sourceCode,\n        type: options.type,\n      };\n\n      return await transformAsset(file, context);\n    }\n\n    // 자바스크립트 파일 변환\n    const file: JSFile = {\n      filename,\n      inputFileSize: data.length,\n      code: sourceCode,\n      type: options.type === &#39;script&#39; ? &#39;js/script&#39; : &#39;js/module&#39;,\n      functionMap: null,\n    };\n\n    return await transformJSWithBabel(file, context);\n  }\n  ...</code>\n        </deckgo-highlight-code>\n<h3 id=\"json-파일-변환\" style=\"position:relative;\"><a href=\"#json-%ED%8C%8C%EC%9D%BC-%EB%B3%80%ED%99%98\" aria-label=\"json 파일 변환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JSON 파일 변환</h3>\n<p>변환의 대상 파일명이 <code class=\"language-text\">.json</code>로 끝나는 경우, <code class=\"language-text\">transformJSON()</code>을 통해 파일 코드를 변환하게 된다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-transform-worker/src/index.js#L526\nasync function transformJSON(file, { options, config, projectRoot }) {\n  // &#39;JSON&#39; 파일 코드를 변환한다.\n  let code =\n    config.unstable_disableModuleWrapping === true\n      ? JsFileWrapping.jsonToCommonJS(file.code)\n      : JsFileWrapping.wrapJson(file.code, config.globalPrefix);\n\n  // 변환 결과물 최소화 옵션이 켜져 있다면 코드를 최소화한다.\n  if (minify) {\n    ({ map, code } = await minifyCode(...);\n  }\n\n  ...\n  const output = [\n    {\n      data: {\n        code,\n        lineCount,\n        map,\n        functionMap: null,\n      },\n      type: jsType,\n    },\n  ];\n  return {\n    dependencies: [],\n    output,\n  };\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">JSON</code> 파일의 변환 과정은 비교적 간단하다. 파일에 작성되어 있는 코드를 <code class=\"language-text\">jsonToCommonJS()</code>를 통해 모듈 내보내기 구문으로 래핑하고, 이를 <code class=\"language-text\">wrapJson()</code>을\n통해 <code class=\"language-text\">__d</code>라는 함수로 래핑한다. 여기서 <code class=\"language-text\">__d</code>는 <code class=\"language-text\">Metro</code> 번들에서 사용되는 모듈을 정의하고 서로 참조할 수 있도록 구성하는 함수이다. 이는 Metro 모듈 정의 함수로서\n<a href=\"https://github.com/facebook/metro/blob/v0.80.9/packages/metro-runtime/src/polyfills/require.js#L88\">metro-runtime</a>의 <code class=\"language-text\">require.js</code> 폴리필을 통해 제공된다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/ModuleGraph/worker/JsFileWrapping.js#L63\nfunction jsonToCommonJS(source: string): string {\n  return `module.exports = ${source};`;\n}\n\nfunction wrapJson(source: string, globalPrefix: string): string {\n  const moduleFactoryParameters = buildParameters(\n    &#39;_importDefaultUnused&#39;,\n    &#39;_importAllUnused&#39;,\n    &#39;_dependencyMapUnused&#39;\n  );\n\n  return [\n    `${globalPrefix}__d(function(${moduleFactoryParameters.join(&#39;, &#39;)}) {`,\n    `  ${jsonToCommonJS(source)}`,\n    &#39;});&#39;,\n  ].join(&#39;\\n&#39;);\n}</code>\n        </deckgo-highlight-code>\n<p>예시로 <code class=\"language-text\">profile.json</code>은 다음과 같은 코드 변환 결과를 얻게 된다.</p>\n<deckgo-highlight-code language=\"json\"  >\n          <code slot=\"code\">// profile.json\n{\n  &quot;name&quot;: &quot;Yoo&quot;,\n  &quot;age&quot;: 29\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">__d(function(global, require, _importDefaultUnused, _importAllUnused, module, exports, _dependencyMapUnused) {\n  module.exports = {\n    &quot;name&quot;: &#39;Yoo&#39;,\n    &quot;age&quot;: 29\n  }\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"asset-파일-변환\" style=\"position:relative;\"><a href=\"#asset-%ED%8C%8C%EC%9D%BC-%EB%B3%80%ED%99%98\" aria-label=\"asset 파일 변환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ASSET 파일 변환</h3>\n<p>다음은 <code class=\"language-text\">ASSET</code> 파일의 변환이다. 이는 <code class=\"language-text\">transformAsset()</code>이 담당하며 <code class=\"language-text\">options.type</code>이 <code class=\"language-text\">asset</code>인 경우에 해당한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-transform-worker/src/index.js#L473\nasync function transformAsset(file, context) {\n  const assetTransformer = require(&#39;./utils/assetTransformer&#39;);\n  const { assetRegistryPath, assetPlugins } = context.config;\n  const result = await assetTransformer.transform(\n    getBabelTransformArgs(file, context),\n    assetRegistryPath,\n    assetPlugins\n  );\n  const jsFile = {\n    ...file,\n    type: &#39;js/module/asset&#39;,\n    ast: result.ast,\n    functionMap: null,\n  };\n  return transformJS(jsFile, context);\n}</code>\n        </deckgo-highlight-code>\n<p>여기서 <code class=\"language-text\">assetTransformer</code>의 <code class=\"language-text\">transform()</code>은 <code class=\"language-text\">getAssetData()</code>를 통해 에셋의 해시값, 높이, 너비, 크기 등 메타데이터들을 읽어온다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-transform-worker/src/utils/assetTransformer.js\nasync function transform(\n  {filename, options, src}: BabelTransformerArgs,\n  assetRegistryPath: string,\n  assetDataPlugins: $ReadOnlyArray&lt;string&gt;,\n): Promise&lt;{ast: File, ...}&gt; {\n  ...\n  const absolutePath = path.resolve(options.projectRoot, filename);\n\n  const data = await getAssetData(\n    absolutePath,\n    filename,\n    assetDataPlugins,\n    options.platform,\n    options.publicPath,\n  );\n\n  return {\n    ast: generateAssetCodeFileAst(assetRegistryPath, data),\n  };\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/Assets.js#L220\nasync function getAssetData(\n  assetPath,\n  localPath,\n  assetDataPlugins,\n  platform = null,\n  publicPath\n) {\n  ...\n  const assetData = {\n    __packager_asset: true,\n    fileSystemLocation: path.dirname(assetPath),\n    httpServerLocation: assetUrlPath,\n    width: dimensions ? dimensions.width / scale : undefined,\n    height: dimensions ? dimensions.height / scale : undefined,\n    scales: assetInfo.scales,\n    files: assetInfo.files,\n    hash: assetInfo.hash,\n    name: assetInfo.name,\n    type: assetInfo.type,\n  };\n  return await applyAssetDataPlugins(assetDataPlugins, assetData);\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">getAssetData()</code>에서는 에셋의 메타데이터를 구하기 위해 <code class=\"language-text\">applyAssetDataPlugins()</code>에 에셋 데이터를 전달해 호출하는데 이는 <a href=\"https://metrobundler.dev/docs/configuration/#assetplugins\">assetPlugins</a>\n설정에 적용한 에셋을 위한 플러그인들을 통해 메타데이터를 구해내기 위한 과정이다. 실제로 <code class=\"language-text\">applyAssetDataPlugins()</code>에서는 에셋을 처리하기 위해\n플러그인들을 재귀적으로 순회하면서 메타데이터를 구한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/Assets.js#L263\nasync function applyAssetDataPlugins(assetDataPlugins, assetData) {\n  if (!assetDataPlugins.length) {\n    return assetData;\n  }\n  const [currentAssetPlugin, ...remainingAssetPlugins] = assetDataPlugins;\n  const assetPluginFunction = require(currentAssetPlugin);\n  const resultAssetData = await assetPluginFunction(assetData);\n  return await applyAssetDataPlugins(remainingAssetPlugins, resultAssetData);\n}</code>\n        </deckgo-highlight-code>\n<p>최종적으로 구해진 메타데이터는 추상 구문 트리로 패키징 되는데, <code class=\"language-text\">AssetRegistry</code>에 해당 에셋을 등록하는 구문이 상단에 추가된다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/Bundler/util.js#L29\nfunction generateAssetCodeFileAst(\n  assetRegistryPath: string,\n  assetDescriptor: AssetDataWithoutFiles\n): File {\n  const properDescriptor = filterObject(\n    assetDescriptor,\n    assetPropertyBlockList\n  );\n\n  const descriptorAst = babylon.parseExpression(\n    JSON.stringify(properDescriptor)\n  );\n  const t = babelTypes;\n\n  // ast로 패키징된 에셋을 저장하는 구문을 이어붙인다.\n  // require(&#39;AssetRegistry&#39;).registerAsset({...})\n  const buildRequire = template.statement(`\n    module.exports = require(ASSET_REGISTRY_PATH).registerAsset(DESCRIPTOR_AST)\n  `);\n\n  // 구해진 에셋의 메타데이터를 통해 &#39;AssetRegistry&#39;에 에셋을 등록하는 구문을 포함하여 추상 구문 트리를 반환한다.\n  return t.file(\n    t.program([\n      buildRequire({\n        ASSET_REGISTRY_PATH: t.stringLiteral(assetRegistryPath),\n        DESCRIPTOR_AST: descriptorAst,\n      }),\n    ])\n  );\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">AssetRegistry</code>에 등록된 에셋은 내부 <code class=\"language-text\">assets</code> 배열에 추가되고, 해당 인덱스를 반환받게 되는데, 비즈니스 로직에서 이미지를 요청하는 경우 에셋이 등록된\n인덱스를 통해 해당 에셋의 메타데이터와 실제 주소를 가져와 랜더링하게 된다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// https://github.com/facebook/react-native/blob/v0.74.2/packages/assets/registry.js#L28\nfunction registerAsset(asset: PackagerAsset): number {\n  return assets.push(asset);\n}\n\nfunction getAssetByID(assetId: number): PackagerAsset {\n  return assets[assetId - 1];\n}\n\nmodule.exports = { registerAsset, getAssetByID };</code>\n        </deckgo-highlight-code>\n<p>마지막으로 에셋 정보를 담은 추상 구문 트리를 <code class=\"language-text\">transformJS()</code>를 통해 변환한다. 에셋이 변환된 결과도 마찬가지로 모듈을 정의하는 <code class=\"language-text\">__d</code> 함수로\n래핑된 것을 볼 수 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-transform-worker/src/index.js#L473\nasync function transformAsset(file, context) {\n  ...\n  return transformJS(jsFile, context);\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {\n  module.exports = _$$_REQUIRE(_dependencyMap[0], &quot;react-native/Libraries/Image/AssetRegistry&quot;).registerAsset({\n    &quot;__packager_asset&quot;: true,\n    &quot;httpServerLocation&quot;: &quot;/assets/node_modules/react-native/Libraries/LogBox/UI/LogBoxImages&quot;,\n    &quot;width&quot;: 44,\n    &quot;height&quot;: 44,\n    &quot;scales&quot;: [1],\n    &quot;hash&quot;: &quot;817aca47ff3cea63020753d336e628a4&quot;,\n    &quot;name&quot;: &quot;loader&quot;,\n    &quot;type&quot;: &quot;png&quot;\n  })\n}</code>\n        </deckgo-highlight-code>\n<h3 id=\"자바스크립트-파일-변환\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8-%ED%8C%8C%EC%9D%BC-%EB%B3%80%ED%99%98\" aria-label=\"자바스크립트 파일 변환 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바스크립트 파일 변환</h3>\n<p>드디어 자바스크립트 소스 파일의 변환이다. 자바스크립트 변환은 <code class=\"language-text\">transformJSWithBabel()</code>이 담당한다. 이때 자바스크립트 소스 파일을 변환을 담당하는 <code class=\"language-text\">transformer</code>는\n기본적으로 <a href=\"https://github.com/facebook/metro/tree/v0.80.9/packages/metro-babel-transformer\">metro-babel-transformer</a>에 정의되어 있으며,\n리엑트 네이티브의 경우 <a href=\"https://github.com/facebook/react-native/tree/v0.74.2/packages/react-native-babel-transformer\">react-native-babel-tranformer</a>에서\n담당한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-transform-worker/src/index.js#L500\nasync function transformJSWithBabel(file, context) {\n  const { babelTransformerPath } = context.config;\n  const transformer = require(babelTransformerPath);\n  const transformResult = await transformer.transform(\n    getBabelTransformArgs(file, context, [functionMapBabelPlugin])\n  );\n  const jsFile = {\n    ...file,\n    ast: transformResult.ast,\n    functionMap:\n      transformResult.metadata?.metro?.functionMap ??\n      transformResult.functionMap ??\n      null,\n  };\n  return await transformJS(jsFile, context);\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">react-native-babel-transformer</code>의 <code class=\"language-text\">transform()</code>은 가장 먼저 적절한 <code class=\"language-text\">babelConfig</code>를 구성하여 <code class=\"language-text\">@babel/core</code>의 <code class=\"language-text\">parseSync()</code>를 통해\n추상 구문 트리를 구한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// https://github.com/facebook/react-native/blob/v0.74.2/packages/react-native-babel-transformer/src/index.js#L180\nconst {parseSync, transformFromAstSync} = require(&#39;@babel/core&#39;);\n\nconst transform = ({\n  filename,\n  options,\n  src,\n  plugins,\n}) =&gt; {\n  ...\n  try {\n    const babelConfig = {\n      sourceType: &#39;unambiguous&#39;,\n      // &#39;buildBabelConfig()&#39; 호출을 통해 반환된 속성\n      ...buildBabelConfig(filename, options, plugins),\n      caller: {name: &#39;metro&#39;, bundler: &#39;metro&#39;, platform: options.platform},\n      ast: true,\n      cloneInputAst: false,\n    };\n\n    const sourceAst =\n      isTypeScriptSource(filename) ||\n      isTSXSource(filename) ||\n      !options.hermesParser\n        ? parseSync(src, babelConfig)\n        : require(&#39;hermes-parser&#39;).parse(src, {\n          babel: true,\n          sourceType: babelConfig.sourceType,\n        });\n    ...\n  }\n};</code>\n        </deckgo-highlight-code>\n<p>여기서 <a href=\"https://github.com/facebook/react-native/blob/v0.74.2/packages/react-native-babel-transformer/src/index.js#L128\">buildBabelConfig()</a>에서 반환되어 <code class=\"language-text\">babelConfig</code>로 설정되는 과정에 주목해보자.\n잠시 살펴볼 두 가지 과정이 있다. 그 중 첫 번째는, <code class=\"language-text\">.babelrc</code>, <code class=\"language-text\">.babelrc.js</code>, <code class=\"language-text\">babel.config.js</code>을 찾아 프로젝트에서 작성된 <code class=\"language-text\">babel</code> 속성 정보를 찾는 단계이다.</p>\n<p><code class=\"language-text\">getBabelRC()</code> 코드를 따로 첨부하진 않았지만, 만약 <code class=\"language-text\">babel</code> 속성 정의를 위한 세 가지 케이스의 파일이 프로젝트 상단에 작성되어 있지 않다면,\n리엑트 네이티브에서 <code class=\"language-text\">babel</code>을 사용하기 위한 필수적인 프리셋인 <code class=\"language-text\">@react-native/babel-preset</code>이 명시된 속성이 대신 반환되는 코드가 포함되어 있다.\n이는 <code class=\"language-text\">babel</code> 속성이 작성되어 있지 않아도 리엑트 네이티브로 작성된 프로젝트가 문제없이 번들링을 생성할 수 있도록 하는 조치로 보인다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// react-native-babel-transformer/src/index.js#L128\nfunction buildBabelConfig(filename, options, plugins = []) {\n  // &#39;.babelrc&#39;, &#39;.babelrc.js&#39;, &#39;babel.config.js&#39; 파일을 찾는다.\n  // 만약 찾지 못했다면, 기본적인 프리셋인 &#39;@react-native/babel-preset&#39;이 적용된 속성이 대신 반환된다.\n  const babelRC = getBabelRC(options);\n  ...\n}</code>\n        </deckgo-highlight-code>\n<p>참고로, <a href=\"https://github.com/facebook/react-native/blob/v0.74.0/packages/react-native-babel-preset/src/configs/main.js\">react-native-babel-preset</a>에서 관리되는 프리셋은 리엑트 네이티브 패키지 생태계에서 사용되는 <a href=\"https://flow.org/\">flow</a> 구문을 제거하거나, Hermes 엔진에서 블록 스코프를 완전하게 지원하지 못하는 점을\n보완하기 위한 플러그인 등 다양한 플러그인들의 모음이다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// react-native-babel-preset/src/configs/main.js#L27\nconst defaultPlugins = [\n  [require(&#39;@babel/plugin-syntax-flow&#39;)],\n  [require(&#39;babel-plugin-transform-flow-enums&#39;)],\n  [require(&#39;@babel/plugin-transform-block-scoping&#39;)],\n  [require(&#39;@babel/plugin-proposal-class-properties&#39;), { loose }],\n  [require(&#39;@babel/plugin-transform-private-methods&#39;), { loose }],\n  [require(&#39;@babel/plugin-transform-private-property-in-object&#39;), { loose }],\n  [require(&#39;@babel/plugin-syntax-dynamic-import&#39;)],\n  [require(&#39;@babel/plugin-syntax-export-default-from&#39;)],\n  ...passthroughSyntaxPlugins,\n  [require(&#39;@babel/plugin-transform-unicode-regex&#39;)],\n];</code>\n        </deckgo-highlight-code>\n<p>두 번째는 개발 환경일 때 <code class=\"language-text\">Hot Module Replacement</code>를 위해 <a href=\"https://github.com/facebook/react/blob/v18.2.0/packages/react-refresh/src/ReactFreshBabelPlugin.js\">ReactFreshBabelPlugin</a>이 주입하여 개발 생산성을 보장하고 있다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// react-native-babel-transformer/src/index.js#L128\nfunction buildBabelConfig(\n  filename,\n  options,\n  plugins = [],\n) {\n  ...\n  if (options.dev &amp;&amp; options.hot) {\n    const mayContainEditableReactComponents =\n      filename.indexOf(&#39;node_modules&#39;) === -1;\n\n    if (mayContainEditableReactComponents) {\n      const hmrConfig = makeHMRConfig();\n      hmrConfig.plugins = withExtraPlugins.concat(hmrConfig.plugins);\n      config = {...config, ...hmrConfig};\n    }\n  }\n\n  return {\n    ...babelRC,\n    ...config,\n  };\n}</code>\n        </deckgo-highlight-code>\n<p>최종적으로 <code class=\"language-text\">react-native-babel-transformer</code>의 <code class=\"language-text\">transform</code>에서는 <code class=\"language-text\">@babel/core</code>의 <code class=\"language-text\">transformFromAstSync()</code>를 통해 얻어진 변환된 결과물을\n반환한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// react-native-babel-transformer/src/index.js#L180\nconst transform = ({\n  filename,\n  options,\n  src,\n  plugins,\n}) =&gt; {\n  ...\n  try {\n    const result = transformFromAstSync(sourceAst, src, babelConfig);\n\n    if (!result) {\n      return {ast: null};\n    }\n\n    return {ast: nullthrows(result.ast), metadata: result.metadata};\n  }\n};</code>\n        </deckgo-highlight-code>\n<p>다시 <code class=\"language-text\">transformJSWithBabel()</code>로 돌아가서 살펴보자. 위 과정을 통해 구해진 <code class=\"language-text\">transformResult</code>를 통해 파일 데이터를 구성하고, <code class=\"language-text\">transformJS()</code>에\n전달한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-transform-worker/src/index.js#L500\nasync function transformJSWithBabel(file, context) {\n  const { babelTransformerPath } = context.config;\n  const transformer = require(babelTransformerPath);\n  const transformResult = await transformer.transform(\n    getBabelTransformArgs(file, context, [functionMapBabelPlugin])\n  );\n  const jsFile = {\n    ...file,\n    ast: transformResult.ast,\n    functionMap:\n      transformResult.metadata?.metro?.functionMap ??\n      transformResult.functionMap ??\n      null,\n  };\n  return await transformJS(jsFile, context);\n}</code>\n        </deckgo-highlight-code>\n<p>이제 <code class=\"language-text\">transformJS()</code>를 살펴보자. 각각의 자바스크립트 코드 파일에서 <code class=\"language-text\">babel</code>을 통해 추상 구문 트리를 얻어내는 것이 첫 단계였다면, 두 번째 단계는\n각각의 추상 구문 트리에서 <code class=\"language-text\">import / import() / require / require.context</code>에 의해 요청되는 의존성을 수집하는 단계이다.</p>\n<p>다만 의존성을 수집하는 단계는 <code class=\"language-text\">module</code> 타입일 때만 진행한다. <code class=\"language-text\">js/script</code> 타입의 자바스크립트 파일일 경우 필요한 의존성이 없기 때문에 해당 단계를\n진행하지 않는다. 또한 최종적으로 변환되는 코드의 형태도 <code class=\"language-text\">module</code> 파일과는 다르다. <code class=\"language-text\">js/script</code> 파일의 대표적인 예시는 폴리필 파일인 경우이다.\n번들 내부의 전역에서 필요한 코드를 주입하기 위해 사용되는 스크립트인 만큼, 이는 즉시 실행 함수로 폴리필 코드를 래핑하는 변환 과정을 거친다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-transform-worker/src/index.js#L258\nasync function transformJS(file, { config, options, projectRoot }) {\n  // Transformers can output null ASTs (if they ignore the file). In that case\n  // we need to parse the module source code to get their AST.\n  let ast =\n    file.ast ??\n    babylon.parse(file.code, {\n      sourceType: &quot;unambiguous&quot;,\n    });\n  ...\n  if (file.type === &quot;js/script&quot;) {\n    dependencies = [];\n    wrappedAst = JsFileWrapping.wrapPolyfill(ast);\n  }\n  ...\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/ModuleGraph/worker/JsFileWrapping.js#L56\nfunction wrapPolyfill(fileAst) {\n  const factory = functionFromProgram(fileAst.program, [&#39;global&#39;]);\n  const iife = t.callExpression(factory, [IIFE_PARAM()]);\n  return t.file(t.program([t.expressionStatement(iife)]));\n}</code>\n        </deckgo-highlight-code>\n<p>그 예시로 리엑트 네이티브에서 주입되는 폴리필 중 <a href=\"https://github.com/facebook/react-native/blob/v0.74.2/packages/polyfills/console.js\">console.js</a>는\n다음과 같이 즉시 실행 함수로 캡슐화된다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">(function (global) {\n  /**\n   * Copyright (c) Meta Platforms, Inc. and affiliates.\n   *\n   * This source code is licensed under the MIT license found in the\n   * LICENSE file in the root directory of this source tree.\n   *\n   * @polyfill\n   * @nolint\n   * @format\n   */\n\n  ...\n\n  if (global.nativeLoggingHook) {\n    var originalConsole = global.console;\n    // Preserve the original `console` as `originalConsole`\n    if (__DEV__ &amp;&amp; originalConsole) {\n      var descriptor = Object.getOwnPropertyDescriptor(global, &#39;console&#39;);\n      if (descriptor) {\n        Object.defineProperty(global, &#39;originalConsole&#39;, descriptor);\n      }\n    }\n    global.console = {\n      error: getNativeLogFunction(LOG_LEVELS.error),\n      info: getNativeLogFunction(LOG_LEVELS.info),\n      log: getNativeLogFunction(LOG_LEVELS.info),\n      warn: getNativeLogFunction(LOG_LEVELS.warn),\n      trace: getNativeLogFunction(LOG_LEVELS.trace),\n      debug: getNativeLogFunction(LOG_LEVELS.trace),\n      table: consoleTablePolyfill,\n      group: consoleGroupPolyfill,\n      groupEnd: consoleGroupEndPolyfill,\n      groupCollapsed: consoleGroupCollapsedPolyfill,\n      assert: consoleAssertPolyfill\n    };\n    Object.defineProperty(console, &#39;_isPolyfilled&#39;, {\n      value: true,\n      enumerable: false\n    });\n\n    ...\n})(\n  typeof globalThis !== &#39;undefined&#39;\n    ? globalThis\n    : typeof global !== &#39;undefined&#39;\n      ? global\n      : typeof window !== &#39;undefined&#39;\n        ? window\n        : this\n  );</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">module</code> 타입의 파일의 경우 코드가 변환되는 과정을 예시로 살펴보기 위해 다음과 같이 <code class=\"language-text\">Button.js</code> 컴포넌트를 작성했다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// Button.js\nimport React from &#39;react&#39;;\nimport { TouchableOpacity, Text } from &#39;react-native&#39;;\n\nexport default function Button({ title, onPress }) {\n  return (\n    &lt;TouchableOpacity onPress={onPress}&gt;\n      &lt;Text&gt;{title}&lt;/Text&gt;\n    &lt;/TouchableOpacity&gt;\n  );\n}</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">module</code> 타입의 자바스크립트 코드는 변환된 추상 구문 트리로부터 의존성 수집이 이루어진다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-transform-worker/src/index.js#L258\nasync function transformJS(file, { config, options, projectRoot }) {\n  let ast =\n    file.ast ??\n    babylon.parse(file.code, {\n      sourceType: &quot;unambiguous&quot;,\n    });\n  ...\n  let dependencyMapName = &quot;&quot;;\n  let dependencies;\n  let wrappedAst;\n  if (file.type === &quot;js/script&quot;) {\n    dependencies = [];\n    wrappedAst = JsFileWrapping.wrapPolyfill(ast);\n  } else {\n    ...\n    // 의존성을 수집한다.\n    ({ ast, dependencies, dependencyMapName } = collectDependencies(\n      ast,\n      opts\n    ));\n  }\n...\n}</code>\n        </deckgo-highlight-code>\n<p>여기서 잠시 의존성을 수집하는 이유를 짚고 넘어가면 좋을 것 같아 최종적으로 <code class=\"language-text\">Button.js</code>의 변환된 결과를 다음 코드에 첨부한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// Button.js 변환 결과\n__d(\n  function(\n    global,\n    _$$_REQUIRE,\n    _$$_IMPORT_DEFAULT,\n    _$$_IMPORT_ALL,\n    module,\n    exports,\n    _dependencyMap\n  ) {\n    var _interopRequireDefault = _$$_REQUIRE(\n      _dependencyMap[0],\n      &#39;@babel/runtime/helpers/interopRequireDefault&#39;\n    );\n    Object.defineProperty(exports, &#39;__esModule&#39;, {\n      value: true,\n    });\n    exports.default = Button;\n    var _react = _interopRequireDefault(\n      _$$_REQUIRE(_dependencyMap[1], &#39;react&#39;)\n    );\n    var _reactNative = _$$_REQUIRE(_dependencyMap[2], &#39;react-native&#39;);\n    var _jsxRuntime = _$$_REQUIRE(_dependencyMap[3], &#39;react/jsx-runtime&#39;);\n    var _jsxFileName =\n      &#39;/Users/bhyoo436-fastfive/github-repos/ReactNativeUnderTheHood/src/components/Button.js&#39;;\n    function Button(_ref) {\n      ...\n    }\n  },\n  577, // Module ID\n  [1, 63, 2, 106], // _dependencyMap\n  &#39;src/components/Button.js&#39;\n);</code>\n        </deckgo-highlight-code>\n<p><code class=\"language-text\">module</code> 타입의 자바스크립트 소스 파일은 위에서 언급한 <code class=\"language-text\">__d</code>를 통해 래핑된다. 여기서 <code class=\"language-text\">__d</code>의 두 번째 인자로 전달되는 값은 본 모듈의 ID이며, 세 번째 인자로\n전달된 배열은 <code class=\"language-text\">_dependencyMap</code>로 해당 모듈에서 필요로 하는 의존성들의 ID를 배열로 가지고 있다.</p>\n<p>즉, 변환된 모듈 내부에서 의존성을 해결하기 위해 <code class=\"language-text\">_dependencyMap</code>를 구성해야 하며, 내부 코드를 <code class=\"language-text\">_dependencyMap</code>를 통해 의존성을 해결하는 방식의 코드로\n변환해야 하기 때문에 의존성을 수집하는 것이다.</p>\n<p>실제 코드상에서 의존성 수집은 <code class=\"language-text\">collectDependencies()</code>에서 담당한다. 추상 구문 트리 내의 모든 노드를 <code class=\"language-text\">@babel/traverse</code>를 통해 순회하면서 <code class=\"language-text\">import / import() / require / require.context</code>를\n표현하는 노드들을 수집하고, 수집된 실제 의존성 정보들을 <code class=\"language-text\">dependencies</code> 배열에 담아 추상 구문 트리와 함께 반환한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/ModuleGraph/worker/collectDependencies.js#L134\nfunction collectDependencies(ast, options) {\n  const visited = new WeakSet();\n  ...\n  const visitor = {\n    CallExpression(path, state) {\n      if (visited.has(path.node)) {\n        return;\n      }\n      const callee = path.node.callee;\n      const name = callee.type === &quot;Identifier&quot; ? callee.name : null;\n      if (isImport(callee)) {\n        processImportCall(path, state, {\n          asyncType: &quot;async&quot;,\n        });\n        return;\n      }\n      if (name === &quot;__prefetchImport&quot; &amp;&amp; !path.scope.getBinding(name)) {\n        processImportCall(path, state, {\n          asyncType: &quot;prefetch&quot;,\n        });\n        return;\n      }\n      // require.context\n      if (\n        state.unstable_allowRequireContext &amp;&amp;\n        callee.type === &quot;MemberExpression&quot; &amp;&amp;\n        callee.object.type === &quot;Identifier&quot; &amp;&amp;\n        callee.object.name === &quot;require&quot; &amp;&amp;\n        callee.property.type === &quot;Identifier&quot; &amp;&amp;\n        callee.property.name === &quot;context&quot; &amp;&amp;\n        !callee.computed &amp;&amp;\n        !path.scope.getBinding(&quot;require&quot;)\n      ) {\n        processRequireContextCall(path, state);\n        visited.add(path.node);\n        return;\n      }\n      // require.resolveWeak\n      if (\n        callee.type === &quot;MemberExpression&quot; &amp;&amp;\n        callee.object.type === &quot;Identifier&quot; &amp;&amp;\n        callee.object.name === &quot;require&quot; &amp;&amp;\n        callee.property.type === &quot;Identifier&quot; &amp;&amp;\n        callee.property.name === &quot;resolveWeak&quot; &amp;&amp;\n        !callee.computed &amp;&amp;\n        !path.scope.getBinding(&quot;require&quot;)\n      ) {\n        processResolveWeakCall(path, state);\n        visited.add(path.node);\n        return;\n      }\n      if (\n        name != null &amp;&amp;\n        state.dependencyCalls.has(name) &amp;&amp;\n        !path.scope.getBinding(name)\n      ) {\n        processRequireCall(path, state);\n        visited.add(path.node);\n      }\n    },\n    ...\n    traverse(ast, visitor, null, state);\n    ...\n\n    // 최종적으로 수집된 의존성 모듈들에 대한 정보를 &#39;index&#39;에 맞게 &#39;dependencies&#39;에 담는다.\n    const collectedDependencies = state.dependencyRegistry.getDependencies();\n    const dependencies = new Array(collectedDependencies.length);\n    for (const { index, name, ...dependencyData } of collectedDependencies) {\n    dependencies[index] = {\n      name,\n      data: dependencyData,\n    };\n  }\n  return {\n    ast,\n    dependencies,\n    dependencyMapName: nullthrows(state.dependencyMapIdentifier).name, // _dependencyMap\n  };\n}</code>\n        </deckgo-highlight-code>\n<p>여기서 불러오기 구문이 담겨있는지 확인하는 분기문에 부합한 대상 노드들에 대해 <code class=\"language-text\">processImportCall()</code> 혹은 <code class=\"language-text\">processRequireCall()</code>과 같은 함수들을\n통해 추상 구문 트리를 조작하고 있다. 여기서 <a href=\"https://github.com/facebook/metro/blob/v0.80.9/packages/metro/src/ModuleGraph/worker/collectDependencies.js#L778\">registerDependency</a>를 통해 해당 의존성이\n의존성 배열에 등록되며, <a href=\"https://github.com/facebook/metro/blob/v0.80.9/packages/metro/src/ModuleGraph/worker/collectDependencies.js#L665\">transformer.transformImportCall</a>을 통해\n변환된 모듈 내부 코드에서 의존성 모듈을 불러오기 위한 코드를 만들기 위해 노드를 조작한다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/ModuleGraph/worker/collectDependencies.js#L436\nfunction processImportCall(\n  path: NodePath&lt;CallExpression&gt;,\n  state: State,\n  options: ImportDependencyOptions,\n): void {\n  const name = getModuleNameFromCallArgs(path);\n  ...\n\n  // 의존성 배열에 모듈을 등록한다.\n  const dep = registerDependency(\n    state,\n    {\n      name,\n      asyncType: options.asyncType,\n      optional: isOptionalDependency(name, path, state),\n    },\n    path,\n  );\n\n  const transformer = state.dependencyTransformer;\n\n  // 모듈 불러오기 구문을 변환하기 위해 노드를 조작한다.\n  if (options.asyncType === &#39;async&#39;) {\n    transformer.transformImportCall(path, dep, state);\n  } else {\n    transformer.transformPrefetch(path, dep, state);\n  }\n}</code>\n        </deckgo-highlight-code>\n<p>마지막으로 <code class=\"language-text\">transform()</code>에서는 위 과정을 거친 조작된 추상 구문 트리를 통해 <code class=\"language-text\">__d</code> 함수를 통해 래핑하여 결과를 얻어낸다.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro-transform-worker/src/index.js#L258\nasync function transformJS(file, { config, options, projectRoot }) {\n  ...\n  ({ast: wrappedAst} = JsFileWrapping.wrapModule(\n    ast,\n    importDefault,\n    importAll,\n    dependencyMapName,\n    config.globalPrefix,\n    config.unstable_renameRequire === false\n  ));\n  ...\n}</code>\n        </deckgo-highlight-code>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// metro/src/ModuleGraph/worker/JsFileWrapping.js#L29\nfunction wrapModule(\n  fileAst: BabelNodeFile,\n  importDefaultName: string,\n  importAllName: string,\n  dependencyMapName: string,\n  globalPrefix: string,\n  skipRequireRename: boolean\n): {\n  ast: BabelNodeFile,\n  requireName: string,\n} {\n  const params = buildParameters(\n    importDefaultName,\n    importAllName,\n    dependencyMapName\n  );\n  // 익명 함수를 생성한다.\n  const factory = functionFromProgram(fileAst.program, params);\n  // 생성된 익명 함수를 매개변수로 사용하여 &#39;__d&#39; 함수 호출을 생성한다.\n  const def = t.callExpression(t.identifier(`${globalPrefix}__d`), [factory]);\n  const ast = t.file(t.program([t.expressionStatement(def)]));\n\n  // &#39;require&#39;을 &#39;$$_REQUIRE&#39;로 대체한다.\n  const requireName = skipRequireRename ? &#39;require&#39; : renameRequires(ast);\n\n  return { ast, requireName };\n}</code>\n        </deckgo-highlight-code>\n<h2 id=\"마치면서\" style=\"position:relative;\"><a href=\"#%EB%A7%88%EC%B9%98%EB%A9%B4%EC%84%9C\" aria-label=\"마치면서 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>마치면서</h2>\n<p><code class=\"language-text\">Metro</code>에 관련된 레퍼런스를 살펴보면서 연신 <code class=\"language-text\">node_modules</code> 폴더를 휘젓고, 로그를 찍어보며 취합된 내용을 한 달 만에 완성하게 되어 후련합니다.\n이전에도 리엑트를 톺아보며 동시성 기능에 대해 살펴본 경험이 있지만, 여전히 구현체들의 코드를 따라가 보며 이해하기란 쉽지 않은 일이란 걸 다시금 느낍니다.</p>\n<p>최대한 실제 코드를 바탕으로 작성했지만, 미숙하거나 잘못된 단락이 있을 수 있으니 편하게 코멘트로 지적해 주시면 감사한 마음으로 다시 살펴보겠습니다:).\n누군가 <code class=\"language-text\">Metro</code>에 대해 공부할 때 조금이나마 도움이 되는 레퍼런스가 되었으면 좋겠습니다. 긴 글 읽어주셔서 감사합니다.</p>\n<h2 id=\"reference\" style=\"position:relative;\"><a href=\"#reference\" aria-label=\"reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Reference</h2>\n<ul>\n<li><a href=\"https://geundung.dev/127\">React Native Under The Hood - 번들러(Bundler)</a></li>\n<li><a href=\"https://metrobundler.dev/docs/resolution\">Module Resolution</a></li>\n<li><a href=\"https://www.overcch.com/posts/dive-into-metro-metro-transformer\">Dive into Metro: Transformer</a></li>\n<li><a href=\"https://medium.com/airbnb-engineering/faster-javascript-builds-with-metro-cfc46d617a1f\">Faster JavaScript Builds with Metro</a></li>\n<li><a href=\"https://nodejs.org/api/modules.html#file-modules\">Node.js v22.3.0 documentation</a></li>\n<li><a href=\"https://github.com/facebook/metro\">github/metro</a></li>\n<li><a href=\"https://github.com/facebook/react-native\">github/react-native</a></li>\n<li><a href=\"https://github.com/jestjs/jest\">github/jest</a></li>\n</ul>","frontmatter":{"title":"Metro 번들러의 컨셉 톺아보기","description":"모듈 해석과 변환 과정을 살펴봅니다.","date":"May 07, 2024"}}},"pageContext":{"slug":"/react-native/metro/","previous":{"fields":{"slug":"/javascript/timezone/"},"frontmatter":{"title":"자바스크립트와 타임존, 그리고 Temporal"}},"next":null}},"staticQueryHashes":["3665086019"],"slicesMap":{}}